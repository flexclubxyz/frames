"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@resvg";
exports.ids = ["vendor-chunks/@resvg"];
exports.modules = {

/***/ "(rsc)/./node_modules/@resvg/resvg-wasm/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@resvg/resvg-wasm/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Resvg: () => (/* binding */ Resvg2),\n/* harmony export */   initWasm: () => (/* binding */ initWasm)\n/* harmony export */ });\n// wasm/dist/index.js\nvar wasm;\nvar heap = new Array(128).fill(void 0);\nheap.push(void 0, null, true, false);\nvar heap_next = heap.length;\nfunction addHeapObject(obj) {\n  if (heap_next === heap.length)\n    heap.push(heap.length + 1);\n  const idx = heap_next;\n  heap_next = heap[idx];\n  heap[idx] = obj;\n  return idx;\n}\nfunction getObject(idx) {\n  return heap[idx];\n}\nfunction dropObject(idx) {\n  if (idx < 132)\n    return;\n  heap[idx] = heap_next;\n  heap_next = idx;\n}\nfunction takeObject(idx) {\n  const ret = getObject(idx);\n  dropObject(idx);\n  return ret;\n}\nvar WASM_VECTOR_LEN = 0;\nvar cachedUint8Memory0 = null;\nfunction getUint8Memory0() {\n  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachedUint8Memory0;\n}\nvar cachedTextEncoder = new TextEncoder(\"utf-8\");\nvar encodeString = typeof cachedTextEncoder.encodeInto === \"function\" ? function(arg, view) {\n  return cachedTextEncoder.encodeInto(arg, view);\n} : function(arg, view) {\n  const buf = cachedTextEncoder.encode(arg);\n  view.set(buf);\n  return {\n    read: arg.length,\n    written: buf.length\n  };\n};\nfunction passStringToWasm0(arg, malloc, realloc) {\n  if (realloc === void 0) {\n    const buf = cachedTextEncoder.encode(arg);\n    const ptr2 = malloc(buf.length);\n    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);\n    WASM_VECTOR_LEN = buf.length;\n    return ptr2;\n  }\n  let len = arg.length;\n  let ptr = malloc(len);\n  const mem = getUint8Memory0();\n  let offset = 0;\n  for (; offset < len; offset++) {\n    const code = arg.charCodeAt(offset);\n    if (code > 127)\n      break;\n    mem[ptr + offset] = code;\n  }\n  if (offset !== len) {\n    if (offset !== 0) {\n      arg = arg.slice(offset);\n    }\n    ptr = realloc(ptr, len, len = offset + arg.length * 3);\n    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n    const ret = encodeString(arg, view);\n    offset += ret.written;\n  }\n  WASM_VECTOR_LEN = offset;\n  return ptr;\n}\nfunction isLikeNone(x) {\n  return x === void 0 || x === null;\n}\nvar cachedInt32Memory0 = null;\nfunction getInt32Memory0() {\n  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n  }\n  return cachedInt32Memory0;\n}\nvar cachedTextDecoder = new TextDecoder(\"utf-8\", { ignoreBOM: true, fatal: true });\ncachedTextDecoder.decode();\nfunction getStringFromWasm0(ptr, len) {\n  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\nfunction _assertClass(instance, klass) {\n  if (!(instance instanceof klass)) {\n    throw new Error(`expected instance of ${klass.name}`);\n  }\n  return instance.ptr;\n}\nvar BBox = class {\n  static __wrap(ptr) {\n    const obj = Object.create(BBox.prototype);\n    obj.ptr = ptr;\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.ptr;\n    this.ptr = 0;\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_bbox_free(ptr);\n  }\n  /**\n  * @returns {number}\n  */\n  get x() {\n    const ret = wasm.__wbg_get_bbox_x(this.ptr);\n    return ret;\n  }\n  /**\n  * @param {number} arg0\n  */\n  set x(arg0) {\n    wasm.__wbg_set_bbox_x(this.ptr, arg0);\n  }\n  /**\n  * @returns {number}\n  */\n  get y() {\n    const ret = wasm.__wbg_get_bbox_y(this.ptr);\n    return ret;\n  }\n  /**\n  * @param {number} arg0\n  */\n  set y(arg0) {\n    wasm.__wbg_set_bbox_y(this.ptr, arg0);\n  }\n  /**\n  * @returns {number}\n  */\n  get width() {\n    const ret = wasm.__wbg_get_bbox_width(this.ptr);\n    return ret;\n  }\n  /**\n  * @param {number} arg0\n  */\n  set width(arg0) {\n    wasm.__wbg_set_bbox_width(this.ptr, arg0);\n  }\n  /**\n  * @returns {number}\n  */\n  get height() {\n    const ret = wasm.__wbg_get_bbox_height(this.ptr);\n    return ret;\n  }\n  /**\n  * @param {number} arg0\n  */\n  set height(arg0) {\n    wasm.__wbg_set_bbox_height(this.ptr, arg0);\n  }\n};\nvar RenderedImage = class {\n  static __wrap(ptr) {\n    const obj = Object.create(RenderedImage.prototype);\n    obj.ptr = ptr;\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.ptr;\n    this.ptr = 0;\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_renderedimage_free(ptr);\n  }\n  /**\n  * Get the PNG width\n  * @returns {number}\n  */\n  get width() {\n    const ret = wasm.renderedimage_width(this.ptr);\n    return ret >>> 0;\n  }\n  /**\n  * Get the PNG height\n  * @returns {number}\n  */\n  get height() {\n    const ret = wasm.renderedimage_height(this.ptr);\n    return ret >>> 0;\n  }\n  /**\n  * Write the image data to Uint8Array\n  * @returns {Uint8Array}\n  */\n  asPng() {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      wasm.renderedimage_asPng(retptr, this.ptr);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      var r2 = getInt32Memory0()[retptr / 4 + 2];\n      if (r2) {\n        throw takeObject(r1);\n      }\n      return takeObject(r0);\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n  }\n  /**\n  * Get the RGBA pixels of the image\n  * @returns {Uint8Array}\n  */\n  get pixels() {\n    const ret = wasm.renderedimage_pixels(this.ptr);\n    return takeObject(ret);\n  }\n};\nvar Resvg = class {\n  static __wrap(ptr) {\n    const obj = Object.create(Resvg.prototype);\n    obj.ptr = ptr;\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.ptr;\n    this.ptr = 0;\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_resvg_free(ptr);\n  }\n  /**\n  * @param {Uint8Array | string} svg\n  * @param {string | undefined} options\n  */\n  constructor(svg, options) {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      var ptr0 = isLikeNone(options) ? 0 : passStringToWasm0(options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n      var len0 = WASM_VECTOR_LEN;\n      wasm.resvg_new(retptr, addHeapObject(svg), ptr0, len0);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      var r2 = getInt32Memory0()[retptr / 4 + 2];\n      if (r2) {\n        throw takeObject(r1);\n      }\n      return Resvg.__wrap(r0);\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n  }\n  /**\n  * Get the SVG width\n  * @returns {number}\n  */\n  get width() {\n    const ret = wasm.resvg_width(this.ptr);\n    return ret;\n  }\n  /**\n  * Get the SVG height\n  * @returns {number}\n  */\n  get height() {\n    const ret = wasm.resvg_height(this.ptr);\n    return ret;\n  }\n  /**\n  * Renders an SVG in Wasm\n  * @returns {RenderedImage}\n  */\n  render() {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      wasm.resvg_render(retptr, this.ptr);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      var r2 = getInt32Memory0()[retptr / 4 + 2];\n      if (r2) {\n        throw takeObject(r1);\n      }\n      return RenderedImage.__wrap(r0);\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n  }\n  /**\n  * Output usvg-simplified SVG string\n  * @returns {string}\n  */\n  toString() {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      wasm.resvg_toString(retptr, this.ptr);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      return getStringFromWasm0(r0, r1);\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n      wasm.__wbindgen_free(r0, r1);\n    }\n  }\n  /**\n  * Calculate a maximum bounding box of all visible elements in this SVG.\n  *\n  * Note: path bounding box are approx values.\n  * @returns {BBox | undefined}\n  */\n  innerBBox() {\n    const ret = wasm.resvg_innerBBox(this.ptr);\n    return ret === 0 ? void 0 : BBox.__wrap(ret);\n  }\n  /**\n  * Calculate a maximum bounding box of all visible elements in this SVG.\n  * This will first apply transform.\n  * Similar to `SVGGraphicsElement.getBBox()` DOM API.\n  * @returns {BBox | undefined}\n  */\n  getBBox() {\n    const ret = wasm.resvg_getBBox(this.ptr);\n    return ret === 0 ? void 0 : BBox.__wrap(ret);\n  }\n  /**\n  * Use a given `BBox` to crop the svg. Currently this method simply changes\n  * the viewbox/size of the svg and do not move the elements for simplicity\n  * @param {BBox} bbox\n  */\n  cropByBBox(bbox) {\n    _assertClass(bbox, BBox);\n    wasm.resvg_cropByBBox(this.ptr, bbox.ptr);\n  }\n  /**\n  * @returns {Array<any>}\n  */\n  imagesToResolve() {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      wasm.resvg_imagesToResolve(retptr, this.ptr);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      var r2 = getInt32Memory0()[retptr / 4 + 2];\n      if (r2) {\n        throw takeObject(r1);\n      }\n      return takeObject(r0);\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n  }\n  /**\n  * @param {string} href\n  * @param {Uint8Array} buffer\n  */\n  resolveImage(href, buffer) {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      const ptr0 = passStringToWasm0(href, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n      const len0 = WASM_VECTOR_LEN;\n      wasm.resvg_resolveImage(retptr, this.ptr, ptr0, len0, addHeapObject(buffer));\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      if (r1) {\n        throw takeObject(r0);\n      }\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n  }\n};\nasync function load(module, imports) {\n  if (typeof Response === \"function\" && module instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming === \"function\") {\n      try {\n        return await WebAssembly.instantiateStreaming(module, imports);\n      } catch (e) {\n        if (module.headers.get(\"Content-Type\") != \"application/wasm\") {\n          console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n        } else {\n          throw e;\n        }\n      }\n    }\n    const bytes = await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, imports);\n  } else {\n    const instance = await WebAssembly.instantiate(module, imports);\n    if (instance instanceof WebAssembly.Instance) {\n      return { instance, module };\n    } else {\n      return instance;\n    }\n  }\n}\nfunction getImports() {\n  const imports = {};\n  imports.wbg = {};\n  imports.wbg.__wbg_new_15d3966e9981a196 = function(arg0, arg1) {\n    const ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_memory = function() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_buffer_cf65c07de34b9a08 = function(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5 = function(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n    takeObject(arg0);\n  };\n  imports.wbg.__wbg_new_537b7341ce90bb31 = function(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_instanceof_Uint8Array_01cebe79ca606cca = function(arg0) {\n    let result;\n    try {\n      result = getObject(arg0) instanceof Uint8Array;\n    } catch (e) {\n      result = false;\n    }\n    const ret = result;\n    return ret;\n  };\n  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof obj === \"string\" ? obj : void 0;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n  };\n  imports.wbg.__wbg_new_b525de17f44a8943 = function() {\n    const ret = new Array();\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_push_49c286f04dd3bf59 = function(arg0, arg1) {\n    const ret = getObject(arg0).push(getObject(arg1));\n    return ret;\n  };\n  imports.wbg.__wbg_length_27a2afe8ab42b09f = function(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n  };\n  imports.wbg.__wbg_set_17499e8aa4003ebd = function(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n  };\n  imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n  };\n  return imports;\n}\nfunction initMemory(imports, maybe_memory) {\n}\nfunction finalizeInit(instance, module) {\n  wasm = instance.exports;\n  init.__wbindgen_wasm_module = module;\n  cachedInt32Memory0 = null;\n  cachedUint8Memory0 = null;\n  return wasm;\n}\nasync function init(input) {\n  if (typeof input === \"undefined\") {\n    input = new URL(\"index_bg.wasm\", void 0);\n  }\n  const imports = getImports();\n  if (typeof input === \"string\" || typeof Request === \"function\" && input instanceof Request || typeof URL === \"function\" && input instanceof URL) {\n    input = fetch(input);\n  }\n  initMemory(imports);\n  const { instance, module } = await load(await input, imports);\n  return finalizeInit(instance, module);\n}\nvar dist_default = init;\n\n// wasm-binding.ts\nvar initialized = false;\nvar initWasm = async (module_or_path) => {\n  if (initialized) {\n    throw new Error(\"Already initialized. The `initWasm()` function can be used only once.\");\n  }\n  await dist_default(await module_or_path);\n  initialized = true;\n};\nvar Resvg2 = class extends Resvg {\n  /**\n   * @param {Uint8Array | string} svg\n   * @param {ResvgRenderOptions | undefined} options\n   */\n  constructor(svg, options) {\n    if (!initialized)\n      throw new Error(\"Wasm has not been initialized. Call `initWasm()` function.\");\n    super(svg, JSON.stringify(options));\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHJlc3ZnL3Jlc3ZnLXdhc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsOEJBQThCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcmVzdmcvcmVzdmctd2FzbS9pbmRleC5tanM/YWNiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB3YXNtL2Rpc3QvaW5kZXguanNcbnZhciB3YXNtO1xudmFyIGhlYXAgPSBuZXcgQXJyYXkoMTI4KS5maWxsKHZvaWQgMCk7XG5oZWFwLnB1c2godm9pZCAwLCBudWxsLCB0cnVlLCBmYWxzZSk7XG52YXIgaGVhcF9uZXh0ID0gaGVhcC5sZW5ndGg7XG5mdW5jdGlvbiBhZGRIZWFwT2JqZWN0KG9iaikge1xuICBpZiAoaGVhcF9uZXh0ID09PSBoZWFwLmxlbmd0aClcbiAgICBoZWFwLnB1c2goaGVhcC5sZW5ndGggKyAxKTtcbiAgY29uc3QgaWR4ID0gaGVhcF9uZXh0O1xuICBoZWFwX25leHQgPSBoZWFwW2lkeF07XG4gIGhlYXBbaWR4XSA9IG9iajtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGdldE9iamVjdChpZHgpIHtcbiAgcmV0dXJuIGhlYXBbaWR4XTtcbn1cbmZ1bmN0aW9uIGRyb3BPYmplY3QoaWR4KSB7XG4gIGlmIChpZHggPCAxMzIpXG4gICAgcmV0dXJuO1xuICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7XG4gIGhlYXBfbmV4dCA9IGlkeDtcbn1cbmZ1bmN0aW9uIHRha2VPYmplY3QoaWR4KSB7XG4gIGNvbnN0IHJldCA9IGdldE9iamVjdChpZHgpO1xuICBkcm9wT2JqZWN0KGlkeCk7XG4gIHJldHVybiByZXQ7XG59XG52YXIgV0FTTV9WRUNUT1JfTEVOID0gMDtcbnZhciBjYWNoZWRVaW50OE1lbW9yeTAgPSBudWxsO1xuZnVuY3Rpb24gZ2V0VWludDhNZW1vcnkwKCkge1xuICBpZiAoY2FjaGVkVWludDhNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZFVpbnQ4TWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgY2FjaGVkVWludDhNZW1vcnkwID0gbmV3IFVpbnQ4QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgfVxuICByZXR1cm4gY2FjaGVkVWludDhNZW1vcnkwO1xufVxudmFyIGNhY2hlZFRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKFwidXRmLThcIik7XG52YXIgZW5jb2RlU3RyaW5nID0gdHlwZW9mIGNhY2hlZFRleHRFbmNvZGVyLmVuY29kZUludG8gPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKGFyZywgdmlldykge1xuICByZXR1cm4gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byhhcmcsIHZpZXcpO1xufSA6IGZ1bmN0aW9uKGFyZywgdmlldykge1xuICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgdmlldy5zZXQoYnVmKTtcbiAgcmV0dXJuIHtcbiAgICByZWFkOiBhcmcubGVuZ3RoLFxuICAgIHdyaXR0ZW46IGJ1Zi5sZW5ndGhcbiAgfTtcbn07XG5mdW5jdGlvbiBwYXNzU3RyaW5nVG9XYXNtMChhcmcsIG1hbGxvYywgcmVhbGxvYykge1xuICBpZiAocmVhbGxvYyA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgY29uc3QgcHRyMiA9IG1hbGxvYyhidWYubGVuZ3RoKTtcbiAgICBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIyLCBwdHIyICsgYnVmLmxlbmd0aCkuc2V0KGJ1Zik7XG4gICAgV0FTTV9WRUNUT1JfTEVOID0gYnVmLmxlbmd0aDtcbiAgICByZXR1cm4gcHRyMjtcbiAgfVxuICBsZXQgbGVuID0gYXJnLmxlbmd0aDtcbiAgbGV0IHB0ciA9IG1hbGxvYyhsZW4pO1xuICBjb25zdCBtZW0gPSBnZXRVaW50OE1lbW9yeTAoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKSB7XG4gICAgY29uc3QgY29kZSA9IGFyZy5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgaWYgKGNvZGUgPiAxMjcpXG4gICAgICBicmVhaztcbiAgICBtZW1bcHRyICsgb2Zmc2V0XSA9IGNvZGU7XG4gIH1cbiAgaWYgKG9mZnNldCAhPT0gbGVuKSB7XG4gICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgYXJnID0gYXJnLnNsaWNlKG9mZnNldCk7XG4gICAgfVxuICAgIHB0ciA9IHJlYWxsb2MocHRyLCBsZW4sIGxlbiA9IG9mZnNldCArIGFyZy5sZW5ndGggKiAzKTtcbiAgICBjb25zdCB2aWV3ID0gZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyICsgb2Zmc2V0LCBwdHIgKyBsZW4pO1xuICAgIGNvbnN0IHJldCA9IGVuY29kZVN0cmluZyhhcmcsIHZpZXcpO1xuICAgIG9mZnNldCArPSByZXQud3JpdHRlbjtcbiAgfVxuICBXQVNNX1ZFQ1RPUl9MRU4gPSBvZmZzZXQ7XG4gIHJldHVybiBwdHI7XG59XG5mdW5jdGlvbiBpc0xpa2VOb25lKHgpIHtcbiAgcmV0dXJuIHggPT09IHZvaWQgMCB8fCB4ID09PSBudWxsO1xufVxudmFyIGNhY2hlZEludDMyTWVtb3J5MCA9IG51bGw7XG5mdW5jdGlvbiBnZXRJbnQzMk1lbW9yeTAoKSB7XG4gIGlmIChjYWNoZWRJbnQzMk1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVkSW50MzJNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICBjYWNoZWRJbnQzMk1lbW9yeTAgPSBuZXcgSW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICB9XG4gIHJldHVybiBjYWNoZWRJbnQzMk1lbW9yeTA7XG59XG52YXIgY2FjaGVkVGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiLCB7IGlnbm9yZUJPTTogdHJ1ZSwgZmF0YWw6IHRydWUgfSk7XG5jYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTtcbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21XYXNtMChwdHIsIGxlbikge1xuICByZXR1cm4gY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgbGVuKSk7XG59XG5mdW5jdGlvbiBfYXNzZXJ0Q2xhc3MoaW5zdGFuY2UsIGtsYXNzKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2Yga2xhc3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBpbnN0YW5jZSBvZiAke2tsYXNzLm5hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlLnB0cjtcbn1cbnZhciBCQm94ID0gY2xhc3Mge1xuICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoQkJveC5wcm90b3R5cGUpO1xuICAgIG9iai5wdHIgPSBwdHI7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgY29uc3QgcHRyID0gdGhpcy5wdHI7XG4gICAgdGhpcy5wdHIgPSAwO1xuICAgIHJldHVybiBwdHI7XG4gIH1cbiAgZnJlZSgpIHtcbiAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIHdhc20uX193YmdfYmJveF9mcmVlKHB0cik7XG4gIH1cbiAgLyoqXG4gICogQHJldHVybnMge251bWJlcn1cbiAgKi9cbiAgZ2V0IHgoKSB7XG4gICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfYmJveF94KHRoaXMucHRyKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcwXG4gICovXG4gIHNldCB4KGFyZzApIHtcbiAgICB3YXNtLl9fd2JnX3NldF9iYm94X3godGhpcy5wdHIsIGFyZzApO1xuICB9XG4gIC8qKlxuICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICovXG4gIGdldCB5KCkge1xuICAgIGNvbnN0IHJldCA9IHdhc20uX193YmdfZ2V0X2Jib3hfeSh0aGlzLnB0cik7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0gYXJnMFxuICAqL1xuICBzZXQgeShhcmcwKSB7XG4gICAgd2FzbS5fX3diZ19zZXRfYmJveF95KHRoaXMucHRyLCBhcmcwKTtcbiAgfVxuICAvKipcbiAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfYmJveF93aWR0aCh0aGlzLnB0cik7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0gYXJnMFxuICAqL1xuICBzZXQgd2lkdGgoYXJnMCkge1xuICAgIHdhc20uX193Ymdfc2V0X2Jib3hfd2lkdGgodGhpcy5wdHIsIGFyZzApO1xuICB9XG4gIC8qKlxuICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgY29uc3QgcmV0ID0gd2FzbS5fX3diZ19nZXRfYmJveF9oZWlnaHQodGhpcy5wdHIpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGFyZzBcbiAgKi9cbiAgc2V0IGhlaWdodChhcmcwKSB7XG4gICAgd2FzbS5fX3diZ19zZXRfYmJveF9oZWlnaHQodGhpcy5wdHIsIGFyZzApO1xuICB9XG59O1xudmFyIFJlbmRlcmVkSW1hZ2UgPSBjbGFzcyB7XG4gIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSZW5kZXJlZEltYWdlLnByb3RvdHlwZSk7XG4gICAgb2JqLnB0ciA9IHB0cjtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjtcbiAgICB0aGlzLnB0ciA9IDA7XG4gICAgcmV0dXJuIHB0cjtcbiAgfVxuICBmcmVlKCkge1xuICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgd2FzbS5fX3diZ19yZW5kZXJlZGltYWdlX2ZyZWUocHRyKTtcbiAgfVxuICAvKipcbiAgKiBHZXQgdGhlIFBORyB3aWR0aFxuICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICBjb25zdCByZXQgPSB3YXNtLnJlbmRlcmVkaW1hZ2Vfd2lkdGgodGhpcy5wdHIpO1xuICAgIHJldHVybiByZXQgPj4+IDA7XG4gIH1cbiAgLyoqXG4gICogR2V0IHRoZSBQTkcgaGVpZ2h0XG4gICogQHJldHVybnMge251bWJlcn1cbiAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICBjb25zdCByZXQgPSB3YXNtLnJlbmRlcmVkaW1hZ2VfaGVpZ2h0KHRoaXMucHRyKTtcbiAgICByZXR1cm4gcmV0ID4+PiAwO1xuICB9XG4gIC8qKlxuICAqIFdyaXRlIHRoZSBpbWFnZSBkYXRhIHRvIFVpbnQ4QXJyYXlcbiAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgKi9cbiAgYXNQbmcoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgd2FzbS5yZW5kZXJlZGltYWdlX2FzUG5nKHJldHB0ciwgdGhpcy5wdHIpO1xuICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgaWYgKHIyKSB7XG4gICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBHZXQgdGhlIFJHQkEgcGl4ZWxzIG9mIHRoZSBpbWFnZVxuICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAqL1xuICBnZXQgcGl4ZWxzKCkge1xuICAgIGNvbnN0IHJldCA9IHdhc20ucmVuZGVyZWRpbWFnZV9waXhlbHModGhpcy5wdHIpO1xuICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gIH1cbn07XG52YXIgUmVzdmcgPSBjbGFzcyB7XG4gIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSZXN2Zy5wcm90b3R5cGUpO1xuICAgIG9iai5wdHIgPSBwdHI7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgY29uc3QgcHRyID0gdGhpcy5wdHI7XG4gICAgdGhpcy5wdHIgPSAwO1xuICAgIHJldHVybiBwdHI7XG4gIH1cbiAgZnJlZSgpIHtcbiAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgIHdhc20uX193YmdfcmVzdmdfZnJlZShwdHIpO1xuICB9XG4gIC8qKlxuICAqIEBwYXJhbSB7VWludDhBcnJheSB8IHN0cmluZ30gc3ZnXG4gICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IG9wdGlvbnNcbiAgKi9cbiAgY29uc3RydWN0b3Ioc3ZnLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgdmFyIHB0cjAgPSBpc0xpa2VOb25lKG9wdGlvbnMpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKG9wdGlvbnMsIHdhc20uX193YmluZGdlbl9tYWxsb2MsIHdhc20uX193YmluZGdlbl9yZWFsbG9jKTtcbiAgICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgd2FzbS5yZXN2Z19uZXcocmV0cHRyLCBhZGRIZWFwT2JqZWN0KHN2ZyksIHB0cjAsIGxlbjApO1xuICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgaWYgKHIyKSB7XG4gICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlc3ZnLl9fd3JhcChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIEdldCB0aGUgU1ZHIHdpZHRoXG4gICogQHJldHVybnMge251bWJlcn1cbiAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIGNvbnN0IHJldCA9IHdhc20ucmVzdmdfd2lkdGgodGhpcy5wdHIpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLyoqXG4gICogR2V0IHRoZSBTVkcgaGVpZ2h0XG4gICogQHJldHVybnMge251bWJlcn1cbiAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICBjb25zdCByZXQgPSB3YXNtLnJlc3ZnX2hlaWdodCh0aGlzLnB0cik7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvKipcbiAgKiBSZW5kZXJzIGFuIFNWRyBpbiBXYXNtXG4gICogQHJldHVybnMge1JlbmRlcmVkSW1hZ2V9XG4gICovXG4gIHJlbmRlcigpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICB3YXNtLnJlc3ZnX3JlbmRlcihyZXRwdHIsIHRoaXMucHRyKTtcbiAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgIGlmIChyMikge1xuICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZW5kZXJlZEltYWdlLl9fd3JhcChyMCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIE91dHB1dCB1c3ZnLXNpbXBsaWZpZWQgU1ZHIHN0cmluZ1xuICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgIHdhc20ucmVzdmdfdG9TdHJpbmcocmV0cHRyLCB0aGlzLnB0cik7XG4gICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBDYWxjdWxhdGUgYSBtYXhpbXVtIGJvdW5kaW5nIGJveCBvZiBhbGwgdmlzaWJsZSBlbGVtZW50cyBpbiB0aGlzIFNWRy5cbiAgKlxuICAqIE5vdGU6IHBhdGggYm91bmRpbmcgYm94IGFyZSBhcHByb3ggdmFsdWVzLlxuICAqIEByZXR1cm5zIHtCQm94IHwgdW5kZWZpbmVkfVxuICAqL1xuICBpbm5lckJCb3goKSB7XG4gICAgY29uc3QgcmV0ID0gd2FzbS5yZXN2Z19pbm5lckJCb3godGhpcy5wdHIpO1xuICAgIHJldHVybiByZXQgPT09IDAgPyB2b2lkIDAgOiBCQm94Ll9fd3JhcChyZXQpO1xuICB9XG4gIC8qKlxuICAqIENhbGN1bGF0ZSBhIG1heGltdW0gYm91bmRpbmcgYm94IG9mIGFsbCB2aXNpYmxlIGVsZW1lbnRzIGluIHRoaXMgU1ZHLlxuICAqIFRoaXMgd2lsbCBmaXJzdCBhcHBseSB0cmFuc2Zvcm0uXG4gICogU2ltaWxhciB0byBgU1ZHR3JhcGhpY3NFbGVtZW50LmdldEJCb3goKWAgRE9NIEFQSS5cbiAgKiBAcmV0dXJucyB7QkJveCB8IHVuZGVmaW5lZH1cbiAgKi9cbiAgZ2V0QkJveCgpIHtcbiAgICBjb25zdCByZXQgPSB3YXNtLnJlc3ZnX2dldEJCb3godGhpcy5wdHIpO1xuICAgIHJldHVybiByZXQgPT09IDAgPyB2b2lkIDAgOiBCQm94Ll9fd3JhcChyZXQpO1xuICB9XG4gIC8qKlxuICAqIFVzZSBhIGdpdmVuIGBCQm94YCB0byBjcm9wIHRoZSBzdmcuIEN1cnJlbnRseSB0aGlzIG1ldGhvZCBzaW1wbHkgY2hhbmdlc1xuICAqIHRoZSB2aWV3Ym94L3NpemUgb2YgdGhlIHN2ZyBhbmQgZG8gbm90IG1vdmUgdGhlIGVsZW1lbnRzIGZvciBzaW1wbGljaXR5XG4gICogQHBhcmFtIHtCQm94fSBiYm94XG4gICovXG4gIGNyb3BCeUJCb3goYmJveCkge1xuICAgIF9hc3NlcnRDbGFzcyhiYm94LCBCQm94KTtcbiAgICB3YXNtLnJlc3ZnX2Nyb3BCeUJCb3godGhpcy5wdHIsIGJib3gucHRyKTtcbiAgfVxuICAvKipcbiAgKiBAcmV0dXJucyB7QXJyYXk8YW55Pn1cbiAgKi9cbiAgaW1hZ2VzVG9SZXNvbHZlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgIHdhc20ucmVzdmdfaW1hZ2VzVG9SZXNvbHZlKHJldHB0ciwgdGhpcy5wdHIpO1xuICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgaWYgKHIyKSB7XG4gICAgICAgIHRocm93IHRha2VPYmplY3QocjEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRha2VPYmplY3QocjApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZlxuICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyXG4gICovXG4gIHJlc29sdmVJbWFnZShocmVmLCBidWZmZXIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoaHJlZiwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgIHdhc20ucmVzdmdfcmVzb2x2ZUltYWdlKHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjAsIGFkZEhlYXBPYmplY3QoYnVmZmVyKSk7XG4gICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICBpZiAocjEpIHtcbiAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gbG9hZChtb2R1bGUsIGltcG9ydHMpIHtcbiAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gXCJmdW5jdGlvblwiICYmIG1vZHVsZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcobW9kdWxlLCBpbXBvcnRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKG1vZHVsZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSAhPSBcImFwcGxpY2F0aW9uL3dhc21cIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcImBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ2AgZmFpbGVkIGJlY2F1c2UgeW91ciBzZXJ2ZXIgZG9lcyBub3Qgc2VydmUgd2FzbSB3aXRoIGBhcHBsaWNhdGlvbi93YXNtYCBNSU1FIHR5cGUuIEZhbGxpbmcgYmFjayB0byBgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVgIHdoaWNoIGlzIHNsb3dlci4gT3JpZ2luYWwgZXJyb3I6XFxuXCIsIGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBtb2R1bGUuYXJyYXlCdWZmZXIoKTtcbiAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnl0ZXMsIGltcG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kdWxlLCBpbXBvcnRzKTtcbiAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIHsgaW5zdGFuY2UsIG1vZHVsZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRJbXBvcnRzKCkge1xuICBjb25zdCBpbXBvcnRzID0ge307XG4gIGltcG9ydHMud2JnID0ge307XG4gIGltcG9ydHMud2JnLl9fd2JnX25ld18xNWQzOTY2ZTk5ODFhMTk2ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gIH07XG4gIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fbWVtb3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgcmV0ID0gd2FzbS5tZW1vcnk7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgfTtcbiAgaW1wb3J0cy53YmcuX193YmdfYnVmZmVyX2NmNjVjMDdkZTM0YjlhMDggPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmJ1ZmZlcjtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF85ZmIyZjExMzU1ZWNhZGY1ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KGdldE9iamVjdChhcmcwKSwgYXJnMSA+Pj4gMCwgYXJnMiA+Pj4gMCk7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgfTtcbiAgaW1wb3J0cy53YmcuX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgdGFrZU9iamVjdChhcmcwKTtcbiAgfTtcbiAgaW1wb3J0cy53YmcuX193YmdfbmV3XzUzN2I3MzQxY2U5MGJiMzEgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoZ2V0T2JqZWN0KGFyZzApKTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diZ19pbnN0YW5jZW9mX1VpbnQ4QXJyYXlfMDFjZWJlNzljYTYwNmNjYSA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBnZXRPYmplY3QoYXJnMCkgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgaW1wb3J0cy53YmcuX193YmluZGdlbl9zdHJpbmdfZ2V0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IG9iaiA9IGdldE9iamVjdChhcmcxKTtcbiAgICBjb25zdCByZXQgPSB0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiID8gb2JqIDogdm9pZCAwO1xuICAgIHZhciBwdHIwID0gaXNMaWtlTm9uZShyZXQpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgIHZhciBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMV0gPSBsZW4wO1xuICAgIGdldEludDMyTWVtb3J5MCgpW2FyZzAgLyA0ICsgMF0gPSBwdHIwO1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diZ19uZXdfYjUyNWRlMTdmNDRhODk0MyA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheSgpO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG4gIH07XG4gIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fc3RyaW5nX25ldyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICBjb25zdCByZXQgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSk7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgfTtcbiAgaW1wb3J0cy53YmcuX193YmdfcHVzaF80OWMyODZmMDRkZDNiZjU5ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5wdXNoKGdldE9iamVjdChhcmcxKSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgaW1wb3J0cy53YmcuX193YmdfbGVuZ3RoXzI3YTJhZmU4YWI0MmIwOWYgPSBmdW5jdGlvbihhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICBpbXBvcnRzLndiZy5fX3diZ19zZXRfMTc0OTllOGFhNDAwM2ViZCA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICBnZXRPYmplY3QoYXJnMCkuc2V0KGdldE9iamVjdChhcmcxKSwgYXJnMiA+Pj4gMCk7XG4gIH07XG4gIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fdGhyb3cgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7XG4gIH07XG4gIHJldHVybiBpbXBvcnRzO1xufVxuZnVuY3Rpb24gaW5pdE1lbW9yeShpbXBvcnRzLCBtYXliZV9tZW1vcnkpIHtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplSW5pdChpbnN0YW5jZSwgbW9kdWxlKSB7XG4gIHdhc20gPSBpbnN0YW5jZS5leHBvcnRzO1xuICBpbml0Ll9fd2JpbmRnZW5fd2FzbV9tb2R1bGUgPSBtb2R1bGU7XG4gIGNhY2hlZEludDMyTWVtb3J5MCA9IG51bGw7XG4gIGNhY2hlZFVpbnQ4TWVtb3J5MCA9IG51bGw7XG4gIHJldHVybiB3YXNtO1xufVxuYXN5bmMgZnVuY3Rpb24gaW5pdChpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaW5wdXQgPSBuZXcgVVJMKFwiaW5kZXhfYmcud2FzbVwiLCB2b2lkIDApO1xuICB9XG4gIGNvbnN0IGltcG9ydHMgPSBnZXRJbXBvcnRzKCk7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIFJlcXVlc3QgPT09IFwiZnVuY3Rpb25cIiAmJiBpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QgfHwgdHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmIGlucHV0IGluc3RhbmNlb2YgVVJMKSB7XG4gICAgaW5wdXQgPSBmZXRjaChpbnB1dCk7XG4gIH1cbiAgaW5pdE1lbW9yeShpbXBvcnRzKTtcbiAgY29uc3QgeyBpbnN0YW5jZSwgbW9kdWxlIH0gPSBhd2FpdCBsb2FkKGF3YWl0IGlucHV0LCBpbXBvcnRzKTtcbiAgcmV0dXJuIGZpbmFsaXplSW5pdChpbnN0YW5jZSwgbW9kdWxlKTtcbn1cbnZhciBkaXN0X2RlZmF1bHQgPSBpbml0O1xuXG4vLyB3YXNtLWJpbmRpbmcudHNcbnZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xudmFyIGluaXRXYXNtID0gYXN5bmMgKG1vZHVsZV9vcl9wYXRoKSA9PiB7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgaW5pdGlhbGl6ZWQuIFRoZSBgaW5pdFdhc20oKWAgZnVuY3Rpb24gY2FuIGJlIHVzZWQgb25seSBvbmNlLlwiKTtcbiAgfVxuICBhd2FpdCBkaXN0X2RlZmF1bHQoYXdhaXQgbW9kdWxlX29yX3BhdGgpO1xuICBpbml0aWFsaXplZCA9IHRydWU7XG59O1xudmFyIFJlc3ZnMiA9IGNsYXNzIGV4dGVuZHMgUmVzdmcge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgc3RyaW5nfSBzdmdcbiAgICogQHBhcmFtIHtSZXN2Z1JlbmRlck9wdGlvbnMgfCB1bmRlZmluZWR9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHN2Zywgb3B0aW9ucykge1xuICAgIGlmICghaW5pdGlhbGl6ZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYXNtIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4gQ2FsbCBgaW5pdFdhc20oKWAgZnVuY3Rpb24uXCIpO1xuICAgIHN1cGVyKHN2ZywgSlNPTi5zdHJpbmdpZnkob3B0aW9ucykpO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgUmVzdmcyIGFzIFJlc3ZnLFxuICBpbml0V2FzbVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@resvg/resvg-wasm/index.mjs\n");

/***/ })

};
;