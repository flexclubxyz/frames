"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@shuding";
exports.ids = ["vendor-chunks/@shuding"];
exports.modules = {

/***/ "(rsc)/./node_modules/@shuding/opentype.js/dist/opentype.module.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@shuding/opentype.js/dist/opentype.module.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   Glyph: () => (/* binding */ Glyph),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   _parse: () => (/* binding */ parse),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   loadSync: () => (/* binding */ loadSync),\n/* harmony export */   parse: () => (/* binding */ parseBuffer)\n/* harmony export */ });\n/**\n * https://opentype.js.org v1.3.5 | (c) Frederik De Bleser and other contributors | MIT License | Uses fflate by 101arrowz and string.prototype.codepointat polyfill by Mathias Bynens\n */\n\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            { ++l[cd[i] - 1]; }\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    { flt[i] = 8; }\nfor (var i = 144; i < 256; ++i)\n    { flt[i] = 9; }\nfor (var i = 256; i < 280; ++i)\n    { flt[i] = 7; }\nfor (var i = 280; i < 288; ++i)\n    { flt[i] = 8; }\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    { fdt[i] = 5; }\n// fixed length map\nvar flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            { m = a[i]; }\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        { s = 0; }\n    if (e == null || e > v.length)\n        { e = v.length; }\n    // can't use .constructor in case user-supplied\n    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        { Error.captureStackTrace(e, err); }\n    if (!nt)\n        { throw e; }\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && st.f && !st.l))\n        { return buf || new u8(0); }\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        { st = {}; }\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        { buf = new u8(sl * 3); }\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        { err(0); }\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    { cbuf(bt + l); }\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                { lm = flrm, dm = fdrm, lbt = 9, dbt = 5; }\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            { n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1]; }\n                        else if (s == 17)\n                            { n = 3 + bits(dat, pos, 7), pos += 3; }\n                        else if (s == 18)\n                            { n = 11 + bits(dat, pos, 127), pos += 7; }\n                        while (n--)\n                            { ldt[i++] = c; }\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                { err(1); }\n            if (pos > tbts) {\n                if (noSt)\n                    { err(0); }\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            { cbuf(bt + 131072); }\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    { err(0); }\n                break;\n            }\n            if (!c)\n                { err(2); }\n            if (sym < 256)\n                { buf[bt++] = sym; }\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    { err(3); }\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        { err(0); }\n                    break;\n                }\n                if (noBuf)\n                    { cbuf(bt + 131072); }\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            { final = 1, st.m = lbt, st.d = dm, st.n = dbt; }\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nfunction inflateSync(data, out) {\n    return inflt(data, out);\n}\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n\n// Geometric objects\n\n// import BoundingBox from './bbox';\n\n/**\n * A bÃ©zier path containing a set of path commands similar to a SVG path.\n * Paths can be drawn on a context using `draw`.\n * @exports opentype.Path\n * @class\n * @constructor\n */\nfunction Path() {\n    this.commands = [];\n    this.fill = 'black';\n    this.stroke = null;\n    this.strokeWidth = 1;\n}\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.moveTo = function (x, y) {\n    this.commands.push({\n        type: 'M',\n        x: x,\n        y: y,\n    });\n};\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.lineTo = function (x, y) {\n    this.commands.push({\n        type: 'L',\n        x: x,\n        y: y,\n    });\n};\n\n/**\n * Draws cubic curve\n * @function\n * curveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws cubic curve\n * @function\n * bezierCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n * @see curveTo\n */\nPath.prototype.curveTo = Path.prototype.bezierCurveTo = function (\n    x1,\n    y1,\n    x2,\n    y2,\n    x,\n    y\n) {\n    this.commands.push({\n        type: 'C',\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        x: x,\n        y: y,\n    });\n};\n\n/**\n * Draws quadratic curve\n * @function\n * quadraticCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws quadratic curve\n * @function\n * quadTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\nPath.prototype.quadTo = Path.prototype.quadraticCurveTo = function (\n    x1,\n    y1,\n    x,\n    y\n) {\n    this.commands.push({\n        type: 'Q',\n        x1: x1,\n        y1: y1,\n        x: x,\n        y: y,\n    });\n};\n\n/**\n * Closes the path\n * @function closePath\n * @memberof opentype.Path.prototype\n */\n\n/**\n * Close the path\n * @function close\n * @memberof opentype.Path.prototype\n */\nPath.prototype.close = Path.prototype.closePath = function () {\n    this.commands.push({\n        type: 'Z',\n    });\n};\n\n/**\n * Add the given path or list of commands to the commands of this path.\n * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n */\nPath.prototype.extend = function (pathOrCommands) {\n    if (pathOrCommands.commands) {\n        pathOrCommands = pathOrCommands.commands;\n    }\n    // else if (pathOrCommands instanceof BoundingBox) {\n    //     const box = pathOrCommands;\n    //     this.moveTo(box.x1, box.y1);\n    //     this.lineTo(box.x2, box.y1);\n    //     this.lineTo(box.x2, box.y2);\n    //     this.lineTo(box.x1, box.y2);\n    //     this.close();\n    //     return;\n    // }\n\n    Array.prototype.push.apply(this.commands, pathOrCommands);\n};\n\n/**\n * Convert the Path to a string of path data instructions\n * See http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toPathData = function (decimalPlaces) {\n    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n    function floatToString(v) {\n        if (Math.round(v) === v) {\n            return '' + Math.round(v);\n        } else {\n            return v.toFixed(decimalPlaces);\n        }\n    }\n\n    function packValues() {\n        var arguments$1 = arguments;\n\n        var s = '';\n        for (var i = 0; i < arguments.length; i += 1) {\n            var v = arguments$1[i];\n            if (v >= 0 && i > 0) {\n                s += ' ';\n            }\n\n            s += floatToString(v);\n        }\n\n        return s;\n    }\n\n    var d = '';\n    for (var i = 0; i < this.commands.length; i += 1) {\n        var cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            d += 'M' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            d += 'L' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            d += 'Z';\n        }\n    }\n\n    return d;\n};\n\n// Glyph encoding\n\nvar cffStandardStrings = [\n    '.notdef',\n    'space',\n    'exclam',\n    'quotedbl',\n    'numbersign',\n    'dollar',\n    'percent',\n    'ampersand',\n    'quoteright',\n    'parenleft',\n    'parenright',\n    'asterisk',\n    'plus',\n    'comma',\n    'hyphen',\n    'period',\n    'slash',\n    'zero',\n    'one',\n    'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n    'eight',\n    'nine',\n    'colon',\n    'semicolon',\n    'less',\n    'equal',\n    'greater',\n    'question',\n    'at',\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n    'bracketleft',\n    'backslash',\n    'bracketright',\n    'asciicircum',\n    'underscore',\n    'quoteleft',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n    'n',\n    'o',\n    'p',\n    'q',\n    'r',\n    's',\n    't',\n    'u',\n    'v',\n    'w',\n    'x',\n    'y',\n    'z',\n    'braceleft',\n    'bar',\n    'braceright',\n    'asciitilde',\n    'exclamdown',\n    'cent',\n    'sterling',\n    'fraction',\n    'yen',\n    'florin',\n    'section',\n    'currency',\n    'quotesingle',\n    'quotedblleft',\n    'guillemotleft',\n    'guilsinglleft',\n    'guilsinglright',\n    'fi',\n    'fl',\n    'endash',\n    'dagger',\n    'daggerdbl',\n    'periodcentered',\n    'paragraph',\n    'bullet',\n    'quotesinglbase',\n    'quotedblbase',\n    'quotedblright',\n    'guillemotright',\n    'ellipsis',\n    'perthousand',\n    'questiondown',\n    'grave',\n    'acute',\n    'circumflex',\n    'tilde',\n    'macron',\n    'breve',\n    'dotaccent',\n    'dieresis',\n    'ring',\n    'cedilla',\n    'hungarumlaut',\n    'ogonek',\n    'caron',\n    'emdash',\n    'AE',\n    'ordfeminine',\n    'Lslash',\n    'Oslash',\n    'OE',\n    'ordmasculine',\n    'ae',\n    'dotlessi',\n    'lslash',\n    'oslash',\n    'oe',\n    'germandbls',\n    'onesuperior',\n    'logicalnot',\n    'mu',\n    'trademark',\n    'Eth',\n    'onehalf',\n    'plusminus',\n    'Thorn',\n    'onequarter',\n    'divide',\n    'brokenbar',\n    'degree',\n    'thorn',\n    'threequarters',\n    'twosuperior',\n    'registered',\n    'minus',\n    'eth',\n    'multiply',\n    'threesuperior',\n    'copyright',\n    'Aacute',\n    'Acircumflex',\n    'Adieresis',\n    'Agrave',\n    'Aring',\n    'Atilde',\n    'Ccedilla',\n    'Eacute',\n    'Ecircumflex',\n    'Edieresis',\n    'Egrave',\n    'Iacute',\n    'Icircumflex',\n    'Idieresis',\n    'Igrave',\n    'Ntilde',\n    'Oacute',\n    'Ocircumflex',\n    'Odieresis',\n    'Ograve',\n    'Otilde',\n    'Scaron',\n    'Uacute',\n    'Ucircumflex',\n    'Udieresis',\n    'Ugrave',\n    'Yacute',\n    'Ydieresis',\n    'Zcaron',\n    'aacute',\n    'acircumflex',\n    'adieresis',\n    'agrave',\n    'aring',\n    'atilde',\n    'ccedilla',\n    'eacute',\n    'ecircumflex',\n    'edieresis',\n    'egrave',\n    'iacute',\n    'icircumflex',\n    'idieresis',\n    'igrave',\n    'ntilde',\n    'oacute',\n    'ocircumflex',\n    'odieresis',\n    'ograve',\n    'otilde',\n    'scaron',\n    'uacute',\n    'ucircumflex',\n    'udieresis',\n    'ugrave',\n    'yacute',\n    'ydieresis',\n    'zcaron',\n    'exclamsmall',\n    'Hungarumlautsmall',\n    'dollaroldstyle',\n    'dollarsuperior',\n    'ampersandsmall',\n    'Acutesmall',\n    'parenleftsuperior',\n    'parenrightsuperior',\n    '266 ff',\n    'onedotenleader',\n    'zerooldstyle',\n    'oneoldstyle',\n    'twooldstyle',\n    'threeoldstyle',\n    'fouroldstyle',\n    'fiveoldstyle',\n    'sixoldstyle',\n    'sevenoldstyle',\n    'eightoldstyle',\n    'nineoldstyle',\n    'commasuperior',\n    'threequartersemdash',\n    'periodsuperior',\n    'questionsmall',\n    'asuperior',\n    'bsuperior',\n    'centsuperior',\n    'dsuperior',\n    'esuperior',\n    'isuperior',\n    'lsuperior',\n    'msuperior',\n    'nsuperior',\n    'osuperior',\n    'rsuperior',\n    'ssuperior',\n    'tsuperior',\n    'ff',\n    'ffi',\n    'ffl',\n    'parenleftinferior',\n    'parenrightinferior',\n    'Circumflexsmall',\n    'hyphensuperior',\n    'Gravesmall',\n    'Asmall',\n    'Bsmall',\n    'Csmall',\n    'Dsmall',\n    'Esmall',\n    'Fsmall',\n    'Gsmall',\n    'Hsmall',\n    'Ismall',\n    'Jsmall',\n    'Ksmall',\n    'Lsmall',\n    'Msmall',\n    'Nsmall',\n    'Osmall',\n    'Psmall',\n    'Qsmall',\n    'Rsmall',\n    'Ssmall',\n    'Tsmall',\n    'Usmall',\n    'Vsmall',\n    'Wsmall',\n    'Xsmall',\n    'Ysmall',\n    'Zsmall',\n    'colonmonetary',\n    'onefitted',\n    'rupiah',\n    'Tildesmall',\n    'exclamdownsmall',\n    'centoldstyle',\n    'Lslashsmall',\n    'Scaronsmall',\n    'Zcaronsmall',\n    'Dieresissmall',\n    'Brevesmall',\n    'Caronsmall',\n    'Dotaccentsmall',\n    'Macronsmall',\n    'figuredash',\n    'hypheninferior',\n    'Ogoneksmall',\n    'Ringsmall',\n    'Cedillasmall',\n    'questiondownsmall',\n    'oneeighth',\n    'threeeighths',\n    'fiveeighths',\n    'seveneighths',\n    'onethird',\n    'twothirds',\n    'zerosuperior',\n    'foursuperior',\n    'fivesuperior',\n    'sixsuperior',\n    'sevensuperior',\n    'eightsuperior',\n    'ninesuperior',\n    'zeroinferior',\n    'oneinferior',\n    'twoinferior',\n    'threeinferior',\n    'fourinferior',\n    'fiveinferior',\n    'sixinferior',\n    'seveninferior',\n    'eightinferior',\n    'nineinferior',\n    'centinferior',\n    'dollarinferior',\n    'periodinferior',\n    'commainferior',\n    'Agravesmall',\n    'Aacutesmall',\n    'Acircumflexsmall',\n    'Atildesmall',\n    'Adieresissmall',\n    'Aringsmall',\n    'AEsmall',\n    'Ccedillasmall',\n    'Egravesmall',\n    'Eacutesmall',\n    'Ecircumflexsmall',\n    'Edieresissmall',\n    'Igravesmall',\n    'Iacutesmall',\n    'Icircumflexsmall',\n    'Idieresissmall',\n    'Ethsmall',\n    'Ntildesmall',\n    'Ogravesmall',\n    'Oacutesmall',\n    'Ocircumflexsmall',\n    'Otildesmall',\n    'Odieresissmall',\n    'OEsmall',\n    'Oslashsmall',\n    'Ugravesmall',\n    'Uacutesmall',\n    'Ucircumflexsmall',\n    'Udieresissmall',\n    'Yacutesmall',\n    'Thornsmall',\n    'Ydieresissmall',\n    '001.000',\n    '001.001',\n    '001.002',\n    '001.003',\n    'Black',\n    'Bold',\n    'Book',\n    'Light',\n    'Medium',\n    'Regular',\n    'Roman',\n    'Semibold' ];\n\nvar cffStandardEncoding = [\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'space',\n    'exclam',\n    'quotedbl',\n    'numbersign',\n    'dollar',\n    'percent',\n    'ampersand',\n    'quoteright',\n    'parenleft',\n    'parenright',\n    'asterisk',\n    'plus',\n    'comma',\n    'hyphen',\n    'period',\n    'slash',\n    'zero',\n    'one',\n    'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n    'eight',\n    'nine',\n    'colon',\n    'semicolon',\n    'less',\n    'equal',\n    'greater',\n    'question',\n    'at',\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n    'bracketleft',\n    'backslash',\n    'bracketright',\n    'asciicircum',\n    'underscore',\n    'quoteleft',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n    'n',\n    'o',\n    'p',\n    'q',\n    'r',\n    's',\n    't',\n    'u',\n    'v',\n    'w',\n    'x',\n    'y',\n    'z',\n    'braceleft',\n    'bar',\n    'braceright',\n    'asciitilde',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'exclamdown',\n    'cent',\n    'sterling',\n    'fraction',\n    'yen',\n    'florin',\n    'section',\n    'currency',\n    'quotesingle',\n    'quotedblleft',\n    'guillemotleft',\n    'guilsinglleft',\n    'guilsinglright',\n    'fi',\n    'fl',\n    '',\n    'endash',\n    'dagger',\n    'daggerdbl',\n    'periodcentered',\n    '',\n    'paragraph',\n    'bullet',\n    'quotesinglbase',\n    'quotedblbase',\n    'quotedblright',\n    'guillemotright',\n    'ellipsis',\n    'perthousand',\n    '',\n    'questiondown',\n    '',\n    'grave',\n    'acute',\n    'circumflex',\n    'tilde',\n    'macron',\n    'breve',\n    'dotaccent',\n    'dieresis',\n    '',\n    'ring',\n    'cedilla',\n    '',\n    'hungarumlaut',\n    'ogonek',\n    'caron',\n    'emdash',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'AE',\n    '',\n    'ordfeminine',\n    '',\n    '',\n    '',\n    '',\n    'Lslash',\n    'Oslash',\n    'OE',\n    'ordmasculine',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'ae',\n    '',\n    '',\n    '',\n    'dotlessi',\n    '',\n    '',\n    'lslash',\n    'oslash',\n    'oe',\n    'germandbls' ];\n\nvar cffExpertEncoding = [\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'space',\n    'exclamsmall',\n    'Hungarumlautsmall',\n    '',\n    'dollaroldstyle',\n    'dollarsuperior',\n    'ampersandsmall',\n    'Acutesmall',\n    'parenleftsuperior',\n    'parenrightsuperior',\n    'twodotenleader',\n    'onedotenleader',\n    'comma',\n    'hyphen',\n    'period',\n    'fraction',\n    'zerooldstyle',\n    'oneoldstyle',\n    'twooldstyle',\n    'threeoldstyle',\n    'fouroldstyle',\n    'fiveoldstyle',\n    'sixoldstyle',\n    'sevenoldstyle',\n    'eightoldstyle',\n    'nineoldstyle',\n    'colon',\n    'semicolon',\n    'commasuperior',\n    'threequartersemdash',\n    'periodsuperior',\n    'questionsmall',\n    '',\n    'asuperior',\n    'bsuperior',\n    'centsuperior',\n    'dsuperior',\n    'esuperior',\n    '',\n    '',\n    'isuperior',\n    '',\n    '',\n    'lsuperior',\n    'msuperior',\n    'nsuperior',\n    'osuperior',\n    '',\n    '',\n    'rsuperior',\n    'ssuperior',\n    'tsuperior',\n    '',\n    'ff',\n    'fi',\n    'fl',\n    'ffi',\n    'ffl',\n    'parenleftinferior',\n    '',\n    'parenrightinferior',\n    'Circumflexsmall',\n    'hyphensuperior',\n    'Gravesmall',\n    'Asmall',\n    'Bsmall',\n    'Csmall',\n    'Dsmall',\n    'Esmall',\n    'Fsmall',\n    'Gsmall',\n    'Hsmall',\n    'Ismall',\n    'Jsmall',\n    'Ksmall',\n    'Lsmall',\n    'Msmall',\n    'Nsmall',\n    'Osmall',\n    'Psmall',\n    'Qsmall',\n    'Rsmall',\n    'Ssmall',\n    'Tsmall',\n    'Usmall',\n    'Vsmall',\n    'Wsmall',\n    'Xsmall',\n    'Ysmall',\n    'Zsmall',\n    'colonmonetary',\n    'onefitted',\n    'rupiah',\n    'Tildesmall',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'exclamdownsmall',\n    'centoldstyle',\n    'Lslashsmall',\n    '',\n    '',\n    'Scaronsmall',\n    'Zcaronsmall',\n    'Dieresissmall',\n    'Brevesmall',\n    'Caronsmall',\n    '',\n    'Dotaccentsmall',\n    '',\n    '',\n    'Macronsmall',\n    '',\n    '',\n    'figuredash',\n    'hypheninferior',\n    '',\n    '',\n    'Ogoneksmall',\n    'Ringsmall',\n    'Cedillasmall',\n    '',\n    '',\n    '',\n    'onequarter',\n    'onehalf',\n    'threequarters',\n    'questiondownsmall',\n    'oneeighth',\n    'threeeighths',\n    'fiveeighths',\n    'seveneighths',\n    'onethird',\n    'twothirds',\n    '',\n    '',\n    'zerosuperior',\n    'onesuperior',\n    'twosuperior',\n    'threesuperior',\n    'foursuperior',\n    'fivesuperior',\n    'sixsuperior',\n    'sevensuperior',\n    'eightsuperior',\n    'ninesuperior',\n    'zeroinferior',\n    'oneinferior',\n    'twoinferior',\n    'threeinferior',\n    'fourinferior',\n    'fiveinferior',\n    'sixinferior',\n    'seveninferior',\n    'eightinferior',\n    'nineinferior',\n    'centinferior',\n    'dollarinferior',\n    'periodinferior',\n    'commainferior',\n    'Agravesmall',\n    'Aacutesmall',\n    'Acircumflexsmall',\n    'Atildesmall',\n    'Adieresissmall',\n    'Aringsmall',\n    'AEsmall',\n    'Ccedillasmall',\n    'Egravesmall',\n    'Eacutesmall',\n    'Ecircumflexsmall',\n    'Edieresissmall',\n    'Igravesmall',\n    'Iacutesmall',\n    'Icircumflexsmall',\n    'Idieresissmall',\n    'Ethsmall',\n    'Ntildesmall',\n    'Ogravesmall',\n    'Oacutesmall',\n    'Ocircumflexsmall',\n    'Otildesmall',\n    'Odieresissmall',\n    'OEsmall',\n    'Oslashsmall',\n    'Ugravesmall',\n    'Uacutesmall',\n    'Ucircumflexsmall',\n    'Udieresissmall',\n    'Yacutesmall',\n    'Thornsmall',\n    'Ydieresissmall' ];\n\n/**\n * This is the encoding used for fonts created from scratch.\n * It loops through all glyphs and finds the appropriate unicode value.\n * Since it's linear time, other encodings will be faster.\n * @exports opentype.DefaultEncoding\n * @class\n * @constructor\n * @param {opentype.Font}\n */\nfunction DefaultEncoding(font) {\n    this.font = font;\n}\n\nDefaultEncoding.prototype.charToGlyphIndex = function (c) {\n    var code = c.codePointAt(0);\n    var glyphs = this.font.glyphs;\n    if (glyphs) {\n        for (var i = 0; i < glyphs.length; i += 1) {\n            var glyph = glyphs.get(i);\n            for (var j = 0; j < glyph.unicodes.length; j += 1) {\n                if (glyph.unicodes[j] === code) {\n                    return i;\n                }\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * @exports opentype.CmapEncoding\n * @class\n * @constructor\n * @param {Object} cmap - a object with the cmap encoded data\n */\nfunction CmapEncoding(cmap) {\n    this.cmap = cmap;\n}\n\n/**\n * @param  {string} c - the character\n * @return {number} The glyph index.\n */\nCmapEncoding.prototype.charToGlyphIndex = function (c) {\n    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;\n};\n\n/**\n * @exports opentype.CffEncoding\n * @class\n * @constructor\n * @param {string} encoding - The encoding\n * @param {Array} charset - The character set.\n */\nfunction CffEncoding(encoding, charset) {\n    this.encoding = encoding;\n    this.charset = charset;\n}\n\n/**\n * @param  {string} s - The character\n * @return {number} The index.\n */\nCffEncoding.prototype.charToGlyphIndex = function (s) {\n    var code = s.codePointAt(0);\n    var charName = this.encoding[code];\n    return this.charset.indexOf(charName);\n};\n\nfunction addGlyphNamesAll(font) {\n    var glyph;\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        glyph = font.glyphs.get(glyphIndex);\n        glyph.addUnicode(parseInt(c));\n    }\n}\n\nfunction addGlyphNamesToUnicodeMap(font) {\n    font._IndexToUnicodeMap = {};\n\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    var charCodes = Object.keys(glyphIndexMap);\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n        var c = charCodes[i];\n        var glyphIndex = glyphIndexMap[c];\n        if (font._IndexToUnicodeMap[glyphIndex] === undefined) {\n            font._IndexToUnicodeMap[glyphIndex] = {\n                unicodes: [parseInt(c)],\n            };\n        } else {\n            font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));\n        }\n    }\n}\n\n/**\n * @alias opentype.addGlyphNames\n * @param {opentype.Font}\n * @param {Object}\n */\nfunction addGlyphNames(font, opt) {\n    if (opt.lowMemory) {\n        addGlyphNamesToUnicodeMap(font);\n    } else {\n        addGlyphNamesAll(font);\n    }\n}\n\n// Run-time checking of preconditions.\n\nfunction fail(message) {\n    throw new Error(message);\n}\n\n// Precondition function that checks if the given predicate is true.\n// If not, it will throw an error.\nfunction argument(predicate, message) {\n    if (!predicate) {\n        fail(message);\n    }\n}\nvar check = { fail: fail, argument: argument, assert: argument };\n\n// The Glyph object\n// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\n\nfunction getPathDefinition(glyph, path) {\n    var _path = path || new Path();\n    return {\n        configurable: true,\n\n        get: function () {\n            if (typeof _path === 'function') {\n                _path = _path();\n            }\n\n            return _path;\n        },\n\n        set: function (p) {\n            _path = p;\n        },\n    };\n}\n/**\n * @typedef GlyphOptions\n * @type Object\n * @property {string} [name] - The glyph name\n * @property {number} [unicode]\n * @property {Array} [unicodes]\n * @property {number} [xMin]\n * @property {number} [yMin]\n * @property {number} [xMax]\n * @property {number} [yMax]\n * @property {number} [advanceWidth]\n */\n\n// A Glyph is an individual mark that often corresponds to a character.\n// Some glyphs, such as ligatures, are a combination of many characters.\n// Glyphs are the basic building blocks of a font.\n//\n// The `Glyph` class contains utility methods for drawing the path and its points.\n/**\n * @exports opentype.Glyph\n * @class\n * @param {GlyphOptions}\n * @constructor\n */\nfunction Glyph(options) {\n    // By putting all the code on a prototype function (which is only declared once)\n    // we reduce the memory requirements for larger fonts by some 2%\n    this.bindConstructorValues(options);\n}\n\n/**\n * @param  {GlyphOptions}\n */\nGlyph.prototype.bindConstructorValues = function (options) {\n    this.index = options.index || 0;\n\n    // These three values cannot be deferred for memory optimization:\n    this.name = options.name || null;\n    this.unicode = options.unicode || undefined;\n    this.unicodes =\n        options.unicodes || options.unicode !== undefined\n            ? [options.unicode]\n            : [];\n\n    // But by binding these values only when necessary, we reduce can\n    // the memory requirements by almost 3% for larger fonts.\n    if ('xMin' in options) {\n        this.xMin = options.xMin;\n    }\n\n    if ('yMin' in options) {\n        this.yMin = options.yMin;\n    }\n\n    if ('xMax' in options) {\n        this.xMax = options.xMax;\n    }\n\n    if ('yMax' in options) {\n        this.yMax = options.yMax;\n    }\n\n    if ('advanceWidth' in options) {\n        this.advanceWidth = options.advanceWidth;\n    }\n\n    // The path for a glyph is the most memory intensive, and is bound as a value\n    // with a getter/setter to ensure we actually do path parsing only once the\n    // path is actually needed by anything.\n    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n};\n\n/**\n * @param {number}\n */\nGlyph.prototype.addUnicode = function (unicode) {\n    if (this.unicodes.length === 0) {\n        this.unicode = unicode;\n    }\n\n    this.unicodes.push(unicode);\n};\n\n// /**\n//  * Calculate the minimum bounding box for this glyph.\n//  * @return {opentype.BoundingBox}\n//  */\n// Glyph.prototype.getBoundingBox = function() {\n//     return this.path.getBoundingBox();\n// };\n\n/**\n * Convert the glyph to a Path we can draw on a drawing context.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n * @param  {opentype.Font} if hinting is to be used, the font\n * @return {opentype.Path}\n */\nGlyph.prototype.getPath = function (x, y, fontSize, options, font) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    var commands;\n    var hPoints;\n    if (!options) { options = {}; }\n    var xScale = options.xScale;\n    var yScale = options.yScale;\n\n    if (options.hinting && font && font.hinting) {\n        // in case of hinting, the hinting engine takes care\n        // of scaling the points (not the path) before hinting.\n        hPoints = this.path && font.hinting.exec(this, fontSize);\n        // in case the hinting engine failed hPoints is undefined\n        // and thus reverts to plain rending\n    }\n\n    if (hPoints) {\n        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n        commands = font.hinting.getCommands(hPoints);\n        x = Math.round(x);\n        y = Math.round(y);\n        // TODO in case of hinting xyScaling is not yet supported\n        xScale = yScale = 1;\n    } else {\n        commands = this.path.commands;\n        var scale = (1 / (this.path.unitsPerEm || 1000)) * fontSize;\n        if (xScale === undefined) { xScale = scale; }\n        if (yScale === undefined) { yScale = scale; }\n    }\n\n    var p = new Path();\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type === 'M') {\n            p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);\n        } else if (cmd.type === 'L') {\n            p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);\n        } else if (cmd.type === 'Q') {\n            p.quadraticCurveTo(\n                x + cmd.x1 * xScale,\n                y + -cmd.y1 * yScale,\n                x + cmd.x * xScale,\n                y + -cmd.y * yScale\n            );\n        } else if (cmd.type === 'C') {\n            p.curveTo(\n                x + cmd.x1 * xScale,\n                y + -cmd.y1 * yScale,\n                x + cmd.x2 * xScale,\n                y + -cmd.y2 * yScale,\n                x + cmd.x * xScale,\n                y + -cmd.y * yScale\n            );\n        } else if (cmd.type === 'Z') {\n            p.closePath();\n        }\n    }\n\n    return p;\n};\n\n/**\n * Split the glyph into contours.\n * This function is here for backwards compatibility, and to\n * provide raw access to the TrueType glyph outlines.\n * @return {Array}\n */\nGlyph.prototype.getContours = function () {\n    if (this.points === undefined) {\n        return [];\n    }\n\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < this.points.length; i += 1) {\n        var pt = this.points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(\n        currentContour.length === 0,\n        'There are still points left in the current contour.'\n    );\n    return contours;\n};\n\n/**\n * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n * @return {Object}\n */\nGlyph.prototype.getMetrics = function () {\n    var commands = this.path.commands;\n    var xCoords = [];\n    var yCoords = [];\n    for (var i = 0; i < commands.length; i += 1) {\n        var cmd = commands[i];\n        if (cmd.type !== 'Z') {\n            xCoords.push(cmd.x);\n            yCoords.push(cmd.y);\n        }\n\n        if (cmd.type === 'Q' || cmd.type === 'C') {\n            xCoords.push(cmd.x1);\n            yCoords.push(cmd.y1);\n        }\n\n        if (cmd.type === 'C') {\n            xCoords.push(cmd.x2);\n            yCoords.push(cmd.y2);\n        }\n    }\n\n    var metrics = {\n        xMin: Math.min.apply(null, xCoords),\n        yMin: Math.min.apply(null, yCoords),\n        xMax: Math.max.apply(null, xCoords),\n        yMax: Math.max.apply(null, yCoords),\n        leftSideBearing: this.leftSideBearing,\n    };\n\n    if (!isFinite(metrics.xMin)) {\n        metrics.xMin = 0;\n    }\n\n    if (!isFinite(metrics.xMax)) {\n        metrics.xMax = this.advanceWidth;\n    }\n\n    if (!isFinite(metrics.yMin)) {\n        metrics.yMin = 0;\n    }\n\n    if (!isFinite(metrics.yMax)) {\n        metrics.yMax = 0;\n    }\n\n    metrics.rightSideBearing =\n        this.advanceWidth -\n        metrics.leftSideBearing -\n        (metrics.xMax - metrics.xMin);\n    return metrics;\n};\n\n// The GlyphSet object\n\n// Define a property on the glyph that depends on the path being loaded.\nfunction defineDependentProperty(glyph, externalName, internalName) {\n    Object.defineProperty(glyph, externalName, {\n        get: function () {\n            // Request the path property to make sure the path is loaded.\n            glyph.path; // jshint ignore:line\n            return glyph[internalName];\n        },\n        set: function (newValue) {\n            glyph[internalName] = newValue;\n        },\n        enumerable: true,\n        configurable: true,\n    });\n}\n\n/**\n * A GlyphSet represents all glyphs available in the font, but modelled using\n * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n * necessary, to keep the memory footprint down.\n * @exports opentype.GlyphSet\n * @class\n * @param {opentype.Font}\n * @param {Array}\n */\nfunction GlyphSet(font, glyphs) {\n    this.font = font;\n    this.glyphs = {};\n    if (Array.isArray(glyphs)) {\n        for (var i = 0; i < glyphs.length; i++) {\n            var glyph = glyphs[i];\n            glyph.path.unitsPerEm = font.unitsPerEm;\n            this.glyphs[i] = glyph;\n        }\n    }\n\n    this.length = (glyphs && glyphs.length) || 0;\n}\n\n/**\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nGlyphSet.prototype.get = function (index) {\n    // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.\n    if (this.glyphs[index] === undefined) {\n        this.font._push(index);\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n\n        var glyph = this.glyphs[index];\n        var unicodeObj = this.font._IndexToUnicodeMap[index];\n\n        if (unicodeObj) {\n            for (var j = 0; j < unicodeObj.unicodes.length; j++)\n                { glyph.addUnicode(unicodeObj.unicodes[j]); }\n        }\n\n        this.glyphs[index].advanceWidth =\n            this.font._hmtxTableData[index].advanceWidth;\n        this.glyphs[index].leftSideBearing =\n            this.font._hmtxTableData[index].leftSideBearing;\n    } else {\n        if (typeof this.glyphs[index] === 'function') {\n            this.glyphs[index] = this.glyphs[index]();\n        }\n    }\n\n    return this.glyphs[index];\n};\n\n/**\n * @param  {number} index\n * @param  {Object}\n */\nGlyphSet.prototype.push = function (index, loader) {\n    this.glyphs[index] = loader;\n    this.length++;\n};\n\n/**\n * @alias opentype.glyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nfunction glyphLoader(font, index) {\n    return new Glyph({ index: index, font: font });\n}\n\n/**\n * Generate a stub glyph that can be filled with all metadata *except*\n * the \"points\" and \"path\" properties, which must be loaded only once\n * the glyph's path is actually requested for text shaping.\n * @alias opentype.ttfGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseGlyph\n * @param  {Object} data\n * @param  {number} position\n * @param  {Function} buildPath\n * @return {opentype.Glyph}\n */\nfunction ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n    return function () {\n        var glyph = new Glyph({ index: index, font: font });\n\n        glyph.path = function () {\n            parseGlyph(glyph, data, position);\n            var path = buildPath(font.glyphs, glyph);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        defineDependentProperty(glyph, 'xMin', '_xMin');\n        defineDependentProperty(glyph, 'xMax', '_xMax');\n        defineDependentProperty(glyph, 'yMin', '_yMin');\n        defineDependentProperty(glyph, 'yMax', '_yMax');\n\n        return glyph;\n    };\n}\n/**\n * @alias opentype.cffGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseCFFCharstring\n * @param  {string} charstring\n * @return {opentype.Glyph}\n */\nfunction cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n    return function () {\n        var glyph = new Glyph({ index: index, font: font });\n\n        glyph.path = function () {\n            var path = parseCFFCharstring(font, glyph, charstring);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        return glyph;\n    };\n}\n\nvar glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };\n\n// The Layout object is the prototype of Substitution objects, and provides\n\nfunction searchTag(arr, tag) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid].tag;\n        if (val === tag) {\n            return imid;\n        } else if (val < tag) {\n            imin = imid + 1;\n        } else {\n            imax = imid - 1;\n        }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\nfunction binSearch(arr, value) {\n    /* jshint bitwise: false */\n    var imin = 0;\n    var imax = arr.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        var val = arr[imid];\n        if (val === value) {\n            return imid;\n        } else if (val < value) {\n            imin = imid + 1;\n        } else {\n            imax = imid - 1;\n        }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\n// binary search in a list of ranges (coverage, class definition)\nfunction searchRange(ranges, value) {\n    // jshint bitwise: false\n    var range;\n    var imin = 0;\n    var imax = ranges.length - 1;\n    while (imin <= imax) {\n        var imid = (imin + imax) >>> 1;\n        range = ranges[imid];\n        var start = range.start;\n        if (start === value) {\n            return range;\n        } else if (start < value) {\n            imin = imid + 1;\n        } else {\n            imax = imid - 1;\n        }\n    }\n    if (imin > 0) {\n        range = ranges[imin - 1];\n        if (value > range.end) { return 0; }\n        return range;\n    }\n}\n\n/**\n * @exports opentype.Layout\n * @class\n */\nfunction Layout(font, tableName) {\n    this.font = font;\n    this.tableName = tableName;\n}\n\nLayout.prototype = {\n    /**\n     * Binary search an object by \"tag\" property\n     * @instance\n     * @function searchTag\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {string} tag\n     * @return {number}\n     */\n    searchTag: searchTag,\n\n    /**\n     * Binary search in a list of numbers\n     * @instance\n     * @function binSearch\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {number} value\n     * @return {number}\n     */\n    binSearch: binSearch,\n\n    /**\n     * Get or create the Layout table (GSUB, GPOS etc).\n     * @param  {boolean} create - Whether to create a new one.\n     * @return {Object} The GSUB or GPOS table.\n     */\n    getTable: function (create) {\n        var layout = this.font.tables[this.tableName];\n        if (!layout && create) {\n            layout = this.font.tables[this.tableName] =\n                this.createDefaultTable();\n        }\n        return layout;\n    },\n\n    /**\n     * Returns the best bet for a script name.\n     * Returns 'DFLT' if it exists.\n     * If not, returns 'latn' if it exists.\n     * If neither exist, returns undefined.\n     */\n    getDefaultScriptName: function () {\n        var layout = this.getTable();\n        if (!layout) {\n            return;\n        }\n        var hasLatn = false;\n        for (var i = 0; i < layout.scripts.length; i++) {\n            var name = layout.scripts[i].tag;\n            if (name === 'DFLT') { return name; }\n            if (name === 'latn') { hasLatn = true; }\n        }\n        if (hasLatn) { return 'latn'; }\n    },\n\n    /**\n     * Returns all LangSysRecords in the given script.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n     * @return {Object} An object with tag and script properties.\n     */\n    getScriptTable: function (script, create) {\n        var layout = this.getTable(create);\n        if (layout) {\n            script = script || 'DFLT';\n            var scripts = layout.scripts;\n            var pos = searchTag(layout.scripts, script);\n            if (pos >= 0) {\n                return scripts[pos].script;\n            } else if (create) {\n                var scr = {\n                    tag: script,\n                    script: {\n                        defaultLangSys: {\n                            reserved: 0,\n                            reqFeatureIndex: 0xffff,\n                            featureIndexes: [],\n                        },\n                        langSysRecords: [],\n                    },\n                };\n                scripts.splice(-1 - pos, 0, scr);\n                return scr.script;\n            }\n        }\n    },\n\n    /**\n     * Returns a language system table\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n     * @return {Object}\n     */\n    getLangSysTable: function (script, language, create) {\n        var scriptTable = this.getScriptTable(script, create);\n        if (scriptTable) {\n            if (!language || language === 'dflt' || language === 'DFLT') {\n                return scriptTable.defaultLangSys;\n            }\n            var pos = searchTag(scriptTable.langSysRecords, language);\n            if (pos >= 0) {\n                return scriptTable.langSysRecords[pos].langSys;\n            } else if (create) {\n                var langSysRecord = {\n                    tag: language,\n                    langSys: {\n                        reserved: 0,\n                        reqFeatureIndex: 0xffff,\n                        featureIndexes: [],\n                    },\n                };\n                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n                return langSysRecord.langSys;\n            }\n        }\n    },\n\n    /**\n     * Get a specific feature table.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n     * @return {Object}\n     */\n    getFeatureTable: function (script, language, feature, create) {\n        var langSysTable = this.getLangSysTable(script, language, create);\n        if (langSysTable) {\n            var featureRecord;\n            var featIndexes = langSysTable.featureIndexes;\n            var allFeatures = this.font.tables[this.tableName].features;\n            // The FeatureIndex array of indices is in arbitrary order,\n            // even if allFeatures is sorted alphabetically by feature tag.\n            for (var i = 0; i < featIndexes.length; i++) {\n                featureRecord = allFeatures[featIndexes[i]];\n                if (featureRecord.tag === feature) {\n                    return featureRecord.feature;\n                }\n            }\n            if (create) {\n                var index = allFeatures.length;\n                // Automatic ordering of features would require to shift feature indexes in the script list.\n                check.assert(\n                    index === 0 || feature >= allFeatures[index - 1].tag,\n                    'Features must be added in alphabetical order.'\n                );\n                featureRecord = {\n                    tag: feature,\n                    feature: { params: 0, lookupListIndexes: [] },\n                };\n                allFeatures.push(featureRecord);\n                featIndexes.push(index);\n                return featureRecord.feature;\n            }\n        }\n    },\n\n    /**\n     * Get the lookup tables of a given type for a script/language/feature.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - 4-letter feature code\n     * @param {number} lookupType - 1 to 9\n     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n     * @return {Object[]}\n     */\n    getLookupTables: function (script, language, feature, lookupType, create) {\n        var featureTable = this.getFeatureTable(\n            script,\n            language,\n            feature,\n            create\n        );\n        var tables = [];\n        if (featureTable) {\n            var lookupTable;\n            var lookupListIndexes = featureTable.lookupListIndexes;\n            var allLookups = this.font.tables[this.tableName].lookups;\n            // lookupListIndexes are in no particular order, so use naive search.\n            for (var i = 0; i < lookupListIndexes.length; i++) {\n                lookupTable = allLookups[lookupListIndexes[i]];\n                if (lookupTable.lookupType === lookupType) {\n                    tables.push(lookupTable);\n                }\n            }\n            if (tables.length === 0 && create) {\n                lookupTable = {\n                    lookupType: lookupType,\n                    lookupFlag: 0,\n                    subtables: [],\n                    markFilteringSet: undefined,\n                };\n                var index = allLookups.length;\n                allLookups.push(lookupTable);\n                lookupListIndexes.push(index);\n                return [lookupTable];\n            }\n        }\n        return tables;\n    },\n\n    /**\n     * Find a glyph in a class definition table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n     * @param {object} classDefTable - an OpenType Layout class definition table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getGlyphClass: function (classDefTable, glyphIndex) {\n        switch (classDefTable.format) {\n            case 1:\n                if (\n                    classDefTable.startGlyph <= glyphIndex &&\n                    glyphIndex <\n                        classDefTable.startGlyph + classDefTable.classes.length\n                ) {\n                    return classDefTable.classes[\n                        glyphIndex - classDefTable.startGlyph\n                    ];\n                }\n                return 0;\n            case 2:\n                var range = searchRange(classDefTable.ranges, glyphIndex);\n                return range ? range.classId : 0;\n        }\n    },\n\n    /**\n     * Find a glyph in a coverage table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n     * @param {object} coverageTable - an OpenType Layout coverage table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getCoverageIndex: function (coverageTable, glyphIndex) {\n        switch (coverageTable.format) {\n            case 1:\n                var index = binSearch(coverageTable.glyphs, glyphIndex);\n                return index >= 0 ? index : -1;\n            case 2:\n                var range = searchRange(coverageTable.ranges, glyphIndex);\n                return range ? range.index + glyphIndex - range.start : -1;\n        }\n    },\n\n    /**\n     * Returns the list of glyph indexes of a coverage table.\n     * Format 1: the list is stored raw\n     * Format 2: compact list as range records.\n     * @instance\n     * @param  {Object} coverageTable\n     * @return {Array}\n     */\n    expandCoverage: function (coverageTable) {\n        if (coverageTable.format === 1) {\n            return coverageTable.glyphs;\n        } else {\n            var glyphs = [];\n            var ranges = coverageTable.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                var start = range.start;\n                var end = range.end;\n                for (var j = start; j <= end; j++) {\n                    glyphs.push(j);\n                }\n            }\n            return glyphs;\n        }\n    },\n};\n\n// The Position object provides utility methods to manipulate\n\n/**\n * @exports opentype.Position\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Position(font) {\n    Layout.call(this, font, 'gpos');\n}\n\nPosition.prototype = Layout.prototype;\n\n/**\n * Init some data for faster and easier access later.\n */\nPosition.prototype.init = function() {\n    var script = this.getDefaultScriptName();\n    this.defaultKerningTables = this.getKerningTables(script);\n};\n\n/**\n * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.\n *\n * @param {integer} leftIndex - left glyph index\n * @param {integer} rightIndex - right glyph index\n * @returns {integer}\n */\nPosition.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {\n    for (var i = 0; i < kerningLookups.length; i++) {\n        var subtables = kerningLookups[i].subtables;\n        for (var j = 0; j < subtables.length; j++) {\n            var subtable = subtables[j];\n            var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);\n            if (covIndex < 0) { continue; }\n            switch (subtable.posFormat) {\n                case 1:\n                    // Search Pair Adjustment Positioning Format 1\n                    var pairSet = subtable.pairSets[covIndex];\n                    for (var k = 0; k < pairSet.length; k++) {\n                        var pair = pairSet[k];\n                        if (pair.secondGlyph === rightIndex) {\n                            return pair.value1 && pair.value1.xAdvance || 0;\n                        }\n                    }\n                    break;      // left glyph found, not right glyph - try next subtable\n                case 2:\n                    // Search Pair Adjustment Positioning Format 2\n                    var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);\n                    var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);\n                    var pair$1 = subtable.classRecords[class1][class2];\n                    return pair$1.value1 && pair$1.value1.xAdvance || 0;\n            }\n        }\n    }\n    return 0;\n};\n\n/**\n * List all kerning lookup tables.\n *\n * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value\n * @param {string} [language='dflt']\n * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)\n */\nPosition.prototype.getKerningTables = function(script, language) {\n    if (this.font.tables.gpos) {\n        return this.getLookupTables(script, language, 'kern', 2);\n    }\n};\n\n// The Substitution object provides utility methods to manipulate\n\n/**\n * @exports opentype.Substitution\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Substitution(font) {\n    Layout.call(this, font, 'gsub');\n}\n\n// Check if 2 arrays of primitives are equal.\nfunction arraysEqual(ar1, ar2) {\n    var n = ar1.length;\n    if (n !== ar2.length) {\n        return false;\n    }\n    for (var i = 0; i < n; i++) {\n        if (ar1[i] !== ar2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Find the first subtable of a lookup table in a particular format.\nfunction getSubstFormat(lookupTable, format, defaultSubtable) {\n    var subtables = lookupTable.subtables;\n    for (var i = 0; i < subtables.length; i++) {\n        var subtable = subtables[i];\n        if (subtable.substFormat === format) {\n            return subtable;\n        }\n    }\n    if (defaultSubtable) {\n        subtables.push(defaultSubtable);\n        return defaultSubtable;\n    }\n    return undefined;\n}\n\nSubstitution.prototype = Layout.prototype;\n\n/**\n * Create a default GSUB table.\n * @return {Object} gsub - The GSUB table.\n */\nSubstitution.prototype.createDefaultTable = function () {\n    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n    return {\n        version: 1,\n        scripts: [\n            {\n                tag: 'DFLT',\n                script: {\n                    defaultLangSys: {\n                        reserved: 0,\n                        reqFeatureIndex: 0xffff,\n                        featureIndexes: [],\n                    },\n                    langSysRecords: [],\n                },\n            } ],\n        features: [],\n        lookups: [],\n    };\n};\n\n/**\n * List all single substitutions (lookup type 1) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getSingle = function (feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 1);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n            if (subtable.substFormat === 1) {\n                var delta = subtable.deltaGlyphId;\n                for (j = 0; j < glyphs.length; j++) {\n                    var glyph = glyphs[j];\n                    substitutions.push({ sub: glyph, by: glyph + delta });\n                }\n            } else {\n                var substitute = subtable.substitute;\n                for (j = 0; j < glyphs.length; j++) {\n                    substitutions.push({ sub: glyphs[j], by: substitute[j] });\n                }\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all multiple substitutions (lookup type 2) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('ccmp', 'stch')\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getMultiple = function (feature, script, language) {\n    var substitutions = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 2);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var j = (void 0);\n\n            for (j = 0; j < glyphs.length; j++) {\n                var glyph = glyphs[j];\n                var replacements = subtable.sequences[j];\n                substitutions.push({ sub: glyph, by: replacements });\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all alternates (lookup type 3) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n * @return {Array} alternates - The list of alternates\n */\nSubstitution.prototype.getAlternates = function (feature, script, language) {\n    var alternates = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 3);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var alternateSets = subtable.alternateSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                alternates.push({ sub: glyphs[j], by: alternateSets[j] });\n            }\n        }\n    }\n    return alternates;\n};\n\n/**\n * List all ligatures (lookup type 4) for a given script, language, and feature.\n * The result is an array of ligature objects like { sub: [ids], by: id }\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} ligatures - The list of ligatures.\n */\nSubstitution.prototype.getLigatures = function (feature, script, language) {\n    var ligatures = [];\n    var lookupTables = this.getLookupTables(script, language, feature, 4);\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n        var subtables = lookupTables[idx].subtables;\n        for (var i = 0; i < subtables.length; i++) {\n            var subtable = subtables[i];\n            var glyphs = this.expandCoverage(subtable.coverage);\n            var ligatureSets = subtable.ligatureSets;\n            for (var j = 0; j < glyphs.length; j++) {\n                var startGlyph = glyphs[j];\n                var ligSet = ligatureSets[j];\n                for (var k = 0; k < ligSet.length; k++) {\n                    var lig = ligSet[k];\n                    ligatures.push({\n                        sub: [startGlyph].concat(lig.components),\n                        by: lig.ligGlyph,\n                    });\n                }\n            }\n        }\n    }\n    return ligatures;\n};\n\n/**\n * Add or modify a single substitution (lookup type 1)\n * Format 2, more flexible, is always used.\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addSingle = function (\n    feature,\n    substitution,\n    script,\n    language\n) {\n    var lookupTable = this.getLookupTables(\n        script,\n        language,\n        feature,\n        1,\n        true\n    )[0];\n    var subtable = getSubstFormat(lookupTable, 2, {\n        // lookup type 1 subtable, format 2, coverage format 1\n        substFormat: 2,\n        coverage: { format: 1, glyphs: [] },\n        substitute: [],\n    });\n    check.assert(\n        subtable.coverage.format === 1,\n        'Single: unable to modify coverage table format ' +\n            subtable.coverage.format\n    );\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.substitute.splice(pos, 0, 0);\n    }\n    subtable.substitute[pos] = substitution.by;\n};\n\n/**\n * Add or modify a multiple substitution (lookup type 2)\n * @param {string} feature - 4-letter feature name ('ccmp', 'stch')\n * @param {Object} substitution - { sub: id, by: [id] } for format 2.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addMultiple = function (\n    feature,\n    substitution,\n    script,\n    language\n) {\n    check.assert(\n        substitution.by instanceof Array && substitution.by.length > 1,\n        'Multiple: \"by\" must be an array of two or more ids'\n    );\n    var lookupTable = this.getLookupTables(\n        script,\n        language,\n        feature,\n        2,\n        true\n    )[0];\n    var subtable = getSubstFormat(lookupTable, 1, {\n        // lookup type 2 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: { format: 1, glyphs: [] },\n        sequences: [],\n    });\n    check.assert(\n        subtable.coverage.format === 1,\n        'Multiple: unable to modify coverage table format ' +\n            subtable.coverage.format\n    );\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.sequences.splice(pos, 0, 0);\n    }\n    subtable.sequences[pos] = substitution.by;\n};\n\n/**\n * Add or modify an alternate substitution (lookup type 3)\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: [ids] }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addAlternate = function (\n    feature,\n    substitution,\n    script,\n    language\n) {\n    var lookupTable = this.getLookupTables(\n        script,\n        language,\n        feature,\n        3,\n        true\n    )[0];\n    var subtable = getSubstFormat(lookupTable, 1, {\n        // lookup type 3 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: { format: 1, glyphs: [] },\n        alternateSets: [],\n    });\n    check.assert(\n        subtable.coverage.format === 1,\n        'Alternate: unable to modify coverage table format ' +\n            subtable.coverage.format\n    );\n    var coverageGlyph = substitution.sub;\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.alternateSets.splice(pos, 0, 0);\n    }\n    subtable.alternateSets[pos] = substitution.by;\n};\n\n/**\n * Add a ligature (lookup type 4)\n * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} ligature - { sub: [ids], by: id }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addLigature = function (\n    feature,\n    ligature,\n    script,\n    language\n) {\n    var lookupTable = this.getLookupTables(\n        script,\n        language,\n        feature,\n        4,\n        true\n    )[0];\n    var subtable = lookupTable.subtables[0];\n    if (!subtable) {\n        subtable = {\n            // lookup type 4 subtable, format 1, coverage format 1\n            substFormat: 1,\n            coverage: { format: 1, glyphs: [] },\n            ligatureSets: [],\n        };\n        lookupTable.subtables[0] = subtable;\n    }\n    check.assert(\n        subtable.coverage.format === 1,\n        'Ligature: unable to modify coverage table format ' +\n            subtable.coverage.format\n    );\n    var coverageGlyph = ligature.sub[0];\n    var ligComponents = ligature.sub.slice(1);\n    var ligatureTable = {\n        ligGlyph: ligature.by,\n        components: ligComponents,\n    };\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos >= 0) {\n        // ligatureSet already exists\n        var ligatureSet = subtable.ligatureSets[pos];\n        for (var i = 0; i < ligatureSet.length; i++) {\n            // If ligature already exists, return.\n            if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n                return;\n            }\n        }\n        // ligature does not exist: add it.\n        ligatureSet.push(ligatureTable);\n    } else {\n        // Create a new ligatureSet and add coverage for the first glyph.\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);\n    }\n};\n\n/**\n * List all feature data for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getFeature = function (feature, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.getSingle(feature, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            return this.getSingle(feature, script, language).concat(\n                this.getAlternates(feature, script, language)\n            );\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.getLigatures(feature, script, language);\n        case 'ccmp':\n            return this.getMultiple(feature, script, language).concat(\n                this.getLigatures(feature, script, language)\n            );\n        case 'stch':\n            return this.getMultiple(feature, script, language);\n    }\n    return undefined;\n};\n\n/**\n * Add a substitution to a feature for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.add = function (feature, sub, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n        // ss01 - ss20\n        return this.addSingle(feature, sub, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            if (typeof sub.by === 'number') {\n                return this.addSingle(feature, sub, script, language);\n            }\n            return this.addAlternate(feature, sub, script, language);\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.addLigature(feature, sub, script, language);\n        case 'ccmp':\n            if (sub.by instanceof Array) {\n                return this.addMultiple(feature, sub, script, language);\n            }\n            return this.addLigature(feature, sub, script, language);\n    }\n    return undefined;\n};\n\nfunction checkArgument(expression, message) {\n    if (!expression) {\n        throw message;\n    }\n}\n\n// Parsing utility functions\n\n// Retrieve an unsigned byte from the DataView.\nfunction getByte(dataView, offset) {\n    return dataView.getUint8(offset);\n}\n\n// Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getUShort(dataView, offset) {\n    return dataView.getUint16(offset, false);\n}\n\n// Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getShort(dataView, offset) {\n    return dataView.getInt16(offset, false);\n}\n\n// Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\nfunction getULong(dataView, offset) {\n    return dataView.getUint32(offset, false);\n}\n\n// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\nfunction getFixed(dataView, offset) {\n    var decimal = dataView.getInt16(offset, false);\n    var fraction = dataView.getUint16(offset + 2, false);\n    return decimal + fraction / 65535;\n}\n\n// Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\nfunction getTag(dataView, offset) {\n    var tag = '';\n    for (var i = offset; i < offset + 4; i += 1) {\n        tag += String.fromCharCode(dataView.getInt8(i));\n    }\n\n    return tag;\n}\n\n// Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\nfunction getOffset(dataView, offset, offSize) {\n    var v = 0;\n    for (var i = 0; i < offSize; i += 1) {\n        v <<= 8;\n        v += dataView.getUint8(offset + i);\n    }\n\n    return v;\n}\n\n// Retrieve a number of bytes from start offset to the end offset from the DataView.\nfunction getBytes(dataView, startOffset, endOffset) {\n    var bytes = [];\n    for (var i = startOffset; i < endOffset; i += 1) {\n        bytes.push(dataView.getUint8(i));\n    }\n\n    return bytes;\n}\n\n// Convert the list of bytes to a string.\nfunction bytesToString(bytes) {\n    var s = '';\n    for (var i = 0; i < bytes.length; i += 1) {\n        s += String.fromCharCode(bytes[i]);\n    }\n\n    return s;\n}\n\nvar typeOffsets = {\n    byte: 1,\n    uShort: 2,\n    short: 2,\n    uLong: 4,\n    fixed: 4,\n    longDateTime: 8,\n    tag: 4\n};\n\n// A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\nfunction Parser(data, offset) {\n    this.data = data;\n    this.offset = offset;\n    this.relativeOffset = 0;\n}\n\nParser.prototype.parseByte = function() {\n    var v = this.data.getUint8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseChar = function() {\n    var v = this.data.getInt8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\nParser.prototype.parseUShort = function() {\n    var v = this.data.getUint16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\nParser.prototype.parseShort = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseF2Dot14 = function() {\n    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseULong = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseOffset32 = Parser.prototype.parseULong;\n\nParser.prototype.parseFixed = function() {\n    var v = getFixed(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseString = function(length) {\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    var string = '';\n    this.relativeOffset += length;\n    for (var i = 0; i < length; i++) {\n        string += String.fromCharCode(dataView.getUint8(offset + i));\n    }\n\n    return string;\n};\n\nParser.prototype.parseTag = function() {\n    return this.parseString(4);\n};\n\n// LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\n// + Since until 2038 those bits will be filled by zeros we can ignore them.\nParser.prototype.parseLongDateTime = function() {\n    var v = getULong(this.data, this.offset + this.relativeOffset + 4);\n    // Subtract seconds between 01/01/1904 and 01/01/1970\n    // to convert Apple Mac timestamp to Standard Unix timestamp\n    v -= 2082844800;\n    this.relativeOffset += 8;\n    return v;\n};\n\nParser.prototype.parseVersion = function(minorBase) {\n    var major = getUShort(this.data, this.offset + this.relativeOffset);\n\n    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n    // Default returns the correct number if minor = 0xN000 where N is 0-9\n    // Set minorBase to 1 for tables that use minor = N where N is 0-9\n    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n    this.relativeOffset += 4;\n    if (minorBase === undefined) { minorBase = 0x1000; }\n    return major + minor / minorBase / 10;\n};\n\nParser.prototype.skip = function(type, amount) {\n    if (amount === undefined) {\n        amount = 1;\n    }\n\n    this.relativeOffset += typeOffsets[type] * amount;\n};\n\n///// Parsing lists and records ///////////////////////////////\n\n// Parse a list of 32 bit unsigned integers.\nParser.prototype.parseULongList = function(count) {\n    if (count === undefined) { count = this.parseULong(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint32(offset);\n        offset += 4;\n    }\n\n    this.relativeOffset += count * 4;\n    return offsets;\n};\n\n// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n// or provided as an argument.\nParser.prototype.parseOffset16List =\nParser.prototype.parseUShortList = function(count) {\n    if (count === undefined) { count = this.parseUShort(); }\n    var offsets = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return offsets;\n};\n\n// Parses a list of 16 bit signed integers.\nParser.prototype.parseShortList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getInt16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return list;\n};\n\n// Parses a list of bytes.\nParser.prototype.parseByteList = function(count) {\n    var list = new Array(count);\n    var dataView = this.data;\n    var offset = this.offset + this.relativeOffset;\n    for (var i = 0; i < count; i++) {\n        list[i] = dataView.getUint8(offset++);\n    }\n\n    this.relativeOffset += count;\n    return list;\n};\n\n/**\n * Parse a list of items.\n * Record count is optional, if omitted it is read from the stream.\n * itemCallback is one of the Parser methods.\n */\nParser.prototype.parseList = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseUShort();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\nParser.prototype.parseList32 = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseULong();\n    }\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\n/**\n * Parse a list of records.\n * Record count is optional, if omitted it is read from the stream.\n * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n */\nParser.prototype.parseRecordList = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseUShort();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\nParser.prototype.parseRecordList32 = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseULong();\n    }\n    var records = new Array(count);\n    var fields = Object.keys(recordDescription);\n    for (var i = 0; i < count; i++) {\n        var rec = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\n// Parse a data structure into an object\n// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\nParser.prototype.parseStruct = function(description) {\n    if (typeof description === 'function') {\n        return description.call(this);\n    } else {\n        var fields = Object.keys(description);\n        var struct = {};\n        for (var j = 0; j < fields.length; j++) {\n            var fieldName = fields[j];\n            var fieldType = description[fieldName];\n            struct[fieldName] = fieldType.call(this);\n        }\n        return struct;\n    }\n};\n\n/**\n * Parse a GPOS valueRecord\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat is optional, if omitted it is read from the stream.\n */\nParser.prototype.parseValueRecord = function(valueFormat) {\n    if (valueFormat === undefined) {\n        valueFormat = this.parseUShort();\n    }\n    if (valueFormat === 0) {\n        // valueFormat2 in kerning pairs is most often 0\n        // in this case return undefined instead of an empty object, to save space\n        return;\n    }\n    var valueRecord = {};\n\n    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }\n    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }\n    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }\n    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }\n\n    // Device table (non-variable font) / VariationIndex table (variable font) not supported\n    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }\n    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }\n\n    return valueRecord;\n};\n\n/**\n * Parse a list of GPOS valueRecords\n * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n * valueFormat and valueCount are read from the stream.\n */\nParser.prototype.parseValueRecordList = function() {\n    var valueFormat = this.parseUShort();\n    var valueCount = this.parseUShort();\n    var values = new Array(valueCount);\n    for (var i = 0; i < valueCount; i++) {\n        values[i] = this.parseValueRecord(valueFormat);\n    }\n    return values;\n};\n\nParser.prototype.parsePointer = function(description) {\n    var structOffset = this.parseOffset16();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\nParser.prototype.parsePointer32 = function(description) {\n    var structOffset = this.parseOffset32();\n    if (structOffset > 0) {\n        // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\n/**\n * Parse a list of offsets to lists of 16-bit integers,\n * or a list of offsets to lists of offsets to any kind of items.\n * If itemCallback is not provided, a list of list of UShort is assumed.\n * If provided, itemCallback is called on each item and must parse the item.\n * See examples in tables/gsub.js\n */\nParser.prototype.parseListOfLists = function(itemCallback) {\n    var offsets = this.parseOffset16List();\n    var count = offsets.length;\n    var relativeOffset = this.relativeOffset;\n    var list = new Array(count);\n    for (var i = 0; i < count; i++) {\n        var start = offsets[i];\n        if (start === 0) {\n            // NULL offset\n            // Add i as owned property to list. Convenient with assert.\n            list[i] = undefined;\n            continue;\n        }\n        this.relativeOffset = start;\n        if (itemCallback) {\n            var subOffsets = this.parseOffset16List();\n            var subList = new Array(subOffsets.length);\n            for (var j = 0; j < subOffsets.length; j++) {\n                this.relativeOffset = start + subOffsets[j];\n                subList[j] = itemCallback.call(this);\n            }\n            list[i] = subList;\n        } else {\n            list[i] = this.parseUShortList();\n        }\n    }\n    this.relativeOffset = relativeOffset;\n    return list;\n};\n\n///// Complex tables parsing //////////////////////////////////\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n// parser.offset must point to the start of the table containing the coverage.\nParser.prototype.parseCoverage = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    var count = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            glyphs: this.parseUShortList(count)\n        };\n    } else if (format === 2) {\n        var ranges = new Array(count);\n        for (var i = 0; i < count; i++) {\n            ranges[i] = {\n                start: this.parseUShort(),\n                end: this.parseUShort(),\n                index: this.parseUShort()\n            };\n        }\n        return {\n            format: 2,\n            ranges: ranges\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n};\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\nParser.prototype.parseClassDef = function() {\n    var startOffset = this.offset + this.relativeOffset;\n    var format = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            startGlyph: this.parseUShort(),\n            classes: this.parseUShortList()\n        };\n    } else if (format === 2) {\n        return {\n            format: 2,\n            ranges: this.parseRecordList({\n                start: Parser.uShort,\n                end: Parser.uShort,\n                classId: Parser.uShort\n            })\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n};\n\n///// Static methods ///////////////////////////////////\n// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\nParser.list = function(count, itemCallback) {\n    return function() {\n        return this.parseList(count, itemCallback);\n    };\n};\n\nParser.list32 = function(count, itemCallback) {\n    return function() {\n        return this.parseList32(count, itemCallback);\n    };\n};\n\nParser.recordList = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList(count, recordDescription);\n    };\n};\n\nParser.recordList32 = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList32(count, recordDescription);\n    };\n};\n\nParser.pointer = function(description) {\n    return function() {\n        return this.parsePointer(description);\n    };\n};\n\nParser.pointer32 = function(description) {\n    return function() {\n        return this.parsePointer32(description);\n    };\n};\n\nParser.tag = Parser.prototype.parseTag;\nParser.byte = Parser.prototype.parseByte;\nParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\nParser.uShortList = Parser.prototype.parseUShortList;\nParser.uLong = Parser.offset32 = Parser.prototype.parseULong;\nParser.uLongList = Parser.prototype.parseULongList;\nParser.struct = Parser.prototype.parseStruct;\nParser.coverage = Parser.prototype.parseCoverage;\nParser.classDef = Parser.prototype.parseClassDef;\n\n///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\nvar langSysTable = {\n    reserved: Parser.uShort,\n    reqFeatureIndex: Parser.uShort,\n    featureIndexes: Parser.uShortList\n};\n\nParser.prototype.parseScriptList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        script: Parser.pointer({\n            defaultLangSys: Parser.pointer(langSysTable),\n            langSysRecords: Parser.recordList({\n                tag: Parser.tag,\n                langSys: Parser.pointer(langSysTable)\n            })\n        })\n    })) || [];\n};\n\nParser.prototype.parseFeatureList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        feature: Parser.pointer({\n            featureParams: Parser.offset16,\n            lookupListIndexes: Parser.uShortList\n        })\n    })) || [];\n};\n\nParser.prototype.parseLookupList = function(lookupTableParsers) {\n    return this.parsePointer(Parser.list(Parser.pointer(function() {\n        var lookupType = this.parseUShort();\n        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');\n        var lookupFlag = this.parseUShort();\n        var useMarkFilteringSet = lookupFlag & 0x10;\n        return {\n            lookupType: lookupType,\n            lookupFlag: lookupFlag,\n            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n        };\n    }))) || [];\n};\n\nParser.prototype.parseFeatureVariationsList = function() {\n    return this.parsePointer32(function() {\n        var majorVersion = this.parseUShort();\n        var minorVersion = this.parseUShort();\n        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');\n        var featureVariations = this.parseRecordList32({\n            conditionSetOffset: Parser.offset32,\n            featureTableSubstitutionOffset: Parser.offset32\n        });\n        return featureVariations;\n    }) || [];\n};\n\nvar parse = {\n    getByte: getByte,\n    getCard8: getByte,\n    getUShort: getUShort,\n    getCard16: getUShort,\n    getShort: getShort,\n    getULong: getULong,\n    getFixed: getFixed,\n    getTag: getTag,\n    getOffset: getOffset,\n    getBytes: getBytes,\n    bytesToString: bytesToString,\n    Parser: Parser,\n};\n\n// The `glyf` table describes the glyphs in TrueType outline format.\n\n// Parse the coordinate data for a glyph.\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n    var v;\n    if ((flag & shortVectorBitMask) > 0) {\n        // The coordinate is 1 byte long.\n        v = p.parseByte();\n        // The `same` bit is re-used for short values to signify the sign of the value.\n        if ((flag & sameBitMask) === 0) {\n            v = -v;\n        }\n\n        v = previousValue + v;\n    } else {\n        //  The coordinate is 2 bytes long.\n        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n        if ((flag & sameBitMask) > 0) {\n            v = previousValue;\n        } else {\n            // Parse the coordinate as a signed 16-bit delta value.\n            v = previousValue + p.parseShort();\n        }\n    }\n\n    return v;\n}\n\n// Parse a TrueType glyph.\nfunction parseGlyph(glyph, data, start) {\n    var p = new parse.Parser(data, start);\n    glyph.numberOfContours = p.parseShort();\n    glyph._xMin = p.parseShort();\n    glyph._yMin = p.parseShort();\n    glyph._xMax = p.parseShort();\n    glyph._yMax = p.parseShort();\n    var flags;\n    var flag;\n\n    if (glyph.numberOfContours > 0) {\n        // This glyph is not a composite.\n        var endPointIndices = glyph.endPointIndices = [];\n        for (var i = 0; i < glyph.numberOfContours; i += 1) {\n            endPointIndices.push(p.parseUShort());\n        }\n\n        glyph.instructionLength = p.parseUShort();\n        glyph.instructions = [];\n        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {\n            glyph.instructions.push(p.parseByte());\n        }\n\n        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n        flags = [];\n        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {\n            flag = p.parseByte();\n            flags.push(flag);\n            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n            if ((flag & 8) > 0) {\n                var repeatCount = p.parseByte();\n                for (var j = 0; j < repeatCount; j += 1) {\n                    flags.push(flag);\n                    i$2 += 1;\n                }\n            }\n        }\n\n        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n        if (endPointIndices.length > 0) {\n            var points = [];\n            var point;\n            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n            if (numberOfCoordinates > 0) {\n                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {\n                    flag = flags[i$3];\n                    point = {};\n                    point.onCurve = !!(flag & 1);\n                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;\n                    points.push(point);\n                }\n\n                var px = 0;\n                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {\n                    flag = flags[i$4];\n                    point = points[i$4];\n                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                    px = point.x;\n                }\n\n                var py = 0;\n                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {\n                    flag = flags[i$5];\n                    point = points[i$5];\n                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                    py = point.y;\n                }\n            }\n\n            glyph.points = points;\n        } else {\n            glyph.points = [];\n        }\n    } else if (glyph.numberOfContours === 0) {\n        glyph.points = [];\n    } else {\n        glyph.isComposite = true;\n        glyph.points = [];\n        glyph.components = [];\n        var moreComponents = true;\n        while (moreComponents) {\n            flags = p.parseUShort();\n            var component = {\n                glyphIndex: p.parseUShort(),\n                xScale: 1,\n                scale01: 0,\n                scale10: 0,\n                yScale: 1,\n                dx: 0,\n                dy: 0\n            };\n            if ((flags & 1) > 0) {\n                // The arguments are words\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseShort();\n                    component.dy = p.parseShort();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n                }\n\n            } else {\n                // The arguments are bytes\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseChar();\n                    component.dy = p.parseChar();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseByte(), p.parseByte()];\n                }\n            }\n\n            if ((flags & 8) > 0) {\n                // We have a scale\n                component.xScale = component.yScale = p.parseF2Dot14();\n            } else if ((flags & 64) > 0) {\n                // We have an X / Y scale\n                component.xScale = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            } else if ((flags & 128) > 0) {\n                // We have a 2x2 transformation\n                component.xScale = p.parseF2Dot14();\n                component.scale01 = p.parseF2Dot14();\n                component.scale10 = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            }\n\n            glyph.components.push(component);\n            moreComponents = !!(flags & 32);\n        }\n        if (flags & 0x100) {\n            // We have instructions\n            glyph.instructionLength = p.parseUShort();\n            glyph.instructions = [];\n            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {\n                glyph.instructions.push(p.parseByte());\n            }\n        }\n    }\n}\n\n// Transform an array of points and return a new array.\nfunction transformPoints(points, transform) {\n    var newPoints = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        var newPt = {\n            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n            onCurve: pt.onCurve,\n            lastPointOfContour: pt.lastPointOfContour\n        };\n        newPoints.push(newPt);\n    }\n\n    return newPoints;\n}\n\nfunction getContours(points) {\n    var contours = [];\n    var currentContour = [];\n    for (var i = 0; i < points.length; i += 1) {\n        var pt = points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n}\n\n// Convert the TrueType glyph outline to a Path.\nfunction getPath(points) {\n    var p = new Path();\n    if (!points) {\n        return p;\n    }\n\n    var contours = getContours(points);\n\n    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n        var contour = contours[contourIndex];\n\n        var prev = null;\n        var curr = contour[contour.length - 1];\n        var next = contour[0];\n\n        if (curr.onCurve) {\n            p.moveTo(curr.x, curr.y);\n        } else {\n            if (next.onCurve) {\n                p.moveTo(next.x, next.y);\n            } else {\n                // If both first and last points are off-curve, start at their middle.\n                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};\n                p.moveTo(start.x, start.y);\n            }\n        }\n\n        for (var i = 0; i < contour.length; ++i) {\n            prev = curr;\n            curr = next;\n            next = contour[(i + 1) % contour.length];\n\n            if (curr.onCurve) {\n                // This is a straight line.\n                p.lineTo(curr.x, curr.y);\n            } else {\n                var prev2 = prev;\n                var next2 = next;\n\n                if (!prev.onCurve) {\n                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };\n                }\n\n                if (!next.onCurve) {\n                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };\n                }\n\n                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n            }\n        }\n\n        p.closePath();\n    }\n    return p;\n}\n\nfunction buildPath(glyphs, glyph) {\n    if (glyph.isComposite) {\n        for (var j = 0; j < glyph.components.length; j += 1) {\n            var component = glyph.components[j];\n            var componentGlyph = glyphs.get(component.glyphIndex);\n            // Force the ttfGlyphLoader to parse the glyph.\n            componentGlyph.getPath();\n            if (componentGlyph.points) {\n                var transformedPoints = (void 0);\n                if (component.matchedPoints === undefined) {\n                    // component positioned by offset\n                    transformedPoints = transformPoints(componentGlyph.points, component);\n                } else {\n                    // component positioned by matched points\n                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||\n                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {\n                        throw Error('Matched points out of range in ' + glyph.name);\n                    }\n                    var firstPt = glyph.points[component.matchedPoints[0]];\n                    var secondPt = componentGlyph.points[component.matchedPoints[1]];\n                    var transform = {\n                        xScale: component.xScale, scale01: component.scale01,\n                        scale10: component.scale10, yScale: component.yScale,\n                        dx: 0, dy: 0\n                    };\n                    secondPt = transformPoints([secondPt], transform)[0];\n                    transform.dx = firstPt.x - secondPt.x;\n                    transform.dy = firstPt.y - secondPt.y;\n                    transformedPoints = transformPoints(componentGlyph.points, transform);\n                }\n                glyph.points = glyph.points.concat(transformedPoints);\n            }\n        }\n    }\n\n    return getPath(glyph.points);\n}\n\nfunction parseGlyfTableAll(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    // The last element of the loca table is invalid.\n    for (var i = 0; i < loca.length - 1; i += 1) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    }\n\n    return glyphs;\n}\n\nfunction parseGlyfTableOnLowMemory(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font);\n\n    font._push = function(i) {\n        var offset = loca[i];\n        var nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    };\n\n    return glyphs;\n}\n\n// Parse all the glyphs according to the offsets from the `loca` table.\nfunction parseGlyfTable(data, start, loca, font, opt) {\n    if (opt.lowMemory)\n        { return parseGlyfTableOnLowMemory(data, start, loca, font); }\n    else\n        { return parseGlyfTableAll(data, start, loca, font); }\n}\n\nvar glyf = { getPath: getPath, parse: parseGlyfTable};\n\n/* A TrueType font hinting interpreter.\n*\n* (c) 2017 Axel Kittenberger\n*\n* This interpreter has been implemented according to this documentation:\n* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n*\n* According to the documentation F24DOT6 values are used for pixels.\n* That means calculation is 1/64 pixel accurate and uses integer operations.\n* However, Javascript has floating point operations by default and only\n* those are available. One could make a case to simulate the 1/64 accuracy\n* exactly by truncating after every division operation\n* (for example with << 0) to get pixel exactly results as other TrueType\n* implementations. It may make sense since some fonts are pixel optimized\n* by hand using DELTAP instructions. The current implementation doesn't\n* and rather uses full floating point precision.\n*\n* xScale, yScale and rotation is currently ignored.\n*\n* A few non-trivial instructions are missing as I didn't encounter yet\n* a font that used them to test a possible implementation.\n*\n* Some fonts seem to use undocumented features regarding the twilight zone.\n* Only some of them are implemented as they were encountered.\n*\n* The exports.DEBUG statements are removed on the minified distribution file.\n*/\n\nvar instructionTable;\nvar exec;\nvar execGlyph;\nvar execComponent;\n\n/*\n* Creates a hinting object.\n*\n* There ought to be exactly one\n* for each truetype font that is used for hinting.\n*/\nfunction Hinting(font) {\n    // the font this hinting object is for\n    this.font = font;\n\n    this.getCommands = function (hPoints) {\n        return glyf.getPath(hPoints).commands;\n    };\n\n    // cached states\n    this._fpgmState  =\n    this._prepState  =\n        undefined;\n\n    // errorState\n    // 0 ... all okay\n    // 1 ... had an error in a glyf,\n    //       continue working but stop spamming\n    //       the console\n    // 2 ... error at prep, stop hinting at this ppem\n    // 3 ... error at fpeg, stop hinting for this font at all\n    this._errorState = 0;\n}\n\n/*\n* Not rounding.\n*/\nfunction roundOff(v) {\n    return v;\n}\n\n/*\n* Rounding to grid.\n*/\nfunction roundToGrid(v) {\n    //Rounding in TT is supposed to \"symmetrical around zero\"\n    return Math.sign(v) * Math.round(Math.abs(v));\n}\n\n/*\n* Rounding to double grid.\n*/\nfunction roundToDoubleGrid(v) {\n    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n}\n\n/*\n* Rounding to half grid.\n*/\nfunction roundToHalfGrid(v) {\n    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n}\n\n/*\n* Rounding to up to grid.\n*/\nfunction roundUpToGrid(v) {\n    return Math.sign(v) * Math.ceil(Math.abs(v));\n}\n\n/*\n* Rounding to down to grid.\n*/\nfunction roundDownToGrid(v) {\n    return Math.sign(v) * Math.floor(Math.abs(v));\n}\n\n/*\n* Super rounding.\n*/\nvar roundSuper = function (v) {\n    var period = this.srPeriod;\n    var phase = this.srPhase;\n    var threshold = this.srThreshold;\n    var sign = 1;\n\n    if (v < 0) {\n        v = -v;\n        sign = -1;\n    }\n\n    v += threshold - phase;\n\n    v = Math.trunc(v / period) * period;\n\n    v += phase;\n\n    // according to http://xgridfit.sourceforge.net/round.html\n    if (v < 0) { return phase * sign; }\n\n    return v * sign;\n};\n\n/*\n* Unit vector of x-axis.\n*/\nvar xUnitVector = {\n    x: 1,\n\n    y: 0,\n\n    axis: 'x',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.xo - rp1.xo;\n            do2 = p.xo - rp2.xo;\n            dm1 = rp1.x - rp1.xo;\n            dm2 = rp2.x - rp2.xo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.x = p.xo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this\n    normalSlope: Number.NEGATIVE_INFINITY,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'.\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.x = (org ? rp.xo : rp.x) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n    },\n\n    // Slope of vector line.\n    slope: 0,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.xTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.xTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.xTouched = false;\n    }\n};\n\n/*\n* Unit vector of y-axis.\n*/\nvar yUnitVector = {\n    x: 0,\n\n    y: 1,\n\n    axis: 'y',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        var do1;\n        var do2;\n        var doa1;\n        var doa2;\n        var dm1;\n        var dm2;\n        var dt;\n\n        if (!pv || pv === this) {\n            do1 = p.yo - rp1.yo;\n            do2 = p.yo - rp2.yo;\n            dm1 = rp1.y - rp1.yo;\n            dm2 = rp2.y - rp2.yo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.y = p.yo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this.\n    normalSlope: 0,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.y = (org ? rp.yo : rp.y) + d;\n            return;\n        }\n\n        var rpx = org ? rp.xo : rp.x;\n        var rpy = org ? rp.yo : rp.y;\n        var rpdx = rpx + d * pv.x;\n        var rpdy = rpy + d * pv.y;\n\n        p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n    },\n\n    // Slope of vector line.\n    slope: Number.POSITIVE_INFINITY,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.yTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.yTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.yTouched = false;\n    }\n};\n\nObject.freeze(xUnitVector);\nObject.freeze(yUnitVector);\n\n/*\n* Creates a unit vector that is not x- or y-axis.\n*/\nfunction UnitVector(x, y) {\n    this.x = x;\n    this.y = y;\n    this.axis = undefined;\n    this.slope = y / x;\n    this.normalSlope = -x / y;\n    Object.freeze(this);\n}\n\n/*\n* Gets the projected distance between two points.\n* o1/o2 ... if true, respective original position is used.\n*/\nUnitVector.prototype.distance = function(p1, p2, o1, o2) {\n    return (\n        this.x * xUnitVector.distance(p1, p2, o1, o2) +\n        this.y * yUnitVector.distance(p1, p2, o1, o2)\n    );\n};\n\n/*\n* Moves point p so the moved position has the same relative\n* position to the moved positions of rp1 and rp2 than the\n* original positions had.\n*\n* See APPENDIX on INTERPOLATE at the bottom of this file.\n*/\nUnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n    var dm1;\n    var dm2;\n    var do1;\n    var do2;\n    var doa1;\n    var doa2;\n    var dt;\n\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n\n    if (dt === 0) {\n        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n        return;\n    }\n\n    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n};\n\n/*\n* Sets the point 'p' relative to point 'rp'\n* by the distance 'd'\n*\n* See APPENDIX on SETRELATIVE at the bottom of this file.\n*\n* p   ...  point to set\n* rp  ... reference point\n* d   ... distance on projection vector\n* pv  ... projection vector (undefined = this)\n* org ... if true, uses the original position of rp as reference.\n*/\nUnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n    pv = pv || this;\n\n    var rpx = org ? rp.xo : rp.x;\n    var rpy = org ? rp.yo : rp.y;\n    var rpdx = rpx + d * pv.x;\n    var rpdy = rpy + d * pv.y;\n\n    var pvns = pv.normalSlope;\n    var fvs = this.slope;\n\n    var px = p.x;\n    var py = p.y;\n\n    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n    p.y = fvs * (p.x - px) + py;\n};\n\n/*\n* Touches the point p.\n*/\nUnitVector.prototype.touch = function(p) {\n    p.xTouched = true;\n    p.yTouched = true;\n};\n\n/*\n* Returns a unit vector with x/y coordinates.\n*/\nfunction getUnitVector(x, y) {\n    var d = Math.sqrt(x * x + y * y);\n\n    x /= d;\n    y /= d;\n\n    if (x === 1 && y === 0) { return xUnitVector; }\n    else if (x === 0 && y === 1) { return yUnitVector; }\n    else { return new UnitVector(x, y); }\n}\n\n/*\n* Creates a point in the hinting engine.\n*/\nfunction HPoint(\n    x,\n    y,\n    lastPointOfContour,\n    onCurve\n) {\n    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n    this.lastPointOfContour = lastPointOfContour;\n    this.onCurve = onCurve;\n    this.prevPointOnContour = undefined;\n    this.nextPointOnContour = undefined;\n    this.xTouched = false;\n    this.yTouched = false;\n\n    Object.preventExtensions(this);\n}\n\n/*\n* Returns the next touched point on the contour.\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.nextTouched = function(v) {\n    var p = this.nextPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }\n\n    return p;\n};\n\n/*\n* Returns the previous touched point on the contour\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.prevTouched = function(v) {\n    var p = this.prevPointOnContour;\n\n    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }\n\n    return p;\n};\n\n/*\n* The zero point.\n*/\nvar HPZero = Object.freeze(new HPoint(0, 0));\n\n/*\n* The default state of the interpreter.\n*\n* Note: Freezing the defaultState and then deriving from it\n* makes the V8 Javascript engine going awkward,\n* so this is avoided, albeit the defaultState shouldn't\n* ever change.\n*/\nvar defaultState = {\n    cvCutIn: 17 / 16,    // control value cut in\n    deltaBase: 9,\n    deltaShift: 0.125,\n    loop: 1,             // loops some instructions\n    minDis: 1,           // minimum distance\n    autoFlip: true\n};\n\n/*\n* The current state of the interpreter.\n*\n* env  ... 'fpgm' or 'prep' or 'glyf'\n* prog ... the program\n*/\nfunction State(env, prog) {\n    this.env = env;\n    this.stack = [];\n    this.prog = prog;\n\n    switch (env) {\n        case 'glyf' :\n            this.zp0 = this.zp1 = this.zp2 = 1;\n            this.rp0 = this.rp1 = this.rp2 = 0;\n            /* fall through */\n        case 'prep' :\n            this.fv = this.pv = this.dpv = xUnitVector;\n            this.round = roundToGrid;\n    }\n}\n\n/*\n* Executes a glyph program.\n*\n* This does the hinting for each glyph.\n*\n* Returns an array of moved points.\n*\n* glyph: the glyph to hint\n* ppem: the size the glyph is rendered for\n*/\nHinting.prototype.exec = function(glyph, ppem) {\n    if (typeof ppem !== 'number') {\n        throw new Error('Point size is not a number!');\n    }\n\n    // Received a fatal error, don't do any hinting anymore.\n    if (this._errorState > 2) { return; }\n\n    var font = this.font;\n    var prepState = this._prepState;\n\n    if (!prepState || prepState.ppem !== ppem) {\n        var fpgmState = this._fpgmState;\n\n        if (!fpgmState) {\n            // Executes the fpgm state.\n            // This is used by fonts to define functions.\n            State.prototype = defaultState;\n\n            fpgmState =\n            this._fpgmState =\n                new State('fpgm', font.tables.fpgm);\n\n            fpgmState.funcs = [ ];\n            fpgmState.font = font;\n\n            if (exports.DEBUG) {\n                console.log('---EXEC FPGM---');\n                fpgmState.step = -1;\n            }\n\n            try {\n                exec(fpgmState);\n            } catch (e) {\n                console.log('Hinting error in FPGM:' + e);\n                this._errorState = 3;\n                return;\n            }\n        }\n\n        // Executes the prep program for this ppem setting.\n        // This is used by fonts to set cvt values\n        // depending on to be rendered font size.\n\n        State.prototype = fpgmState;\n        prepState =\n        this._prepState =\n            new State('prep', font.tables.prep);\n\n        prepState.ppem = ppem;\n\n        // Creates a copy of the cvt table\n        // and scales it to the current ppem setting.\n        var oCvt = font.tables.cvt;\n        if (oCvt) {\n            var cvt = prepState.cvt = new Array(oCvt.length);\n            var scale = ppem / font.unitsPerEm;\n            for (var c = 0; c < oCvt.length; c++) {\n                cvt[c] = oCvt[c] * scale;\n            }\n        } else {\n            prepState.cvt = [];\n        }\n\n        if (exports.DEBUG) {\n            console.log('---EXEC PREP---');\n            prepState.step = -1;\n        }\n\n        try {\n            exec(prepState);\n        } catch (e) {\n            if (this._errorState < 2) {\n                console.log('Hinting error in PREP:' + e);\n            }\n            this._errorState = 2;\n        }\n    }\n\n    if (this._errorState > 1) { return; }\n\n    try {\n        return execGlyph(glyph, prepState);\n    } catch (e) {\n        if (this._errorState < 1) {\n            console.log('Hinting error:' + e);\n            console.log('Note: further hinting errors are silenced');\n        }\n        this._errorState = 1;\n        return undefined;\n    }\n};\n\n/*\n* Executes the hinting program for a glyph.\n*/\nexecGlyph = function(glyph, prepState) {\n    // original point positions\n    var xScale = prepState.ppem / prepState.font.unitsPerEm;\n    var yScale = xScale;\n    var components = glyph.components;\n    var contours;\n    var gZone;\n    var state;\n\n    State.prototype = prepState;\n    if (!components) {\n        state = new State('glyf', glyph.instructions);\n        if (exports.DEBUG) {\n            console.log('---EXEC GLYPH---');\n            state.step = -1;\n        }\n        execComponent(glyph, state, xScale, yScale);\n        gZone = state.gZone;\n    } else {\n        var font = prepState.font;\n        gZone = [];\n        contours = [];\n        for (var i = 0; i < components.length; i++) {\n            var c = components[i];\n            var cg = font.glyphs.get(c.glyphIndex);\n\n            state = new State('glyf', cg.instructions);\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMP ' + i + '---');\n                state.step = -1;\n            }\n\n            execComponent(cg, state, xScale, yScale);\n            // appends the computed points to the result array\n            // post processes the component points\n            var dx = Math.round(c.dx * xScale);\n            var dy = Math.round(c.dy * yScale);\n            var gz = state.gZone;\n            var cc = state.contours;\n            for (var pi = 0; pi < gz.length; pi++) {\n                var p = gz[pi];\n                p.xTouched = p.yTouched = false;\n                p.xo = p.x = p.x + dx;\n                p.yo = p.y = p.y + dy;\n            }\n\n            var gLen = gZone.length;\n            gZone.push.apply(gZone, gz);\n            for (var j = 0; j < cc.length; j++) {\n                contours.push(cc[j] + gLen);\n            }\n        }\n\n        if (glyph.instructions && !state.inhibitGridFit) {\n            // the composite has instructions on its own\n            state = new State('glyf', glyph.instructions);\n\n            state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n\n            state.contours = contours;\n\n            // note: HPZero cannot be used here, since\n            //       the point might be modified\n            gZone.push(\n                new HPoint(0, 0),\n                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n            );\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMPOSITE---');\n                state.step = -1;\n            }\n\n            exec(state);\n\n            gZone.length -= 2;\n        }\n    }\n\n    return gZone;\n};\n\n/*\n* Executes the hinting program for a component of a multi-component glyph\n* or of the glyph itself for a non-component glyph.\n*/\nexecComponent = function(glyph, state, xScale, yScale)\n{\n    var points = glyph.points || [];\n    var pLen = points.length;\n    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n    var contours = state.contours = [];\n\n    // Scales the original points and\n    // makes copies for the hinted points.\n    var cp; // current point\n    for (var i = 0; i < pLen; i++) {\n        cp = points[i];\n\n        gZone[i] = new HPoint(\n            cp.x * xScale,\n            cp.y * yScale,\n            cp.lastPointOfContour,\n            cp.onCurve\n        );\n    }\n\n    // Chain links the contours.\n    var sp; // start point\n    var np; // next point\n\n    for (var i$1 = 0; i$1 < pLen; i$1++) {\n        cp = gZone[i$1];\n\n        if (!sp) {\n            sp = cp;\n            contours.push(i$1);\n        }\n\n        if (cp.lastPointOfContour) {\n            cp.nextPointOnContour = sp;\n            sp.prevPointOnContour = cp;\n            sp = undefined;\n        } else {\n            np = gZone[i$1 + 1];\n            cp.nextPointOnContour = np;\n            np.prevPointOnContour = cp;\n        }\n    }\n\n    if (state.inhibitGridFit) { return; }\n\n    if (exports.DEBUG) {\n        console.log('PROCESSING GLYPH', state.stack);\n        for (var i$2 = 0; i$2 < pLen; i$2++) {\n            console.log(i$2, gZone[i$2].x, gZone[i$2].y);\n        }\n    }\n\n    gZone.push(\n        new HPoint(0, 0),\n        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n    );\n\n    exec(state);\n\n    // Removes the extra points.\n    gZone.length -= 2;\n\n    if (exports.DEBUG) {\n        console.log('FINISHED GLYPH', state.stack);\n        for (var i$3 = 0; i$3 < pLen; i$3++) {\n            console.log(i$3, gZone[i$3].x, gZone[i$3].y);\n        }\n    }\n};\n\n/*\n* Executes the program loaded in state.\n*/\nexec = function(state) {\n    var prog = state.prog;\n\n    if (!prog) { return; }\n\n    var pLen = prog.length;\n    var ins;\n\n    for (state.ip = 0; state.ip < pLen; state.ip++) {\n        if (exports.DEBUG) { state.step++; }\n        ins = instructionTable[prog[state.ip]];\n\n        if (!ins) {\n            throw new Error(\n                'unknown instruction: 0x' +\n                Number(prog[state.ip]).toString(16)\n            );\n        }\n\n        ins(state);\n\n        // very extensive debugging for each step\n        /*\n        if (exports.DEBUG) {\n            var da;\n            if (state.gZone) {\n                da = [];\n                for (let i = 0; i < state.gZone.length; i++)\n                {\n                    da.push(i + ' ' +\n                        state.gZone[i].x * 64 + ' ' +\n                        state.gZone[i].y * 64 + ' ' +\n                        (state.gZone[i].xTouched ? 'x' : '') +\n                        (state.gZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('GZ', da);\n            }\n\n            if (state.tZone) {\n                da = [];\n                for (let i = 0; i < state.tZone.length; i++) {\n                    da.push(i + ' ' +\n                        state.tZone[i].x * 64 + ' ' +\n                        state.tZone[i].y * 64 + ' ' +\n                        (state.tZone[i].xTouched ? 'x' : '') +\n                        (state.tZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('TZ', da);\n            }\n\n            if (state.stack.length > 10) {\n                console.log(\n                    state.stack.length,\n                    '...', state.stack.slice(state.stack.length - 10)\n                );\n            } else {\n                console.log(state.stack.length, state.stack);\n            }\n        }\n        */\n    }\n};\n\n/*\n* Initializes the twilight zone.\n*\n* This is only done if a SZPx instruction\n* refers to the twilight zone.\n*/\nfunction initTZone(state)\n{\n    var tZone = state.tZone = new Array(state.gZone.length);\n\n    // no idea if this is actually correct...\n    for (var i = 0; i < tZone.length; i++)\n    {\n        tZone[i] = new HPoint(0, 0);\n    }\n}\n\n/*\n* Skips the instruction pointer ahead over an IF/ELSE block.\n* handleElse .. if true breaks on matching ELSE\n*/\nfunction skip(state, handleElse)\n{\n    var prog = state.prog;\n    var ip = state.ip;\n    var nesting = 1;\n    var ins;\n\n    do {\n        ins = prog[++ip];\n        if (ins === 0x58) // IF\n            { nesting++; }\n        else if (ins === 0x59) // EIF\n            { nesting--; }\n        else if (ins === 0x40) // NPUSHB\n            { ip += prog[ip + 1] + 1; }\n        else if (ins === 0x41) // NPUSHW\n            { ip += 2 * prog[ip + 1] + 1; }\n        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n            { ip += ins - 0xB0 + 1; }\n        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n            { ip += (ins - 0xB8 + 1) * 2; }\n        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n            { break; }\n    } while (nesting > 0);\n\n    state.ip = ip;\n}\n\n/*----------------------------------------------------------*\n*          And then a lot of instructions...                *\n*----------------------------------------------------------*/\n\n// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n// 0x00-0x01\nfunction SVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }\n\n    state.fv = state.pv = state.dpv = v;\n}\n\n// SPVTCA[a] Set Projection Vector to Coordinate Axis\n// 0x02-0x03\nfunction SPVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }\n\n    state.pv = state.dpv = v;\n}\n\n// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n// 0x04-0x05\nfunction SFVTCA(v, state) {\n    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }\n\n    state.fv = v;\n}\n\n// SPVTL[a] Set Projection Vector To Line\n// 0x06-0x07\nfunction SPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.pv = state.dpv = getUnitVector(dx, dy);\n}\n\n// SFVTL[a] Set Freedom Vector To Line\n// 0x08-0x09\nfunction SFVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.fv = getUnitVector(dx, dy);\n}\n\n// SPVFS[] Set Projection Vector From Stack\n// 0x0A\nfunction SPVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.pv = state.dpv = getUnitVector(x, y);\n}\n\n// SFVFS[] Set Freedom Vector From Stack\n// 0x0B\nfunction SFVFS(state) {\n    var stack = state.stack;\n    var y = stack.pop();\n    var x = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n    state.fv = getUnitVector(x, y);\n}\n\n// GPV[] Get Projection Vector\n// 0x0C\nfunction GPV(state) {\n    var stack = state.stack;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }\n\n    stack.push(pv.x * 0x4000);\n    stack.push(pv.y * 0x4000);\n}\n\n// GFV[] Get Freedom Vector\n// 0x0C\nfunction GFV(state) {\n    var stack = state.stack;\n    var fv = state.fv;\n\n    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }\n\n    stack.push(fv.x * 0x4000);\n    stack.push(fv.y * 0x4000);\n}\n\n// SFVTPV[] Set Freedom Vector To Projection Vector\n// 0x0E\nfunction SFVTPV(state) {\n    state.fv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }\n}\n\n// ISECT[] moves point p to the InterSECTion of two lines\n// 0x0F\nfunction ISECT(state)\n{\n    var stack = state.stack;\n    var pa0i = stack.pop();\n    var pa1i = stack.pop();\n    var pb0i = stack.pop();\n    var pb1i = stack.pop();\n    var pi = stack.pop();\n    var z0 = state.z0;\n    var z1 = state.z1;\n    var pa0 = z0[pa0i];\n    var pa1 = z0[pa1i];\n    var pb0 = z1[pb0i];\n    var pb1 = z1[pb1i];\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }\n\n    // math from\n    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n    var x1 = pa0.x;\n    var y1 = pa0.y;\n    var x2 = pa1.x;\n    var y2 = pa1.y;\n    var x3 = pb0.x;\n    var y3 = pb0.y;\n    var x4 = pb1.x;\n    var y4 = pb1.y;\n\n    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    var f1 = x1 * y2 - y1 * x2;\n    var f2 = x3 * y4 - y3 * x4;\n\n    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n}\n\n// SRP0[] Set Reference Point 0\n// 0x10\nfunction SRP0(state) {\n    state.rp0 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }\n}\n\n// SRP1[] Set Reference Point 1\n// 0x11\nfunction SRP1(state) {\n    state.rp1 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }\n}\n\n// SRP1[] Set Reference Point 2\n// 0x12\nfunction SRP2(state) {\n    state.rp2 = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }\n}\n\n// SZP0[] Set Zone Pointer 0\n// 0x13\nfunction SZP0(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }\n\n    state.zp0 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP1[] Set Zone Pointer 1\n// 0x14\nfunction SZP1(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }\n\n    state.zp1 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z1 = state.tZone;\n            break;\n        case 1 :\n            state.z1 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP2[] Set Zone Pointer 2\n// 0x15\nfunction SZP2(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }\n\n    state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZPS[] Set Zone PointerS\n// 0x16\nfunction SZPS(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }\n\n    state.zp0 = state.zp1 = state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) { initTZone(state); }\n            state.z0 = state.z1 = state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.z1 = state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SLOOP[] Set LOOP variable\n// 0x17\nfunction SLOOP(state) {\n    state.loop = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }\n}\n\n// RTG[] Round To Grid\n// 0x18\nfunction RTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }\n\n    state.round = roundToGrid;\n}\n\n// RTHG[] Round To Half Grid\n// 0x19\nfunction RTHG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }\n\n    state.round = roundToHalfGrid;\n}\n\n// SMD[] Set Minimum Distance\n// 0x1A\nfunction SMD(state) {\n    var d = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }\n\n    state.minDis = d / 0x40;\n}\n\n// ELSE[] ELSE clause\n// 0x1B\nfunction ELSE(state) {\n    // This instruction has been reached by executing a then branch\n    // so it just skips ahead until matching EIF.\n    //\n    // In case the IF was negative the IF[] instruction already\n    // skipped forward over the ELSE[]\n\n    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }\n\n    skip(state, false);\n}\n\n// JMPR[] JuMP Relative\n// 0x1C\nfunction JMPR(state) {\n    var o = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }\n\n    // A jump by 1 would do nothing.\n    state.ip += o - 1;\n}\n\n// SCVTCI[] Set Control Value Table Cut-In\n// 0x1D\nfunction SCVTCI(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }\n\n    state.cvCutIn = n / 0x40;\n}\n\n// DUP[] DUPlicate top stack element\n// 0x20\nfunction DUP(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }\n\n    stack.push(stack[stack.length - 1]);\n}\n\n// POP[] POP top stack element\n// 0x21\nfunction POP(state) {\n    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }\n\n    state.stack.pop();\n}\n\n// CLEAR[] CLEAR the stack\n// 0x22\nfunction CLEAR(state) {\n    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }\n\n    state.stack.length = 0;\n}\n\n// SWAP[] SWAP the top two elements on the stack\n// 0x23\nfunction SWAP(state) {\n    var stack = state.stack;\n\n    var a = stack.pop();\n    var b = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }\n\n    stack.push(a);\n    stack.push(b);\n}\n\n// DEPTH[] DEPTH of the stack\n// 0x24\nfunction DEPTH(state) {\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }\n\n    stack.push(stack.length);\n}\n\n// LOOPCALL[] LOOPCALL function\n// 0x2A\nfunction LOOPCALL(state) {\n    var stack = state.stack;\n    var fn = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    for (var i = 0; i < c; i++) {\n        exec(state);\n\n        if (exports.DEBUG) { console.log(\n            ++state.step,\n            i + 1 < c ? 'next loopcall' : 'done loopcall',\n            i\n        ); }\n    }\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n}\n\n// CALL[] CALL function\n// 0x2B\nfunction CALL(state) {\n    var fn = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }\n\n    // saves callers program\n    var cip = state.ip;\n    var cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    exec(state);\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n\n    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }\n}\n\n// CINDEX[] Copy the INDEXed element to the top of the stack\n// 0x25\nfunction CINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }\n\n    // In case of k == 1, it copies the last element after popping\n    // thus stack.length - k.\n    stack.push(stack[stack.length - k]);\n}\n\n// MINDEX[] Move the INDEXed element to the top of the stack\n// 0x26\nfunction MINDEX(state) {\n    var stack = state.stack;\n    var k = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }\n\n    stack.push(stack.splice(stack.length - k, 1)[0]);\n}\n\n// FDEF[] Function DEFinition\n// 0x2C\nfunction FDEF(state) {\n    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    var fn = stack.pop();\n    var ipBegin = ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }\n\n    while (prog[++ip] !== 0x2D){ }\n\n    state.ip = ip;\n    state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n}\n\n// MDAP[a] Move Direct Absolute Point\n// 0x2E-0x2F\nfunction MDAP(round, state) {\n    var pi = state.stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) { d = state.round(d); }\n\n    fv.setRelative(p, HPZero, d, pv);\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// IUP[a] Interpolate Untouched Points through the outline\n// 0x30\nfunction IUP(v, state) {\n    var z2 = state.z2;\n    var pLen = z2.length - 2;\n    var cp;\n    var pp;\n    var np;\n\n    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }\n\n    for (var i = 0; i < pLen; i++) {\n        cp = z2[i]; // current point\n\n        // if this point has been touched go on\n        if (v.touched(cp)) { continue; }\n\n        pp = cp.prevTouched(v);\n\n        // no point on the contour has been touched?\n        if (pp === cp) { continue; }\n\n        np = cp.nextTouched(v);\n\n        if (pp === np) {\n            // only one point on the contour has been touched\n            // so simply moves the point like that\n\n            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n        }\n\n        v.interpolate(cp, pp, np, v);\n    }\n}\n\n// SHP[] SHift Point using reference point\n// 0x32-0x33\nfunction SHP(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var loop = state.loop;\n    var z2 = state.z2;\n\n    while (loop--)\n    {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        var d = pv.distance(rp, rp, false, true);\n        fv.setRelative(p, p, d, pv);\n        fv.touch(p);\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ?\n                   'loop ' + (state.loop - loop) + ': ' :\n                   ''\n                ) +\n                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi\n            );\n        }\n    }\n\n    state.loop = 1;\n}\n\n// SHC[] SHift Contour using reference point\n// 0x36-0x37\nfunction SHC(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var ci = stack.pop();\n    var sp = state.z2[state.contours[ci]];\n    var p = sp;\n\n    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }\n\n    var d = pv.distance(rp, rp, false, true);\n\n    do {\n        if (p !== rp) { fv.setRelative(p, p, d, pv); }\n        p = p.nextPointOnContour;\n    } while (p !== sp);\n}\n\n// SHZ[] SHift Zone using reference point\n// 0x36-0x37\nfunction SHZ(a, state) {\n    var stack = state.stack;\n    var rpi = a ? state.rp1 : state.rp2;\n    var rp = (a ? state.z0 : state.z1)[rpi];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }\n\n    var z;\n    switch (e) {\n        case 0 : z = state.tZone; break;\n        case 1 : z = state.gZone; break;\n        default : throw new Error('Invalid zone');\n    }\n\n    var p;\n    var d = pv.distance(rp, rp, false, true);\n    var pLen = z.length - 2;\n    for (var i = 0; i < pLen; i++)\n    {\n        p = z[i];\n        fv.setRelative(p, p, d, pv);\n        //if (p !== rp) fv.setRelative(p, p, d, pv);\n    }\n}\n\n// SHPIX[] SHift point by a PIXel amount\n// 0x38\nfunction SHPIX(state) {\n    var stack = state.stack;\n    var loop = state.loop;\n    var fv = state.fv;\n    var d = stack.pop() / 0x40;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'SHPIX[]', pi, d\n            );\n        }\n\n        fv.setRelative(p, p, d);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// IP[] Interpolate Point\n// 0x39\nfunction IP(state) {\n    var stack = state.stack;\n    var rp1i = state.rp1;\n    var rp2i = state.rp2;\n    var loop = state.loop;\n    var rp1 = state.z0[rp1i];\n    var rp2 = state.z1[rp2i];\n    var fv = state.fv;\n    var pv = state.dpv;\n    var z2 = state.z2;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'IP[]', pi, rp1i, '<->', rp2i\n            );\n        }\n\n        fv.interpolate(p, rp1, rp2, pv);\n\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// MSIRP[a] Move Stack Indirect Relative Point\n// 0x3A-0x3B\nfunction MSIRP(a, state) {\n    var stack = state.stack;\n    var d = stack.pop() / 64;\n    var pi = stack.pop();\n    var p = state.z1[pi];\n    var rp0 = state.z0[state.rp0];\n    var fv = state.fv;\n    var pv = state.pv;\n\n    fv.setRelative(p, rp0, d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (a) { state.rp0 = pi; }\n}\n\n// ALIGNRP[] Align to reference point.\n// 0x3C\nfunction ALIGNRP(state) {\n    var stack = state.stack;\n    var rp0i = state.rp0;\n    var rp0 = state.z0[rp0i];\n    var loop = state.loop;\n    var fv = state.fv;\n    var pv = state.pv;\n    var z1 = state.z1;\n\n    while (loop--) {\n        var pi = stack.pop();\n        var p = z1[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'ALIGNRP[]', pi\n            );\n        }\n\n        fv.setRelative(p, rp0, 0, pv);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// RTG[] Round To Double Grid\n// 0x3D\nfunction RTDG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }\n\n    state.round = roundToDoubleGrid;\n}\n\n// MIAP[a] Move Indirect Absolute Point\n// 0x3E-0x3F\nfunction MIAP(round, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var pi = stack.pop();\n    var p = state.z0[pi];\n    var fv = state.fv;\n    var pv = state.pv;\n    var cv = state.cvt[n];\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            'MIAP[' + round + ']',\n            n, '(', cv, ')', pi\n        );\n    }\n\n    var d = pv.distance(p, HPZero);\n\n    if (round) {\n        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n\n        d = state.round(d);\n    }\n\n    fv.setRelative(p, HPZero, d, pv);\n\n    if (state.zp0 === 0) {\n        p.xo = p.x;\n        p.yo = p.y;\n    }\n\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// NPUSB[] PUSH N Bytes\n// 0x40\nfunction NPUSHB(state) {\n    var prog = state.prog;\n    var ip = state.ip;\n    var stack = state.stack;\n\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// NPUSHW[] PUSH N Words\n// 0x41\nfunction NPUSHW(state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n    var n = prog[++ip];\n\n    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// WS[] Write Store\n// 0x42\nfunction WS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    if (!store) { store = state.store = []; }\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }\n\n    store[l] = v;\n}\n\n// RS[] Read Store\n// 0x43\nfunction RS(state) {\n    var stack = state.stack;\n    var store = state.store;\n\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RS', l); }\n\n    var v = (store && store[l]) || 0;\n\n    stack.push(v);\n}\n\n// WCVTP[] Write Control Value Table in Pixel units\n// 0x44\nfunction WCVTP(state) {\n    var stack = state.stack;\n\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }\n\n    state.cvt[l] = v / 0x40;\n}\n\n// RCVT[] Read Control Value Table entry\n// 0x45\nfunction RCVT(state) {\n    var stack = state.stack;\n    var cvte = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }\n\n    stack.push(state.cvt[cvte] * 0x40);\n}\n\n// GC[] Get Coordinate projected onto the projection vector\n// 0x46-0x47\nfunction GC(a, state) {\n    var stack = state.stack;\n    var pi = stack.pop();\n    var p = state.z2[pi];\n\n    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }\n\n    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n}\n\n// MD[a] Measure Distance\n// 0x49-0x4A\nfunction MD(a, state) {\n    var stack = state.stack;\n    var pi2 = stack.pop();\n    var pi1 = stack.pop();\n    var p2 = state.z1[pi2];\n    var p1 = state.z0[pi1];\n    var d = state.dpv.distance(p1, p2, a, a);\n\n    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }\n\n    state.stack.push(Math.round(d * 64));\n}\n\n// MPPEM[] Measure Pixels Per EM\n// 0x4B\nfunction MPPEM(state) {\n    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }\n    state.stack.push(state.ppem);\n}\n\n// FLIPON[] set the auto FLIP Boolean to ON\n// 0x4D\nfunction FLIPON(state) {\n    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }\n    state.autoFlip = true;\n}\n\n// LT[] Less Than\n// 0x50\nfunction LT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }\n\n    stack.push(e1 < e2 ? 1 : 0);\n}\n\n// LTEQ[] Less Than or EQual\n// 0x53\nfunction LTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }\n\n    stack.push(e1 <= e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than\n// 0x52\nfunction GT(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }\n\n    stack.push(e1 > e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than or EQual\n// 0x53\nfunction GTEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }\n\n    stack.push(e1 >= e2 ? 1 : 0);\n}\n\n// EQ[] EQual\n// 0x54\nfunction EQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }\n\n    stack.push(e2 === e1 ? 1 : 0);\n}\n\n// NEQ[] Not EQual\n// 0x55\nfunction NEQ(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }\n\n    stack.push(e2 !== e1 ? 1 : 0);\n}\n\n// ODD[] ODD\n// 0x56\nfunction ODD(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 1 : 0);\n}\n\n// EVEN[] EVEN\n// 0x57\nfunction EVEN(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }\n\n    stack.push(Math.trunc(n) % 2 ? 0 : 1);\n}\n\n// IF[] IF test\n// 0x58\nfunction IF(state) {\n    var test = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }\n\n    // if test is true it just continues\n    // if not the ip is skipped until matching ELSE or EIF\n    if (!test) {\n        skip(state, true);\n\n        if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }\n    }\n}\n\n// EIF[] End IF\n// 0x59\nfunction EIF(state) {\n    // this can be reached normally when\n    // executing an else branch.\n    // -> just ignore it\n\n    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }\n}\n\n// AND[] logical AND\n// 0x5A\nfunction AND(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }\n\n    stack.push(e2 && e1 ? 1 : 0);\n}\n\n// OR[] logical OR\n// 0x5B\nfunction OR(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }\n\n    stack.push(e2 || e1 ? 1 : 0);\n}\n\n// NOT[] logical NOT\n// 0x5C\nfunction NOT(state) {\n    var stack = state.stack;\n    var e = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }\n\n    stack.push(e ? 0 : 1);\n}\n\n// DELTAP1[] DELTA exception P1\n// DELTAP2[] DELTA exception P2\n// DELTAP3[] DELTA exception P3\n// 0x5D, 0x71, 0x72\nfunction DELTAP123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var fv = state.fv;\n    var pv = state.pv;\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n    var z0 = state.z0;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var pi = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }\n\n        var p = z0[pi];\n        fv.setRelative(p, p, mag * ds, pv);\n    }\n}\n\n// SDB[] Set Delta Base in the graphics state\n// 0x5E\nfunction SDB(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }\n\n    state.deltaBase = n;\n}\n\n// SDS[] Set Delta Shift in the graphics state\n// 0x5F\nfunction SDS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }\n\n    state.deltaShift = Math.pow(0.5, n);\n}\n\n// ADD[] ADD\n// 0x60\nfunction ADD(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }\n\n    stack.push(n1 + n2);\n}\n\n// SUB[] SUB\n// 0x61\nfunction SUB(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }\n\n    stack.push(n1 - n2);\n}\n\n// DIV[] DIV\n// 0x62\nfunction DIV(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }\n\n    stack.push(n1 * 64 / n2);\n}\n\n// MUL[] MUL\n// 0x63\nfunction MUL(state) {\n    var stack = state.stack;\n    var n2 = stack.pop();\n    var n1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }\n\n    stack.push(n1 * n2 / 64);\n}\n\n// ABS[] ABSolute value\n// 0x64\nfunction ABS(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }\n\n    stack.push(Math.abs(n));\n}\n\n// NEG[] NEGate\n// 0x65\nfunction NEG(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }\n\n    stack.push(-n);\n}\n\n// FLOOR[] FLOOR\n// 0x66\nfunction FLOOR(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }\n\n    stack.push(Math.floor(n / 0x40) * 0x40);\n}\n\n// CEILING[] CEILING\n// 0x67\nfunction CEILING(state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }\n\n    stack.push(Math.ceil(n / 0x40) * 0x40);\n}\n\n// ROUND[ab] ROUND value\n// 0x68-0x6B\nfunction ROUND(dt, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }\n\n    stack.push(state.round(n / 0x40) * 0x40);\n}\n\n// WCVTF[] Write Control Value Table in Funits\n// 0x70\nfunction WCVTF(state) {\n    var stack = state.stack;\n    var v = stack.pop();\n    var l = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }\n\n    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n}\n\n// DELTAC1[] DELTA exception C1\n// DELTAC2[] DELTA exception C2\n// DELTAC3[] DELTA exception C3\n// 0x73, 0x74, 0x75\nfunction DELTAC123(b, state) {\n    var stack = state.stack;\n    var n = stack.pop();\n    var ppem = state.ppem;\n    var base = state.deltaBase + (b - 1) * 16;\n    var ds = state.deltaShift;\n\n    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }\n\n    for (var i = 0; i < n; i++) {\n        var c = stack.pop();\n        var arg = stack.pop();\n        var appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) { continue; }\n\n        var mag = (arg & 0x0F) - 8;\n        if (mag >= 0) { mag++; }\n\n        var delta = mag * ds;\n\n        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }\n\n        state.cvt[c] += delta;\n    }\n}\n\n// SROUND[] Super ROUND\n// 0x76\nfunction SROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = 0.5;\n            break;\n        case 0x40:\n            period = 1;\n            break;\n        case 0x80:\n            period = 2;\n            break;\n        default:\n            throw new Error('invalid SROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default: throw new Error('invalid SROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// S45ROUND[] Super ROUND 45 degrees\n// 0x77\nfunction S45ROUND(state) {\n    var n = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }\n\n    state.round = roundSuper;\n\n    var period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = Math.sqrt(2) / 2;\n            break;\n        case 0x40:\n            period = Math.sqrt(2);\n            break;\n        case 0x80:\n            period = 2 * Math.sqrt(2);\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) { state.srThreshold = 0; }\n    else { state.srThreshold = (n / 8 - 0.5) * period; }\n}\n\n// ROFF[] Round Off\n// 0x7A\nfunction ROFF(state) {\n    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }\n\n    state.round = roundOff;\n}\n\n// RUTG[] Round Up To Grid\n// 0x7C\nfunction RUTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }\n\n    state.round = roundUpToGrid;\n}\n\n// RDTG[] Round Down To Grid\n// 0x7D\nfunction RDTG(state) {\n    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }\n\n    state.round = roundDownToGrid;\n}\n\n// SCANCTRL[] SCAN conversion ConTRoL\n// 0x85\nfunction SCANCTRL(state) {\n    var n = state.stack.pop();\n\n    // ignored by opentype.js\n\n    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }\n}\n\n// SDPVTL[a] Set Dual Projection Vector To Line\n// 0x86-0x87\nfunction SDPVTL(a, state) {\n    var stack = state.stack;\n    var p2i = stack.pop();\n    var p1i = stack.pop();\n    var p2 = state.z2[p2i];\n    var p1 = state.z1[p1i];\n\n    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }\n\n    var dx;\n    var dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.dpv = getUnitVector(dx, dy);\n}\n\n// GETINFO[] GET INFOrmation\n// 0x88\nfunction GETINFO(state) {\n    var stack = state.stack;\n    var sel = stack.pop();\n    var r = 0;\n\n    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }\n\n    // v35 as in no subpixel hinting\n    if (sel & 0x01) { r = 35; }\n\n    // TODO rotation and stretch currently not supported\n    // and thus those GETINFO are always 0.\n\n    // opentype.js is always gray scaling\n    if (sel & 0x20) { r |= 0x1000; }\n\n    stack.push(r);\n}\n\n// ROLL[] ROLL the top three stack elements\n// 0x8A\nfunction ROLL(state) {\n    var stack = state.stack;\n    var a = stack.pop();\n    var b = stack.pop();\n    var c = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }\n\n    stack.push(b);\n    stack.push(a);\n    stack.push(c);\n}\n\n// MAX[] MAXimum of top two stack elements\n// 0x8B\nfunction MAX(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }\n\n    stack.push(Math.max(e1, e2));\n}\n\n// MIN[] MINimum of top two stack elements\n// 0x8C\nfunction MIN(state) {\n    var stack = state.stack;\n    var e2 = stack.pop();\n    var e1 = stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }\n\n    stack.push(Math.min(e1, e2));\n}\n\n// SCANTYPE[] SCANTYPE\n// 0x8D\nfunction SCANTYPE(state) {\n    var n = state.stack.pop();\n    // ignored by opentype.js\n    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }\n}\n\n// INSTCTRL[] INSTCTRL\n// 0x8D\nfunction INSTCTRL(state) {\n    var s = state.stack.pop();\n    var v = state.stack.pop();\n\n    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }\n\n    switch (s) {\n        case 1 : state.inhibitGridFit = !!v; return;\n        case 2 : state.ignoreCvt = !!v; return;\n        default: throw new Error('invalid INSTCTRL[] selector');\n    }\n}\n\n// PUSHB[abc] PUSH Bytes\n// 0xB0-0xB7\nfunction PUSHB(n, state) {\n    var stack = state.stack;\n    var prog = state.prog;\n    var ip = state.ip;\n\n    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n    state.ip = ip;\n}\n\n// PUSHW[abc] PUSH Words\n// 0xB8-0xBF\nfunction PUSHW(n, state) {\n    var ip = state.ip;\n    var prog = state.prog;\n    var stack = state.stack;\n\n    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }\n\n    for (var i = 0; i < n; i++) {\n        var w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// MDRP[abcde] Move Direct Relative Point\n// 0xD0-0xEF\n// (if indirect is 0)\n//\n// and\n//\n// MIRP[abcde] Move Indirect Relative Point\n// 0xE0-0xFF\n// (if indirect is 1)\n\nfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n    var stack = state.stack;\n    var cvte = indirect && stack.pop();\n    var pi = stack.pop();\n    var rp0i = state.rp0;\n    var rp = state.z0[rp0i];\n    var p = state.z1[pi];\n\n    var md = state.minDis;\n    var fv = state.fv;\n    var pv = state.dpv;\n    var od; // original distance\n    var d; // moving distance\n    var sign; // sign of distance\n    var cv;\n\n    d = od = pv.distance(p, rp, true, true);\n    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n    // TODO consider autoFlip\n    d = Math.abs(d);\n\n    if (indirect) {\n        cv = state.cvt[cvte];\n\n        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n    }\n\n    if (keepD && d < md) { d = md; }\n\n    if (ro) { d = state.round(d); }\n\n    fv.setRelative(p, rp, sign * d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            (indirect ? 'MIRP[' : 'MDRP[') +\n            (setRp0 ? 'M' : 'm') +\n            (keepD ? '>' : '_') +\n            (ro ? 'R' : '_') +\n            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +\n            ']',\n            indirect ?\n                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :\n                '',\n            pi,\n            '(d =', od, '->', sign * d, ')'\n        );\n    }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (setRp0) { state.rp0 = pi; }\n}\n\n/*\n* The instruction table.\n*/\ninstructionTable = [\n    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n    /* 0x06 */ SPVTL.bind(undefined, 0),\n    /* 0x07 */ SPVTL.bind(undefined, 1),\n    /* 0x08 */ SFVTL.bind(undefined, 0),\n    /* 0x09 */ SFVTL.bind(undefined, 1),\n    /* 0x0A */ SPVFS,\n    /* 0x0B */ SFVFS,\n    /* 0x0C */ GPV,\n    /* 0x0D */ GFV,\n    /* 0x0E */ SFVTPV,\n    /* 0x0F */ ISECT,\n    /* 0x10 */ SRP0,\n    /* 0x11 */ SRP1,\n    /* 0x12 */ SRP2,\n    /* 0x13 */ SZP0,\n    /* 0x14 */ SZP1,\n    /* 0x15 */ SZP2,\n    /* 0x16 */ SZPS,\n    /* 0x17 */ SLOOP,\n    /* 0x18 */ RTG,\n    /* 0x19 */ RTHG,\n    /* 0x1A */ SMD,\n    /* 0x1B */ ELSE,\n    /* 0x1C */ JMPR,\n    /* 0x1D */ SCVTCI,\n    /* 0x1E */ undefined,   // TODO SSWCI\n    /* 0x1F */ undefined,   // TODO SSW\n    /* 0x20 */ DUP,\n    /* 0x21 */ POP,\n    /* 0x22 */ CLEAR,\n    /* 0x23 */ SWAP,\n    /* 0x24 */ DEPTH,\n    /* 0x25 */ CINDEX,\n    /* 0x26 */ MINDEX,\n    /* 0x27 */ undefined,   // TODO ALIGNPTS\n    /* 0x28 */ undefined,\n    /* 0x29 */ undefined,   // TODO UTP\n    /* 0x2A */ LOOPCALL,\n    /* 0x2B */ CALL,\n    /* 0x2C */ FDEF,\n    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)\n    /* 0x2E */ MDAP.bind(undefined, 0),\n    /* 0x2F */ MDAP.bind(undefined, 1),\n    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n    /* 0x32 */ SHP.bind(undefined, 0),\n    /* 0x33 */ SHP.bind(undefined, 1),\n    /* 0x34 */ SHC.bind(undefined, 0),\n    /* 0x35 */ SHC.bind(undefined, 1),\n    /* 0x36 */ SHZ.bind(undefined, 0),\n    /* 0x37 */ SHZ.bind(undefined, 1),\n    /* 0x38 */ SHPIX,\n    /* 0x39 */ IP,\n    /* 0x3A */ MSIRP.bind(undefined, 0),\n    /* 0x3B */ MSIRP.bind(undefined, 1),\n    /* 0x3C */ ALIGNRP,\n    /* 0x3D */ RTDG,\n    /* 0x3E */ MIAP.bind(undefined, 0),\n    /* 0x3F */ MIAP.bind(undefined, 1),\n    /* 0x40 */ NPUSHB,\n    /* 0x41 */ NPUSHW,\n    /* 0x42 */ WS,\n    /* 0x43 */ RS,\n    /* 0x44 */ WCVTP,\n    /* 0x45 */ RCVT,\n    /* 0x46 */ GC.bind(undefined, 0),\n    /* 0x47 */ GC.bind(undefined, 1),\n    /* 0x48 */ undefined,   // TODO SCFS\n    /* 0x49 */ MD.bind(undefined, 0),\n    /* 0x4A */ MD.bind(undefined, 1),\n    /* 0x4B */ MPPEM,\n    /* 0x4C */ undefined,   // TODO MPS\n    /* 0x4D */ FLIPON,\n    /* 0x4E */ undefined,   // TODO FLIPOFF\n    /* 0x4F */ undefined,   // TODO DEBUG\n    /* 0x50 */ LT,\n    /* 0x51 */ LTEQ,\n    /* 0x52 */ GT,\n    /* 0x53 */ GTEQ,\n    /* 0x54 */ EQ,\n    /* 0x55 */ NEQ,\n    /* 0x56 */ ODD,\n    /* 0x57 */ EVEN,\n    /* 0x58 */ IF,\n    /* 0x59 */ EIF,\n    /* 0x5A */ AND,\n    /* 0x5B */ OR,\n    /* 0x5C */ NOT,\n    /* 0x5D */ DELTAP123.bind(undefined, 1),\n    /* 0x5E */ SDB,\n    /* 0x5F */ SDS,\n    /* 0x60 */ ADD,\n    /* 0x61 */ SUB,\n    /* 0x62 */ DIV,\n    /* 0x63 */ MUL,\n    /* 0x64 */ ABS,\n    /* 0x65 */ NEG,\n    /* 0x66 */ FLOOR,\n    /* 0x67 */ CEILING,\n    /* 0x68 */ ROUND.bind(undefined, 0),\n    /* 0x69 */ ROUND.bind(undefined, 1),\n    /* 0x6A */ ROUND.bind(undefined, 2),\n    /* 0x6B */ ROUND.bind(undefined, 3),\n    /* 0x6C */ undefined,   // TODO NROUND[ab]\n    /* 0x6D */ undefined,   // TODO NROUND[ab]\n    /* 0x6E */ undefined,   // TODO NROUND[ab]\n    /* 0x6F */ undefined,   // TODO NROUND[ab]\n    /* 0x70 */ WCVTF,\n    /* 0x71 */ DELTAP123.bind(undefined, 2),\n    /* 0x72 */ DELTAP123.bind(undefined, 3),\n    /* 0x73 */ DELTAC123.bind(undefined, 1),\n    /* 0x74 */ DELTAC123.bind(undefined, 2),\n    /* 0x75 */ DELTAC123.bind(undefined, 3),\n    /* 0x76 */ SROUND,\n    /* 0x77 */ S45ROUND,\n    /* 0x78 */ undefined,   // TODO JROT[]\n    /* 0x79 */ undefined,   // TODO JROF[]\n    /* 0x7A */ ROFF,\n    /* 0x7B */ undefined,\n    /* 0x7C */ RUTG,\n    /* 0x7D */ RDTG,\n    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n    /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n    /* 0x80 */ undefined,   // TODO FLIPPT\n    /* 0x81 */ undefined,   // TODO FLIPRGON\n    /* 0x82 */ undefined,   // TODO FLIPRGOFF\n    /* 0x83 */ undefined,\n    /* 0x84 */ undefined,\n    /* 0x85 */ SCANCTRL,\n    /* 0x86 */ SDPVTL.bind(undefined, 0),\n    /* 0x87 */ SDPVTL.bind(undefined, 1),\n    /* 0x88 */ GETINFO,\n    /* 0x89 */ undefined,   // TODO IDEF\n    /* 0x8A */ ROLL,\n    /* 0x8B */ MAX,\n    /* 0x8C */ MIN,\n    /* 0x8D */ SCANTYPE,\n    /* 0x8E */ INSTCTRL,\n    /* 0x8F */ undefined,\n    /* 0x90 */ undefined,\n    /* 0x91 */ undefined,\n    /* 0x92 */ undefined,\n    /* 0x93 */ undefined,\n    /* 0x94 */ undefined,\n    /* 0x95 */ undefined,\n    /* 0x96 */ undefined,\n    /* 0x97 */ undefined,\n    /* 0x98 */ undefined,\n    /* 0x99 */ undefined,\n    /* 0x9A */ undefined,\n    /* 0x9B */ undefined,\n    /* 0x9C */ undefined,\n    /* 0x9D */ undefined,\n    /* 0x9E */ undefined,\n    /* 0x9F */ undefined,\n    /* 0xA0 */ undefined,\n    /* 0xA1 */ undefined,\n    /* 0xA2 */ undefined,\n    /* 0xA3 */ undefined,\n    /* 0xA4 */ undefined,\n    /* 0xA5 */ undefined,\n    /* 0xA6 */ undefined,\n    /* 0xA7 */ undefined,\n    /* 0xA8 */ undefined,\n    /* 0xA9 */ undefined,\n    /* 0xAA */ undefined,\n    /* 0xAB */ undefined,\n    /* 0xAC */ undefined,\n    /* 0xAD */ undefined,\n    /* 0xAE */ undefined,\n    /* 0xAF */ undefined,\n    /* 0xB0 */ PUSHB.bind(undefined, 1),\n    /* 0xB1 */ PUSHB.bind(undefined, 2),\n    /* 0xB2 */ PUSHB.bind(undefined, 3),\n    /* 0xB3 */ PUSHB.bind(undefined, 4),\n    /* 0xB4 */ PUSHB.bind(undefined, 5),\n    /* 0xB5 */ PUSHB.bind(undefined, 6),\n    /* 0xB6 */ PUSHB.bind(undefined, 7),\n    /* 0xB7 */ PUSHB.bind(undefined, 8),\n    /* 0xB8 */ PUSHW.bind(undefined, 1),\n    /* 0xB9 */ PUSHW.bind(undefined, 2),\n    /* 0xBA */ PUSHW.bind(undefined, 3),\n    /* 0xBB */ PUSHW.bind(undefined, 4),\n    /* 0xBC */ PUSHW.bind(undefined, 5),\n    /* 0xBD */ PUSHW.bind(undefined, 6),\n    /* 0xBE */ PUSHW.bind(undefined, 7),\n    /* 0xBF */ PUSHW.bind(undefined, 8),\n    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n];\n\n/*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90Â°'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90Â° \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90Â°   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *---->*rp1\n         .     .                          (+12)\n         .     .                  rp2o *---------->* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------>*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *--->* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .\n    rp2o *-------->*rp2\n\n\n                               (+10)\n                          po *-------->* p\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .(+30)\n    rp2o *---------------------------->*rp2\n\n\n                                        (+25)\n                          po *----------------------->* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/\n\n/**\n * Converts a string into a list of tokens.\n */\n\n/**\n * Create a new token\n * @param {string} char a single char\n */\nfunction Token(char) {\n    this.char = char;\n    this.state = {};\n    this.activeState = null;\n}\n\n/**\n * Create a new context range\n * @param {number} startIndex range start index\n * @param {number} endOffset range end index offset\n * @param {string} contextName owner context name\n */\nfunction ContextRange(startIndex, endOffset, contextName) {\n    this.contextName = contextName;\n    this.startIndex = startIndex;\n    this.endOffset = endOffset;\n}\n\n/**\n * Check context start and end\n * @param {string} contextName a unique context name\n * @param {function} checkStart a predicate function the indicates a context's start\n * @param {function} checkEnd a predicate function the indicates a context's end\n */\nfunction ContextChecker(contextName, checkStart, checkEnd) {\n    this.contextName = contextName;\n    this.openRange = null;\n    this.ranges = [];\n    this.checkStart = checkStart;\n    this.checkEnd = checkEnd;\n}\n\n/**\n * @typedef ContextParams\n * @type Object\n * @property {array} context context items\n * @property {number} currentIndex current item index\n */\n\n/**\n * Create a context params\n * @param {array} context a list of items\n * @param {number} currentIndex current item index\n */\nfunction ContextParams(context, currentIndex) {\n    this.context = context;\n    this.index = currentIndex;\n    this.length = context.length;\n    this.current = context[currentIndex];\n    this.backtrack = context.slice(0, currentIndex);\n    this.lookahead = context.slice(currentIndex + 1);\n}\n\n/**\n * Create an event instance\n * @param {string} eventId event unique id\n */\nfunction Event(eventId) {\n    this.eventId = eventId;\n    this.subscribers = [];\n}\n\n/**\n * Initialize a core events and auto subscribe required event handlers\n * @param {any} events an object that enlists core events handlers\n */\nfunction initializeCoreEvents(events) {\n    var this$1 = this;\n\n    var coreEvents = [\n        'start', 'end', 'next', 'newToken', 'contextStart',\n        'contextEnd', 'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'\n    ];\n\n    coreEvents.forEach(function (eventId) {\n        Object.defineProperty(this$1.events, eventId, {\n            value: new Event(eventId)\n        });\n    });\n\n    if (!!events) {\n        coreEvents.forEach(function (eventId) {\n            var event = events[eventId];\n            if (typeof event === 'function') {\n                this$1.events[eventId].subscribe(event);\n            }\n        });\n    }\n    var requiresContextUpdate = [\n        'insertToken', 'removeToken', 'removeRange',\n        'replaceToken', 'replaceRange', 'composeRUD'\n    ];\n    requiresContextUpdate.forEach(function (eventId) {\n        this$1.events[eventId].subscribe(\n            this$1.updateContextsRanges\n        );\n    });\n}\n\n/**\n * Converts a string into a list of tokens\n * @param {any} events tokenizer core events\n */\nfunction Tokenizer(events) {\n    this.tokens = [];\n    this.registeredContexts = {};\n    this.contextCheckers = [];\n    this.events = {};\n    this.registeredModifiers = [];\n\n    initializeCoreEvents.call(this, events);\n}\n\n/**\n * Sets the state of a token, usually called by a state modifier.\n * @param {string} key state item key\n * @param {any} value state item value\n */\nToken.prototype.setState = function(key, value) {\n    this.state[key] = value;\n    this.activeState = { key: key, value: this.state[key] };\n    return this.activeState;\n};\n\nToken.prototype.getState = function (stateId) {\n    return this.state[stateId] || null;\n};\n\n/**\n * Checks if an index exists in the tokens list.\n * @param {number} index token index\n */\nTokenizer.prototype.inboundIndex = function(index) {\n    return index >= 0 && index < this.tokens.length;\n};\n\n/**\n * Compose and apply a list of operations (replace, update, delete)\n * @param {array} RUDs replace, update and delete operations\n * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)\n */\nTokenizer.prototype.composeRUD = function (RUDs) {\n    var this$1 = this;\n\n    var silent = true;\n    var state = RUDs.map(function (RUD) { return (\n        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))\n    ); });\n    var hasFAILObject = function (obj) { return (\n        typeof obj === 'object' &&\n        obj.hasOwnProperty('FAIL')\n    ); };\n    if (state.every(hasFAILObject)) {\n        return {\n            FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n            report: state.filter(hasFAILObject)\n        };\n    }\n    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);\n};\n\n/**\n * Replace a range of tokens with a list of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {token} tokens a list of tokens to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {\n    offset = offset !== null ? offset : this.tokens.length;\n    var isTokenType = tokens.every(function (token) { return token instanceof Token; });\n    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {\n        var replaced = this.tokens.splice.apply(\n            this.tokens, [startIndex, offset].concat(tokens)\n        );\n        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }\n        return [replaced, tokens];\n    } else {\n        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };\n    }\n};\n\n/**\n * Replace a token with another token\n * @param {number} index token index\n * @param {token} token a token to replace\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.replaceToken = function (index, token, silent) {\n    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {\n        var replaced = this.tokens.splice(index, 1, token);\n        if (!silent) { this.dispatch('replaceToken', [index, token]); }\n        return [replaced[0], token];\n    } else {\n        return { FAIL: 'replaceToken: invalid token or index.' };\n    }\n};\n\n/**\n * Removes a range of tokens\n * @param {number} startIndex range start index\n * @param {number} offset range offset\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeRange = function(startIndex, offset, silent) {\n    offset = !isNaN(offset) ? offset : this.tokens.length;\n    var tokens = this.tokens.splice(startIndex, offset);\n    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }\n    return tokens;\n};\n\n/**\n * Remove a token at a certain index\n * @param {number} index token index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.removeToken = function(index, silent) {\n    if (!isNaN(index) && this.inboundIndex(index)) {\n        var token = this.tokens.splice(index, 1);\n        if (!silent) { this.dispatch('removeToken', [token, index]); }\n        return token;\n    } else {\n        return { FAIL: 'removeToken: invalid token index.' };\n    }\n};\n\n/**\n * Insert a list of tokens at a certain index\n * @param {array} tokens a list of tokens to insert\n * @param {number} index insert the list of tokens at index\n * @param {boolean} silent dispatch events and update context ranges\n */\nTokenizer.prototype.insertToken = function (tokens, index, silent) {\n    var tokenType = tokens.every(\n        function (token) { return token instanceof Token; }\n    );\n    if (tokenType) {\n        this.tokens.splice.apply(\n            this.tokens, [index, 0].concat(tokens)\n        );\n        if (!silent) { this.dispatch('insertToken', [tokens, index]); }\n        return tokens;\n    } else {\n        return { FAIL: 'insertToken: invalid token(s).' };\n    }\n};\n\n/**\n * A state modifier that is called on 'newToken' event\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a function to update token state\n */\nTokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {\n    this.events.newToken.subscribe(function(token, contextParams) {\n        var conditionParams = [token, contextParams];\n        var canApplyModifier = (\n            condition === null ||\n            condition.apply(this, conditionParams) === true\n        );\n        var modifierParams = [token, contextParams];\n        if (canApplyModifier) {\n            var newStateValue = modifier.apply(this, modifierParams);\n            token.setState(modifierId, newStateValue);\n        }\n    });\n    this.registeredModifiers.push(modifierId);\n};\n\n/**\n * Subscribe a handler to an event\n * @param {function} eventHandler an event handler function\n */\nEvent.prototype.subscribe = function (eventHandler) {\n    if (typeof eventHandler === 'function') {\n        return ((this.subscribers.push(eventHandler)) - 1);\n    } else {\n        return { FAIL: (\"invalid '\" + (this.eventId) + \"' event handler\")};\n    }\n};\n\n/**\n * Unsubscribe an event handler\n * @param {string} subsId subscription id\n */\nEvent.prototype.unsubscribe = function (subsId) {\n    this.subscribers.splice(subsId, 1);\n};\n\n/**\n * Sets context params current value index\n * @param {number} index context params current value index\n */\nContextParams.prototype.setCurrentIndex = function(index) {\n    this.index = index;\n    this.current = this.context[index];\n    this.backtrack = this.context.slice(0, index);\n    this.lookahead = this.context.slice(index + 1);\n};\n\n/**\n * Get an item at an offset from the current value\n * example (current value is 3):\n *  1    2   [3]   4    5   |   items values\n * -2   -1    0    1    2   |   offset values\n * @param {number} offset an offset from current value index\n */\nContextParams.prototype.get = function (offset) {\n    switch (true) {\n        case (offset === 0):\n            return this.current;\n        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):\n            return this.backtrack.slice(offset)[0];\n        case (offset > 0 && offset <= this.lookahead.length):\n            return this.lookahead[offset - 1];\n        default:\n            return null;\n    }\n};\n\n/**\n * Converts a context range into a string value\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.rangeToText = function (range) {\n    if (range instanceof ContextRange) {\n        return (\n            this.getRangeTokens(range)\n                .map(function (token) { return token.char; }).join('')\n        );\n    }\n};\n\n/**\n * Converts all tokens into a string\n */\nTokenizer.prototype.getText = function () {\n    return this.tokens.map(function (token) { return token.char; }).join('');\n};\n\n/**\n * Get a context by name\n * @param {string} contextName context name to get\n */\nTokenizer.prototype.getContext = function (contextName) {\n    var context = this.registeredContexts[contextName];\n    return !!context ? context : null;\n};\n\n/**\n * Subscribes a new event handler to an event\n * @param {string} eventName event name to subscribe to\n * @param {function} eventHandler a function to be invoked on event\n */\nTokenizer.prototype.on = function(eventName, eventHandler) {\n    var event = this.events[eventName];\n    if (!!event) {\n        return event.subscribe(eventHandler);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Dispatches an event\n * @param {string} eventName event name\n * @param {any} args event handler arguments\n */\nTokenizer.prototype.dispatch = function(eventName, args) {\n    var this$1 = this;\n\n    var event = this.events[eventName];\n    if (event instanceof Event) {\n        event.subscribers.forEach(function (subscriber) {\n            subscriber.apply(this$1, args || []);\n        });\n    }\n};\n\n/**\n * Register a new context checker\n * @param {string} contextName a unique context name\n * @param {function} contextStartCheck a predicate function that returns true on context start\n * @param {function} contextEndCheck  a predicate function that returns true on context end\n * TODO: call tokenize on registration to update context ranges with the new context.\n */\nTokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {\n    if (!!this.getContext(contextName)) { return {\n        FAIL:\n        (\"context name '\" + contextName + \"' is already registered.\")\n    }; }\n    if (typeof contextStartCheck !== 'function') { return {\n        FAIL:\n        \"missing context start check.\"\n    }; }\n    if (typeof contextEndCheck !== 'function') { return {\n        FAIL:\n        \"missing context end check.\"\n    }; }\n    var contextCheckers = new ContextChecker(\n        contextName, contextStartCheck, contextEndCheck\n    );\n    this.registeredContexts[contextName] = contextCheckers;\n    this.contextCheckers.push(contextCheckers);\n    return contextCheckers;\n};\n\n/**\n * Gets a context range tokens\n * @param {contextRange} range a context range\n */\nTokenizer.prototype.getRangeTokens = function(range) {\n    var endIndex = range.startIndex + range.endOffset;\n    return [].concat(\n        this.tokens\n            .slice(range.startIndex, endIndex)\n    );\n};\n\n/**\n * Gets the ranges of a context\n * @param {string} contextName context name\n */\nTokenizer.prototype.getContextRanges = function(contextName) {\n    var context = this.getContext(contextName);\n    if (!!context) {\n        return context.ranges;\n    } else {\n        return { FAIL: (\"context checker '\" + contextName + \"' is not registered.\") };\n    }\n};\n\n/**\n * Resets context ranges to run context update\n */\nTokenizer.prototype.resetContextsRanges = function () {\n    var registeredContexts = this.registeredContexts;\n    for (var contextName in registeredContexts) {\n        if (registeredContexts.hasOwnProperty(contextName)) {\n            var context = registeredContexts[contextName];\n            context.ranges = [];\n        }\n    }\n};\n\n/**\n * Updates context ranges\n */\nTokenizer.prototype.updateContextsRanges = function () {\n    this.resetContextsRanges();\n    var chars = this.tokens.map(function (token) { return token.char; });\n    for (var i = 0; i < chars.length; i++) {\n        var contextParams = new ContextParams(chars, i);\n        this.runContextCheck(contextParams);\n    }\n    this.dispatch('updateContextsRanges', [this.registeredContexts]);\n};\n\n/**\n * Sets the end offset of an open range\n * @param {number} offset range end offset\n * @param {string} contextName context name\n */\nTokenizer.prototype.setEndOffset = function (offset, contextName) {\n    var startIndex = this.getContext(contextName).openRange.startIndex;\n    var range = new ContextRange(startIndex, offset, contextName);\n    var ranges = this.getContext(contextName).ranges;\n    range.rangeId = contextName + \".\" + (ranges.length);\n    ranges.push(range);\n    this.getContext(contextName).openRange = null;\n    return range;\n};\n\n/**\n * Runs a context check on the current context\n * @param {contextParams} contextParams current context params\n */\nTokenizer.prototype.runContextCheck = function(contextParams) {\n    var this$1 = this;\n\n    var index = contextParams.index;\n    this.contextCheckers.forEach(function (contextChecker) {\n        var contextName = contextChecker.contextName;\n        var openRange = this$1.getContext(contextName).openRange;\n        if (!openRange && contextChecker.checkStart(contextParams)) {\n            openRange = new ContextRange(index, null, contextName);\n            this$1.getContext(contextName).openRange = openRange;\n            this$1.dispatch('contextStart', [contextName, index]);\n        }\n        if (!!openRange && contextChecker.checkEnd(contextParams)) {\n            var offset = (index - openRange.startIndex) + 1;\n            var range = this$1.setEndOffset(offset, contextName);\n            this$1.dispatch('contextEnd', [contextName, range]);\n        }\n    });\n};\n\n/**\n * Converts a text into a list of tokens\n * @param {string} text a text to tokenize\n */\nTokenizer.prototype.tokenize = function (text) {\n    this.tokens = [];\n    this.resetContextsRanges();\n    var chars = Array.from(text);\n    this.dispatch('start');\n    for (var i = 0; i < chars.length; i++) {\n        var char = chars[i];\n        var contextParams = new ContextParams(chars, i);\n        this.dispatch('next', [contextParams]);\n        this.runContextCheck(contextParams);\n        var token = new Token(char);\n        this.tokens.push(token);\n        this.dispatch('newToken', [token, contextParams]);\n    }\n    this.dispatch('end', [this.tokens]);\n    return this.tokens;\n};\n\n// â­âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ®\n// â Character Class Assertions â Checks if a char belongs to a certain class â\n// â°ââ¾âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¯\n// jscs:disable maximumLineLength\n/**\n * Check if a char is Arabic\n * @param {string} c a single char\n */\nfunction isArabicChar(c) {\n    return /[\\u0600-\\u065F\\u066A-\\u06D2\\u06FA-\\u06FF]/.test(c);\n}\n\n/**\n * Check if a char is an isolated arabic char\n * @param {string} c a single char\n */\nfunction isIsolatedArabicChar(char) {\n    return /[\\u0630\\u0690\\u0621\\u0631\\u0661\\u0671\\u0622\\u0632\\u0672\\u0692\\u06C2\\u0623\\u0673\\u0693\\u06C3\\u0624\\u0694\\u06C4\\u0625\\u0675\\u0695\\u06C5\\u06E5\\u0676\\u0696\\u06C6\\u0627\\u0677\\u0697\\u06C7\\u0648\\u0688\\u0698\\u06C8\\u0689\\u0699\\u06C9\\u068A\\u06CA\\u066B\\u068B\\u06CB\\u068C\\u068D\\u06CD\\u06FD\\u068E\\u06EE\\u06FE\\u062F\\u068F\\u06CF\\u06EF]/.test(char);\n}\n\n/**\n * Check if a char is an Arabic Tashkeel char\n * @param {string} c a single char\n */\nfunction isTashkeelArabicChar(char) {\n    return /[\\u0600-\\u0605\\u060C-\\u060E\\u0610-\\u061B\\u061E\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED]/.test(char);\n}\n\n/**\n * Check if a char is Latin\n * @param {string} c a single char\n */\nfunction isLatinChar(c) {\n    return /[A-z]/.test(c);\n}\n\n/**\n * Check if a char is whitespace char\n * @param {string} c a single char\n */\nfunction isWhiteSpace(c) {\n    return /\\s/.test(c);\n}\n\n/**\n * Query a feature by some of it's properties to lookup a glyph substitution.\n */\n\n/**\n * Create feature query instance\n * @param {Font} font opentype font instance\n */\nfunction FeatureQuery(font) {\n    this.font = font;\n    this.features = {};\n}\n\n/**\n * @typedef SubstitutionAction\n * @type Object\n * @property {number} id substitution type\n * @property {string} tag feature tag\n * @property {any} substitution substitution value(s)\n */\n\n/**\n * Create a substitution action instance\n * @param {SubstitutionAction} action\n */\nfunction SubstitutionAction(action) {\n    this.id = action.id;\n    this.tag = action.tag;\n    this.substitution = action.substitution;\n}\n\n/**\n * Lookup a coverage table\n * @param {number} glyphIndex glyph index\n * @param {CoverageTable} coverage coverage table\n */\nfunction lookupCoverage(glyphIndex, coverage) {\n    if (!glyphIndex) { return -1; }\n    switch (coverage.format) {\n        case 1:\n            return coverage.glyphs.indexOf(glyphIndex);\n\n        case 2:\n            var ranges = coverage.ranges;\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                if (glyphIndex >= range.start && glyphIndex <= range.end) {\n                    var offset = glyphIndex - range.start;\n                    return range.index + offset;\n                }\n            }\n            break;\n        default:\n            return -1; // not found\n    }\n    return -1;\n}\n\n/**\n * Handle a single substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return glyphIndex + subtable.deltaGlyphId;\n}\n\n/**\n * Handle a single substitution - format 2\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction singleSubstitutionFormat2(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.substitute[substituteIndex];\n}\n\n/**\n * Lookup a list of coverage tables\n * @param {any} coverageList a list of coverage tables\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction lookupCoverageList(coverageList, contextParams) {\n    var lookupList = [];\n    for (var i = 0; i < coverageList.length; i++) {\n        var coverage = coverageList[i];\n        var glyphIndex = contextParams.current;\n        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;\n        var lookupIndex = lookupCoverage(glyphIndex, coverage);\n        if (lookupIndex !== -1) {\n            lookupList.push(lookupIndex);\n        }\n    }\n    if (lookupList.length !== coverageList.length) { return -1; }\n    return lookupList;\n}\n\n/**\n * Handle chaining context substitution - format 3\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction chainingSubstitutionFormat3(contextParams, subtable) {\n    var lookupsCount = (\n        subtable.inputCoverage.length +\n        subtable.lookaheadCoverage.length +\n        subtable.backtrackCoverage.length\n    );\n    if (contextParams.context.length < lookupsCount) { return []; }\n    // INPUT LOOKUP //\n    var inputLookups = lookupCoverageList(\n        subtable.inputCoverage, contextParams\n    );\n    if (inputLookups === -1) { return []; }\n    // LOOKAHEAD LOOKUP //\n    var lookaheadOffset = subtable.inputCoverage.length - 1;\n    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }\n    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);\n    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {\n        lookaheadContext.shift();\n    }\n    var lookaheadParams = new ContextParams(lookaheadContext, 0);\n    var lookaheadLookups = lookupCoverageList(\n        subtable.lookaheadCoverage, lookaheadParams\n    );\n    // BACKTRACK LOOKUP //\n    var backtrackContext = [].concat(contextParams.backtrack);\n    backtrackContext.reverse();\n    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {\n        backtrackContext.shift();\n    }\n    if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }\n    var backtrackParams = new ContextParams(backtrackContext, 0);\n    var backtrackLookups = lookupCoverageList(\n        subtable.backtrackCoverage, backtrackParams\n    );\n    var contextRulesMatch = (\n        inputLookups.length === subtable.inputCoverage.length &&\n        lookaheadLookups.length === subtable.lookaheadCoverage.length &&\n        backtrackLookups.length === subtable.backtrackCoverage.length\n    );\n    var substitutions = [];\n    if (contextRulesMatch) {\n        for (var i = 0; i < subtable.lookupRecords.length; i++) {\n            var lookupRecord = subtable.lookupRecords[i];\n            var lookupListIndex = lookupRecord.lookupListIndex;\n            var lookupTable = this.getLookupByIndex(lookupListIndex);\n            for (var s = 0; s < lookupTable.subtables.length; s++) {\n                var subtable$1 = lookupTable.subtables[s];\n                var lookup = this.getLookupMethod(lookupTable, subtable$1);\n                var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);\n                if (substitutionType === '12') {\n                    for (var n = 0; n < inputLookups.length; n++) {\n                        var glyphIndex = contextParams.get(n);\n                        var substitution = lookup(glyphIndex);\n                        if (substitution) { substitutions.push(substitution); }\n                    }\n                }\n            }\n        }\n    }\n    return substitutions;\n}\n\n/**\n * Handle ligature substitution - format 1\n * @param {ContextParams} contextParams context params to lookup\n */\nfunction ligatureSubstitutionFormat1(contextParams, subtable) {\n    // COVERAGE LOOKUP //\n    var glyphIndex = contextParams.current;\n    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (ligSetIndex === -1) { return null; }\n    // COMPONENTS LOOKUP\n    // (!) note, components are ordered in the written direction.\n    var ligature;\n    var ligatureSet = subtable.ligatureSets[ligSetIndex];\n    for (var s = 0; s < ligatureSet.length; s++) {\n        ligature = ligatureSet[s];\n        for (var l = 0; l < ligature.components.length; l++) {\n            var lookaheadItem = contextParams.lookahead[l];\n            var component = ligature.components[l];\n            if (lookaheadItem !== component) { break; }\n            if (l === ligature.components.length - 1) { return ligature; }\n        }\n    }\n    return null;\n}\n\n/**\n * Handle decomposition substitution - format 1\n * @param {number} glyphIndex glyph index\n * @param {any} subtable subtable\n */\nfunction decompositionSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n    if (substituteIndex === -1) { return null; }\n    return subtable.sequences[substituteIndex];\n}\n\n/**\n * Get default script features indexes\n */\nFeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {\n    var scripts = this.font.tables.gsub.scripts;\n    for (var s = 0; s < scripts.length; s++) {\n        var script = scripts[s];\n        if (script.tag === 'DFLT') { return (\n            script.script.defaultLangSys.featureIndexes\n        ); }\n    }\n    return [];\n};\n\n/**\n * Get feature indexes of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {\n    var tables = this.font.tables;\n    if (!tables.gsub) { return []; }\n    if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }\n    var scripts = this.font.tables.gsub.scripts;\n    for (var i = 0; i < scripts.length; i++) {\n        var script = scripts[i];\n        if (script.tag === scriptTag && script.script.defaultLangSys) {\n            return script.script.defaultLangSys.featureIndexes;\n        } else {\n            var langSysRecords = script.langSysRecords;\n            if (!!langSysRecords) {\n                for (var j = 0; j < langSysRecords.length; j++) {\n                    var langSysRecord = langSysRecords[j];\n                    if (langSysRecord.tag === scriptTag) {\n                        var langSys = langSysRecord.langSys;\n                        return langSys.featureIndexes;\n                    }\n                }\n            }\n        }\n    }\n    return this.getDefaultScriptFeaturesIndexes();\n};\n\n/**\n * Map a feature tag to a gsub feature\n * @param {any} features gsub features\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {\n    var tags = {};\n    for (var i = 0; i < features.length; i++) {\n        var tag = features[i].tag;\n        var feature = features[i].feature;\n        tags[tag] = feature;\n    }\n    this.features[scriptTag].tags = tags;\n};\n\n/**\n * Get features of a specific script\n * @param {string} scriptTag script tag\n */\nFeatureQuery.prototype.getScriptFeatures = function (scriptTag) {\n    var features = this.features[scriptTag];\n    if (this.features.hasOwnProperty(scriptTag)) { return features; }\n    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);\n    if (!featuresIndexes) { return null; }\n    var gsub = this.font.tables.gsub;\n    features = featuresIndexes.map(function (index) { return gsub.features[index]; });\n    this.features[scriptTag] = features;\n    this.mapTagsToFeatures(features, scriptTag);\n    return features;\n};\n\n/**\n * Get substitution type\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {\n    var lookupType = lookupTable.lookupType.toString();\n    var substFormat = subtable.substFormat.toString();\n    return lookupType + substFormat;\n};\n\n/**\n * Get lookup method\n * @param {any} lookupTable lookup table\n * @param {any} subtable subtable\n */\nFeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {\n    var this$1 = this;\n\n    var substitutionType = this.getSubstitutionType(lookupTable, subtable);\n    switch (substitutionType) {\n        case '11':\n            return function (glyphIndex) { return singleSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '12':\n            return function (glyphIndex) { return singleSubstitutionFormat2.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        case '63':\n            return function (contextParams) { return chainingSubstitutionFormat3.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '41':\n            return function (contextParams) { return ligatureSubstitutionFormat1.apply(\n                this$1, [contextParams, subtable]\n            ); };\n        case '21':\n            return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(\n                this$1, [glyphIndex, subtable]\n            ); };\n        default:\n            throw new Error(\n                \"lookupType: \" + (lookupTable.lookupType) + \" - \" +\n                \"substFormat: \" + (subtable.substFormat) + \" \" +\n                \"is not yet supported\"\n            );\n    }\n};\n\n/**\n * [ LOOKUP TYPES ]\n * -------------------------------\n * Single                        1;\n * Multiple                      2;\n * Alternate                     3;\n * Ligature                      4;\n * Context                       5;\n * ChainingContext               6;\n * ExtensionSubstitution         7;\n * ReverseChainingContext        8;\n * -------------------------------\n *\n */\n\n/**\n * @typedef FQuery\n * @type Object\n * @param {string} tag feature tag\n * @param {string} script feature script\n * @param {ContextParams} contextParams context params\n */\n\n/**\n * Lookup a feature using a query parameters\n * @param {FQuery} query feature query\n */\nFeatureQuery.prototype.lookupFeature = function (query) {\n    var contextParams = query.contextParams;\n    var currentIndex = contextParams.index;\n    var feature = this.getFeature({\n        tag: query.tag, script: query.script\n    });\n    if (!feature) { return new Error(\n        \"font '\" + (this.font.names.fullName.en) + \"' \" +\n        \"doesn't support feature '\" + (query.tag) + \"' \" +\n        \"for script '\" + (query.script) + \"'.\"\n    ); }\n    var lookups = this.getFeatureLookups(feature);\n    var substitutions = [].concat(contextParams.context);\n    for (var l = 0; l < lookups.length; l++) {\n        var lookupTable = lookups[l];\n        var subtables = this.getLookupSubtables(lookupTable);\n        for (var s = 0; s < subtables.length; s++) {\n            var subtable = subtables[s];\n            var substType = this.getSubstitutionType(lookupTable, subtable);\n            var lookup = this.getLookupMethod(lookupTable, subtable);\n            var substitution = (void 0);\n            switch (substType) {\n                case '11':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 11, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '12':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 12, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '63':\n                    substitution = lookup(contextParams);\n                    if (Array.isArray(substitution) && substitution.length) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 63, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '41':\n                    substitution = lookup(contextParams);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 41, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n                case '21':\n                    substitution = lookup(contextParams.current);\n                    if (substitution) {\n                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n                            id: 21, tag: query.tag, substitution: substitution\n                        }));\n                    }\n                    break;\n            }\n            contextParams = new ContextParams(substitutions, currentIndex);\n            if (Array.isArray(substitution) && !substitution.length) { continue; }\n            substitution = null;\n        }\n    }\n    return substitutions.length ? substitutions : null;\n};\n\n/**\n * Checks if a font supports a specific features\n * @param {FQuery} query feature query object\n */\nFeatureQuery.prototype.supports = function (query) {\n    if (!query.script) { return false; }\n    this.getScriptFeatures(query.script);\n    var supportedScript = this.features.hasOwnProperty(query.script);\n    if (!query.tag) { return supportedScript; }\n    var supportedFeature = (\n        this.features[query.script].some(function (feature) { return feature.tag === query.tag; })\n    );\n    return supportedScript && supportedFeature;\n};\n\n/**\n * Get lookup table subtables\n * @param {any} lookupTable lookup table\n */\nFeatureQuery.prototype.getLookupSubtables = function (lookupTable) {\n    return lookupTable.subtables || null;\n};\n\n/**\n * Get lookup table by index\n * @param {number} index lookup table index\n */\nFeatureQuery.prototype.getLookupByIndex = function (index) {\n    var lookups = this.font.tables.gsub.lookups;\n    return lookups[index] || null;\n};\n\n/**\n * Get lookup tables for a feature\n * @param {string} feature\n */\nFeatureQuery.prototype.getFeatureLookups = function (feature) {\n    // TODO: memoize\n    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));\n};\n\n/**\n * Query a feature by it's properties\n * @param {any} query an object that describes the properties of a query\n */\nFeatureQuery.prototype.getFeature = function getFeature(query) {\n    if (!this.font) { return { FAIL: \"No font was found\"}; }\n    if (!this.features.hasOwnProperty(query.script)) {\n        this.getScriptFeatures(query.script);\n    }\n    var scriptFeatures = this.features[query.script];\n    if (!scriptFeatures) { return (\n        { FAIL: (\"No feature for script \" + (query.script))}\n    ); }\n    if (!scriptFeatures.tags[query.tag]) { return null; }\n    return this.features[query.script].tags[query.tag];\n};\n\n/**\n * Arabic word context checkers\n */\n\nfunction arabicWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? arabic first char\n        (prevChar === null && isArabicChar(char)) ||\n        // ? arabic char preceded with a non arabic char\n        (!isArabicChar(prevChar) && isArabicChar(char))\n    );\n}\n\nfunction arabicWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last arabic char\n        (nextChar === null) ||\n        // ? next char is not arabic\n        (!isArabicChar(nextChar))\n    );\n}\n\nvar arabicWordCheck = {\n    startCheck: arabicWordStartCheck,\n    endCheck: arabicWordEndCheck\n};\n\n/**\n * Arabic sentence context checkers\n */\n\nfunction arabicSentenceStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? an arabic char preceded with a non arabic char\n        (isArabicChar(char) || isTashkeelArabicChar(char)) &&\n        !isArabicChar(prevChar)\n    );\n}\n\nfunction arabicSentenceEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    switch (true) {\n        case nextChar === null:\n            return true;\n        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):\n            var nextIsWhitespace = isWhiteSpace(nextChar);\n            if (!nextIsWhitespace) { return true; }\n            if (nextIsWhitespace) {\n                var arabicCharAhead = false;\n                arabicCharAhead = (\n                    contextParams.lookahead.some(\n                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }\n                    )\n                );\n                if (!arabicCharAhead) { return true; }\n            }\n            break;\n        default:\n            return false;\n    }\n}\n\nvar arabicSentenceCheck = {\n    startCheck: arabicSentenceStartCheck,\n    endCheck: arabicSentenceEndCheck\n};\n\n/**\n * Apply single substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat1$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply single substitution format 2\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction singleSubstitutionFormat2$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution);\n}\n\n/**\n * Apply chaining context substitution format 3\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction chainingSubstitutionFormat3$1(action, tokens, index) {\n    action.substitution.forEach(function (subst, offset) {\n        var token = tokens[index + offset];\n        token.setState(action.tag, subst);\n    });\n}\n\n/**\n * Apply ligature substitution format 1\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction ligatureSubstitutionFormat1$1(action, tokens, index) {\n    var token = tokens[index];\n    token.setState(action.tag, action.substitution.ligGlyph);\n    var compsCount = action.substitution.components.length;\n    for (var i = 0; i < compsCount; i++) {\n        token = tokens[index + i + 1];\n        token.setState('deleted', true);\n    }\n}\n\n/**\n * Supported substitutions\n */\nvar SUBSTITUTIONS = {\n    11: singleSubstitutionFormat1$1,\n    12: singleSubstitutionFormat2$1,\n    63: chainingSubstitutionFormat3$1,\n    41: ligatureSubstitutionFormat1$1\n};\n\n/**\n * Apply substitutions to a list of tokens\n * @param {Array} substitutions substitutions\n * @param {any} tokens a list of tokens\n * @param {number} index token index\n */\nfunction applySubstitution(action, tokens, index) {\n    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {\n        SUBSTITUTIONS[action.id](action, tokens, index);\n    }\n}\n\n/**\n * Apply Arabic presentation forms to a range of tokens\n */\n\n/**\n * Check if a char can be connected to it's preceding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectPrev(charContextParams) {\n    var backtrack = [].concat(charContextParams.backtrack);\n    for (var i = backtrack.length - 1; i >= 0; i--) {\n        var prevChar = backtrack[i];\n        var isolated = isIsolatedArabicChar(prevChar);\n        var tashkeel = isTashkeelArabicChar(prevChar);\n        if (!isolated && !tashkeel) { return true; }\n        if (isolated) { return false; }\n    }\n    return false;\n}\n\n/**\n * Check if a char can be connected to it's proceeding char\n * @param {ContextParams} charContextParams context params of a char\n */\nfunction willConnectNext(charContextParams) {\n    if (isIsolatedArabicChar(charContextParams.current)) { return false; }\n    for (var i = 0; i < charContextParams.lookahead.length; i++) {\n        var nextChar = charContextParams.lookahead[i];\n        var tashkeel = isTashkeelArabicChar(nextChar);\n        if (!tashkeel) { return true; }\n    }\n    return false;\n}\n\n/**\n * Apply arabic presentation forms to a list of tokens\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicPresentationForms(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tags = this.featuresTags[script];\n    var tokens = this.tokenizer.getRangeTokens(range);\n    if (tokens.length === 1) { return; }\n    var contextParams = new ContextParams(\n        tokens.map(function (token) { return token.getState('glyphIndex'); }\n    ), 0);\n    var charContextParams = new ContextParams(\n        tokens.map(function (token) { return token.char; }\n    ), 0);\n    tokens.forEach(function (token, index) {\n        if (isTashkeelArabicChar(token.char)) { return; }\n        contextParams.setCurrentIndex(index);\n        charContextParams.setCurrentIndex(index);\n        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)\n        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }\n        if (willConnectNext(charContextParams)) { CONNECT |= 2; }\n        var tag;\n        switch (CONNECT) {\n            case 1: (tag = 'fina'); break;\n            case 2: (tag = 'init'); break;\n            case 3: (tag = 'medi'); break;\n        }\n        if (tags.indexOf(tag) === -1) { return; }\n        var substitutions = this$1.query.lookupFeature({\n            tag: tag, script: script, contextParams: contextParams\n        });\n        if (substitutions instanceof Error) { return console.info(substitutions.message); }\n        substitutions.forEach(function (action, index) {\n            if (action instanceof SubstitutionAction) {\n                applySubstitution(action, tokens, index);\n                contextParams.context[index] = action.substitution;\n            }\n        });\n    });\n}\n\n/**\n * Apply Arabic required ligatures feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction arabicRequiredLigatures(range) {\n    var this$1 = this;\n\n    var script = 'arab';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'rlig', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams(tokens);\n        }\n    });\n}\n\n/**\n * Latin word context checkers\n */\n\nfunction latinWordStartCheck(contextParams) {\n    var char = contextParams.current;\n    var prevChar = contextParams.get(-1);\n    return (\n        // ? latin first char\n        (prevChar === null && isLatinChar(char)) ||\n        // ? latin char preceded with a non latin char\n        (!isLatinChar(prevChar) && isLatinChar(char))\n    );\n}\n\nfunction latinWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1);\n    return (\n        // ? last latin char\n        (nextChar === null) ||\n        // ? next char is not latin\n        (!isLatinChar(nextChar))\n    );\n}\n\nvar latinWordCheck = {\n    startCheck: latinWordStartCheck,\n    endCheck: latinWordEndCheck\n};\n\n/**\n * Apply Latin ligature feature to a range of tokens\n */\n\n/**\n * Update context params\n * @param {any} tokens a list of tokens\n * @param {number} index current item index\n */\nfunction getContextParams$1(tokens, index) {\n    var context = tokens.map(function (token) { return token.activeState.value; });\n    return new ContextParams(context, index || 0);\n}\n\n/**\n * Apply Arabic required ligatures to a context range\n * @param {ContextRange} range a range of tokens\n */\nfunction latinLigature(range) {\n    var this$1 = this;\n\n    var script = 'latn';\n    var tokens = this.tokenizer.getRangeTokens(range);\n    var contextParams = getContextParams$1(tokens);\n    contextParams.context.forEach(function (glyphIndex, index) {\n        contextParams.setCurrentIndex(index);\n        var substitutions = this$1.query.lookupFeature({\n            tag: 'liga', script: script, contextParams: contextParams\n        });\n        if (substitutions.length) {\n            substitutions.forEach(\n                function (action) { return applySubstitution(action, tokens, index); }\n            );\n            contextParams = getContextParams$1(tokens);\n        }\n    });\n}\n\n/**\n * Infer bidirectional properties for a given text and apply\n * the corresponding layout rules.\n */\n\n/**\n * Create Bidi. features\n * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'\n */\nfunction Bidi(baseDir) {\n    this.baseDir = baseDir || 'ltr';\n    this.tokenizer = new Tokenizer();\n    this.featuresTags = {};\n}\n\n/**\n * Sets Bidi text\n * @param {string} text a text input\n */\nBidi.prototype.setText = function (text) {\n    this.text = text;\n};\n\n/**\n * Store essential context checks:\n * arabic word check for applying gsub features\n * arabic sentence check for adjusting arabic layout\n */\nBidi.prototype.contextChecks = ({\n    latinWordCheck: latinWordCheck,\n    arabicWordCheck: arabicWordCheck,\n    arabicSentenceCheck: arabicSentenceCheck\n});\n\n/**\n * Register arabic word check\n */\nfunction registerContextChecker(checkId) {\n    var check = this.contextChecks[(checkId + \"Check\")];\n    return this.tokenizer.registerContextChecker(\n        checkId, check.startCheck, check.endCheck\n    );\n}\n\n/**\n * Perform pre tokenization procedure then\n * tokenize text input\n */\nfunction tokenizeText() {\n    registerContextChecker.call(this, 'latinWord');\n    registerContextChecker.call(this, 'arabicWord');\n    registerContextChecker.call(this, 'arabicSentence');\n    return this.tokenizer.tokenize(this.text);\n}\n\n/**\n * Reverse arabic sentence layout\n * TODO: check base dir before applying adjustments - priority low\n */\nfunction reverseArabicSentences() {\n    var this$1 = this;\n\n    var ranges = this.tokenizer.getContextRanges('arabicSentence');\n    ranges.forEach(function (range) {\n        var rangeTokens = this$1.tokenizer.getRangeTokens(range);\n        this$1.tokenizer.replaceRange(\n            range.startIndex,\n            range.endOffset,\n            rangeTokens.reverse()\n        );\n    });\n}\n\n/**\n * Register supported features tags\n * @param {script} script script tag\n * @param {Array} tags features tags list\n */\nBidi.prototype.registerFeatures = function (script, tags) {\n    var this$1 = this;\n\n    var supportedTags = tags.filter(\n        function (tag) { return this$1.query.supports({script: script, tag: tag}); }\n    );\n    if (!this.featuresTags.hasOwnProperty(script)) {\n        this.featuresTags[script] = supportedTags;\n    } else {\n        this.featuresTags[script] =\n        this.featuresTags[script].concat(supportedTags);\n    }\n};\n\n/**\n * Apply GSUB features\n * @param {Array} tagsList a list of features tags\n * @param {string} script a script tag\n * @param {Font} font opentype font instance\n */\nBidi.prototype.applyFeatures = function (font, features) {\n    if (!font) { throw new Error(\n        'No valid font was provided to apply features'\n    ); }\n    if (!this.query) { this.query = new FeatureQuery(font); }\n    for (var f = 0; f < features.length; f++) {\n        var feature = features[f];\n        if (!this.query.supports({script: feature.script})) { continue; }\n        this.registerFeatures(feature.script, feature.tags);\n    }\n};\n\n/**\n * Register a state modifier\n * @param {string} modifierId state modifier id\n * @param {function} condition a predicate function that returns true or false\n * @param {function} modifier a modifier function to set token state\n */\nBidi.prototype.registerModifier = function (modifierId, condition, modifier) {\n    this.tokenizer.registerModifier(modifierId, condition, modifier);\n};\n\n/**\n * Check if 'glyphIndex' is registered\n */\nfunction checkGlyphIndexStatus() {\n    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {\n        throw new Error(\n            'glyphIndex modifier is required to apply ' +\n            'arabic presentation features.'\n        );\n    }\n}\n\n/**\n * Apply arabic presentation forms features\n */\nfunction applyArabicPresentationForms() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicPresentationForms.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyArabicRequireLigatures() {\n    var this$1 = this;\n\n    var script = 'arab';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('rlig') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('arabicWord');\n    ranges.forEach(function (range) {\n        arabicRequiredLigatures.call(this$1, range);\n    });\n}\n\n/**\n * Apply required arabic ligatures\n */\nfunction applyLatinLigatures() {\n    var this$1 = this;\n\n    var script = 'latn';\n    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n    var tags = this.featuresTags[script];\n    if (tags.indexOf('liga') === -1) { return; }\n    checkGlyphIndexStatus.call(this);\n    var ranges = this.tokenizer.getContextRanges('latinWord');\n    ranges.forEach(function (range) {\n        latinLigature.call(this$1, range);\n    });\n}\n\n/**\n * Check if a context is registered\n * @param {string} contextId context id\n */\nBidi.prototype.checkContextReady = function (contextId) {\n    return !!this.tokenizer.getContext(contextId);\n};\n\n/**\n * Apply features to registered contexts\n */\nBidi.prototype.applyFeaturesToContexts = function () {\n    if (this.checkContextReady('arabicWord')) {\n        applyArabicPresentationForms.call(this);\n        applyArabicRequireLigatures.call(this);\n    }\n    if (this.checkContextReady('latinWord')) {\n        applyLatinLigatures.call(this);\n    }\n    if (this.checkContextReady('arabicSentence')) {\n        reverseArabicSentences.call(this);\n    }\n};\n\n/**\n * process text input\n * @param {string} text an input text\n */\nBidi.prototype.processText = function(text) {\n    if (!this.text || this.text !== text) {\n        this.setText(text);\n        tokenizeText.call(this);\n        this.applyFeaturesToContexts();\n    }\n};\n\n/**\n * Process a string of text to identify and adjust\n * bidirectional text entities.\n * @param {string} text input text\n */\nBidi.prototype.getBidiText = function (text) {\n    this.processText(text);\n    return this.tokenizer.getText();\n};\n\n/**\n * Get the current state index of each token\n * @param {text} text an input text\n */\nBidi.prototype.getTextGlyphs = function (text) {\n    this.processText(text);\n    var indexes = [];\n    for (var i = 0; i < this.tokenizer.tokens.length; i++) {\n        var token = this.tokenizer.tokens[i];\n        if (token.state.deleted) { continue; }\n        var index = token.activeState.value;\n        indexes.push(Array.isArray(index) ? index[0] : index);\n    }\n    return indexes;\n};\n\n// The Font object\n\n/**\n * @typedef FontOptions\n * @type Object\n * @property {Boolean} empty - whether to create a new empty font\n * @property {string} familyName\n * @property {string} styleName\n * @property {string=} fullName\n * @property {string=} postScriptName\n * @property {string=} designer\n * @property {string=} designerURL\n * @property {string=} manufacturer\n * @property {string=} manufacturerURL\n * @property {string=} license\n * @property {string=} licenseURL\n * @property {string=} version\n * @property {string=} description\n * @property {string=} copyright\n * @property {string=} trademark\n * @property {Number} unitsPerEm\n * @property {Number} ascender\n * @property {Number} descender\n * @property {Number} createdTimestamp\n * @property {string=} weightClass\n * @property {string=} widthClass\n * @property {string=} fsSelection\n */\n\n/**\n * A Font represents a loaded OpenType font file.\n * It contains a set of glyphs and methods to draw text on a drawing context,\n * or to get a path representing the text.\n * @exports opentype.Font\n * @class\n * @param {FontOptions}\n * @constructor\n */\nfunction Font(options) {\n    options = options || {};\n    options.tables = options.tables || {};\n\n    if (!options.empty) {\n        // Check that we've provided the minimum set of names.\n        checkArgument(\n            options.familyName,\n            'When creating a new Font object, familyName is required.'\n        );\n        checkArgument(\n            options.styleName,\n            'When creating a new Font object, styleName is required.'\n        );\n        checkArgument(\n            options.unitsPerEm,\n            'When creating a new Font object, unitsPerEm is required.'\n        );\n        checkArgument(\n            options.ascender,\n            'When creating a new Font object, ascender is required.'\n        );\n        checkArgument(\n            options.descender <= 0,\n            'When creating a new Font object, negative descender value is required.'\n        );\n\n        this.unitsPerEm = options.unitsPerEm || 1000;\n        this.ascender = options.ascender;\n        this.descender = options.descender;\n        this.createdTimestamp = options.createdTimestamp;\n        this.tables = Object.assign(options.tables, {\n            os2: Object.assign(\n                {\n                    usWeightClass:\n                        options.weightClass || this.usWeightClasses.MEDIUM,\n                    usWidthClass:\n                        options.widthClass || this.usWidthClasses.MEDIUM,\n                    fsSelection:\n                        options.fsSelection || this.fsSelectionValues.REGULAR,\n                },\n                options.tables.os2\n            ),\n        });\n    }\n\n    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n    this.encoding = new DefaultEncoding(this);\n    this.position = new Position(this);\n    this.substitution = new Substitution(this);\n    this.tables = this.tables || {};\n\n    // needed for low memory mode only.\n    this._push = null;\n    this._hmtxTableData = {};\n\n    Object.defineProperty(this, 'hinting', {\n        get: function () {\n            if (this._hinting) { return this._hinting; }\n            if (this.outlinesFormat === 'truetype') {\n                return (this._hinting = new Hinting(this));\n            }\n        },\n    });\n}\n\n/**\n * Check if the font has a glyph for the given character.\n * @param  {string}\n * @return {Boolean}\n */\nFont.prototype.hasChar = function (c) {\n    return this.encoding.charToGlyphIndex(c) !== null;\n};\n\n/**\n * Convert the given character to a single glyph index.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.charToGlyphIndex = function (s) {\n    return this.encoding.charToGlyphIndex(s);\n};\n\n/**\n * Convert the given character to a single Glyph object.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.charToGlyph = function (c) {\n    var glyphIndex = this.charToGlyphIndex(c);\n    var glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * Update features\n * @param {any} options features options\n */\nFont.prototype.updateFeatures = function (options) {\n    // TODO: update all features options not only 'latn'.\n    return this.defaultRenderOptions.features.map(function (feature) {\n        if (feature.script === 'latn') {\n            return {\n                script: 'latn',\n                tags: feature.tags.filter(function (tag) { return options[tag]; }),\n            };\n        } else {\n            return feature;\n        }\n    });\n};\n\n/**\n * Convert the given text to a list of Glyph objects.\n * Note that there is no strict one-to-one mapping between characters and\n * glyphs, so the list of returned glyphs can be larger or smaller than the\n * length of the given string.\n * @param  {string}\n * @param  {GlyphRenderOptions} [options]\n * @return {opentype.Glyph[]}\n */\nFont.prototype.stringToGlyphs = function (s, options) {\n    var this$1 = this;\n\n    var bidi = new Bidi();\n\n    // Create and register 'glyphIndex' state modifier\n    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };\n    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);\n\n    // roll-back to default features\n    var features = options\n        ? this.updateFeatures(options.features)\n        : this.defaultRenderOptions.features;\n\n    bidi.applyFeatures(this, features);\n\n    var indexes = bidi.getTextGlyphs(s);\n\n    var length = indexes.length;\n\n    // convert glyph indexes to glyph objects\n    var glyphs = new Array(length);\n    var notdef = this.glyphs.get(0);\n    for (var i = 0; i < length; i += 1) {\n        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;\n    }\n    return glyphs;\n};\n\n/**\n * Retrieve the value of the kerning pair between the left glyph (or its index)\n * and the right glyph (or its index). If no kerning pair is found, return 0.\n * The kerning value gets added to the advance width when calculating the spacing\n * between glyphs.\n * For GPOS kerning, this method uses the default script and language, which covers\n * most use cases. To have greater control, use font.position.getKerningValue .\n * @param  {opentype.Glyph} leftGlyph\n * @param  {opentype.Glyph} rightGlyph\n * @return {Number}\n */\nFont.prototype.getKerningValue = function (leftGlyph, rightGlyph) {\n    leftGlyph = leftGlyph.index || leftGlyph;\n    rightGlyph = rightGlyph.index || rightGlyph;\n    var gposKerning = this.position.defaultKerningTables;\n    if (gposKerning) {\n        return this.position.getKerningValue(\n            gposKerning,\n            leftGlyph,\n            rightGlyph\n        );\n    }\n    // \"kern\" table\n    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;\n};\n\n/**\n * @typedef GlyphRenderOptions\n * @type Object\n * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n * @property {string} [language='dflt'] - language system used to determine which features to apply.\n *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n * @property {boolean} [kerning=true] - whether to include kerning values\n * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n */\nFont.prototype.defaultRenderOptions = {\n    kerning: true,\n    features: [\n        /**\n         * these 4 features are required to render Arabic text properly\n         * and shouldn't be turned off when rendering arabic text.\n         */\n        { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },\n        { script: 'latn', tags: ['liga', 'rlig'] } ],\n};\n\n/**\n * Helper function that invokes the given callback for each glyph in the given text.\n * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n * @param {string} text - The text to apply.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @param  {Function} callback\n */\nFont.prototype.forEachGlyph = function (\n    text,\n    x,\n    y,\n    fontSize,\n    options,\n    callback\n) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    options = Object.assign({}, this.defaultRenderOptions, options);\n    var fontScale = (1 / this.unitsPerEm) * fontSize;\n    var glyphs = this.stringToGlyphs(text, options);\n    var kerningLookups;\n    if (options.kerning) {\n        var script = options.script || this.position.getDefaultScriptName();\n        kerningLookups = this.position.getKerningTables(\n            script,\n            options.language\n        );\n    }\n    for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs[i];\n        callback.call(this, glyph, x, y, fontSize, options);\n        if (glyph.advanceWidth) {\n            x += glyph.advanceWidth * fontScale;\n        }\n\n        if (options.kerning && i < glyphs.length - 1) {\n            // We should apply position adjustment lookups in a more generic way.\n            // Here we only use the xAdvance value.\n            var kerningValue = kerningLookups\n                ? this.position.getKerningValue(\n                      kerningLookups,\n                      glyph.index,\n                      glyphs[i + 1].index\n                  )\n                : this.getKerningValue(glyph, glyphs[i + 1]);\n            x += kerningValue * fontScale;\n        }\n\n        if (options.letterSpacing) {\n            x += options.letterSpacing * fontSize;\n        } else if (options.tracking) {\n            x += (options.tracking / 1000) * fontSize;\n        }\n    }\n    return x;\n};\n\n/**\n * Create a Path object that represents the given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path}\n */\nFont.prototype.getPath = function (text, x, y, fontSize, options) {\n    var fullPath = new Path();\n    this.forEachGlyph(\n        text,\n        x,\n        y,\n        fontSize,\n        options,\n        function (glyph, gX, gY, gFontSize) {\n            var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n            fullPath.extend(glyphPath);\n        }\n    );\n    return fullPath;\n};\n\n/**\n * Create an array of Path objects that represent the glyphs of a given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path[]}\n */\nFont.prototype.getPaths = function (text, x, y, fontSize, options) {\n    var glyphPaths = [];\n    this.forEachGlyph(\n        text,\n        x,\n        y,\n        fontSize,\n        options,\n        function (glyph, gX, gY, gFontSize) {\n            var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n            glyphPaths.push(glyphPath);\n        }\n    );\n\n    return glyphPaths;\n};\n\n/**\n * Returns the advance width of a text.\n *\n * This is something different than Path.getBoundingBox() as for example a\n * suffixed whitespace increases the advanceWidth but not the bounding box\n * or an overhanging letter like a calligraphic 'f' might have a quite larger\n * bounding box than its advance width.\n *\n * This corresponds to canvas2dContext.measureText(text).width\n *\n * @param  {string} text - The text to create.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return advance width\n */\nFont.prototype.getAdvanceWidth = function (text, fontSize, options) {\n    return this.forEachGlyph(text, 0, 0, fontSize, options, function () {});\n};\n\n/**\n * @private\n */\nFont.prototype.fsSelectionValues = {\n    ITALIC: 0x001, //1\n    UNDERSCORE: 0x002, //2\n    NEGATIVE: 0x004, //4\n    OUTLINED: 0x008, //8\n    STRIKEOUT: 0x010, //16\n    BOLD: 0x020, //32\n    REGULAR: 0x040, //64\n    USER_TYPO_METRICS: 0x080, //128\n    WWS: 0x100, //256\n    OBLIQUE: 0x200, //512\n};\n\n/**\n * @private\n */\nFont.prototype.usWidthClasses = {\n    ULTRA_CONDENSED: 1,\n    EXTRA_CONDENSED: 2,\n    CONDENSED: 3,\n    SEMI_CONDENSED: 4,\n    MEDIUM: 5,\n    SEMI_EXPANDED: 6,\n    EXPANDED: 7,\n    EXTRA_EXPANDED: 8,\n    ULTRA_EXPANDED: 9,\n};\n\n/**\n * @private\n */\nFont.prototype.usWeightClasses = {\n    THIN: 100,\n    EXTRA_LIGHT: 200,\n    LIGHT: 300,\n    NORMAL: 400,\n    MEDIUM: 500,\n    SEMI_BOLD: 600,\n    BOLD: 700,\n    EXTRA_BOLD: 800,\n    BLACK: 900,\n};\n\n// The `cmap` table stores the mappings from characters to glyphs.\n\nfunction parseCmapTableFormat12(cmap, p) {\n    //Skip reserved.\n    p.parseUShort();\n\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseULong();\n    cmap.language = p.parseULong();\n\n    var groupCount;\n    cmap.groupCount = groupCount = p.parseULong();\n    cmap.glyphIndexMap = {};\n\n    for (var i = 0; i < groupCount; i += 1) {\n        var startCharCode = p.parseULong();\n        var endCharCode = p.parseULong();\n        var startGlyphId = p.parseULong();\n\n        for (var c = startCharCode; c <= endCharCode; c += 1) {\n            cmap.glyphIndexMap[c] = startGlyphId;\n            startGlyphId++;\n        }\n    }\n}\n\nfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseUShort();\n    cmap.language = p.parseUShort();\n\n    // segCount is stored x 2.\n    var segCount;\n    cmap.segCount = segCount = p.parseUShort() >> 1;\n\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n\n    // The \"unrolled\" mapping from character codes to glyph indices.\n    cmap.glyphIndexMap = {};\n    var endCountParser = new parse.Parser(data, start + offset + 14);\n    var startCountParser = new parse.Parser(\n        data,\n        start + offset + 16 + segCount * 2\n    );\n    var idDeltaParser = new parse.Parser(\n        data,\n        start + offset + 16 + segCount * 4\n    );\n    var idRangeOffsetParser = new parse.Parser(\n        data,\n        start + offset + 16 + segCount * 6\n    );\n    var glyphIndexOffset = start + offset + 16 + segCount * 8;\n    for (var i = 0; i < segCount - 1; i += 1) {\n        var glyphIndex = (void 0);\n        var endCount = endCountParser.parseUShort();\n        var startCount = startCountParser.parseUShort();\n        var idDelta = idDeltaParser.parseShort();\n        var idRangeOffset = idRangeOffsetParser.parseUShort();\n        for (var c = startCount; c <= endCount; c += 1) {\n            if (idRangeOffset !== 0) {\n                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                // Take the current offset in the idRangeOffset array.\n                glyphIndexOffset =\n                    idRangeOffsetParser.offset +\n                    idRangeOffsetParser.relativeOffset -\n                    2;\n\n                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n                glyphIndexOffset += idRangeOffset;\n\n                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n                glyphIndexOffset += (c - startCount) * 2;\n                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n                if (glyphIndex !== 0) {\n                    glyphIndex = (glyphIndex + idDelta) & 0xffff;\n                }\n            } else {\n                glyphIndex = (c + idDelta) & 0xffff;\n            }\n\n            cmap.glyphIndexMap[c] = glyphIndex;\n        }\n    }\n}\n\n// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4 and 12.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\nfunction parseCmapTable(data, start) {\n    var cmap = {};\n    cmap.version = parse.getUShort(data, start);\n    check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n    // The cmap table can contain many sub-tables, each with their own format.\n    // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n    cmap.numTables = parse.getUShort(data, start + 2);\n    var offset = -1;\n    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {\n        var platformId = parse.getUShort(data, start + 4 + i * 8);\n        var encodingId = parse.getUShort(data, start + 4 + i * 8 + 2);\n        if (\n            (platformId === 3 &&\n                (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||\n            (platformId === 0 &&\n                (encodingId === 0 ||\n                    encodingId === 1 ||\n                    encodingId === 2 ||\n                    encodingId === 3 ||\n                    encodingId === 4))\n        ) {\n            offset = parse.getULong(data, start + 4 + i * 8 + 4);\n            break;\n        }\n    }\n\n    if (offset === -1) {\n        // There is no cmap table in the font that we support.\n        throw new Error('No valid cmap sub-tables found.');\n    }\n\n    var p = new parse.Parser(data, start + offset);\n    cmap.format = p.parseUShort();\n\n    if (cmap.format === 12) {\n        parseCmapTableFormat12(cmap, p);\n    } else if (cmap.format === 4) {\n        parseCmapTableFormat4(cmap, p, data, start, offset);\n    } else {\n        throw new Error(\n            'Only format 4 and 12 cmap tables are supported (found format ' +\n                cmap.format +\n                ').'\n        );\n    }\n\n    return cmap;\n}\n\nvar cmap = { parse: parseCmapTable };\n\n// The `CFF` table contains the glyph outlines in PostScript format.\n\n// Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\nfunction calcCFFSubroutineBias(subrs) {\n    var bias;\n    if (subrs.length < 1240) {\n        bias = 107;\n    } else if (subrs.length < 33900) {\n        bias = 1131;\n    } else {\n        bias = 32768;\n    }\n\n    return bias;\n}\n\n// Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\nfunction parseCFFIndex(data, start, conversionFn) {\n    var offsets = [];\n    var objects = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + (count + 1) * offsetSize + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {\n        var value = parse.getBytes(\n            data,\n            objectOffset + offsets[i$1],\n            objectOffset + offsets[i$1 + 1]\n        );\n        if (conversionFn) {\n            value = conversionFn(value);\n        }\n\n        objects.push(value);\n    }\n\n    return { objects: objects, startOffset: start, endOffset: endOffset };\n}\n\nfunction parseCFFIndexLowMemory(data, start) {\n    var offsets = [];\n    var count = parse.getCard16(data, start);\n    var objectOffset;\n    var endOffset;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + (count + 1) * offsetSize + 2;\n        var pos = start + 3;\n        for (var i = 0; i < count + 1; i += 1) {\n            offsets.push(parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    return { offsets: offsets, startOffset: start, endOffset: endOffset };\n}\nfunction getCffIndexObject(i, offsets, data, start, conversionFn) {\n    var count = parse.getCard16(data, start);\n    var objectOffset = 0;\n    if (count !== 0) {\n        var offsetSize = parse.getByte(data, start + 2);\n        objectOffset = start + (count + 1) * offsetSize + 2;\n    }\n\n    var value = parse.getBytes(\n        data,\n        objectOffset + offsets[i],\n        objectOffset + offsets[i + 1]\n    );\n    if (conversionFn) {\n        value = conversionFn(value);\n    }\n    return value;\n}\n\n// Parse a `CFF` DICT real value.\nfunction parseFloatOperand(parser) {\n    var s = '';\n    var eof = 15;\n    var lookup = [\n        '0',\n        '1',\n        '2',\n        '3',\n        '4',\n        '5',\n        '6',\n        '7',\n        '8',\n        '9',\n        '.',\n        'E',\n        'E-',\n        null,\n        '-' ];\n    while (true) {\n        var b = parser.parseByte();\n        var n1 = b >> 4;\n        var n2 = b & 15;\n\n        if (n1 === eof) {\n            break;\n        }\n\n        s += lookup[n1];\n\n        if (n2 === eof) {\n            break;\n        }\n\n        s += lookup[n2];\n    }\n\n    return parseFloat(s);\n}\n\n// Parse a `CFF` DICT operand.\nfunction parseOperand(parser, b0) {\n    var b1;\n    var b2;\n    var b3;\n    var b4;\n    if (b0 === 28) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        return (b1 << 8) | b2;\n    }\n\n    if (b0 === 29) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        b3 = parser.parseByte();\n        b4 = parser.parseByte();\n        return (b1 << 24) | (b2 << 16) | (b3 << 8) | b4;\n    }\n\n    if (b0 === 30) {\n        return parseFloatOperand(parser);\n    }\n\n    if (b0 >= 32 && b0 <= 246) {\n        return b0 - 139;\n    }\n\n    if (b0 >= 247 && b0 <= 250) {\n        b1 = parser.parseByte();\n        return (b0 - 247) * 256 + b1 + 108;\n    }\n\n    if (b0 >= 251 && b0 <= 254) {\n        b1 = parser.parseByte();\n        return -(b0 - 251) * 256 - b1 - 108;\n    }\n\n    throw new Error('Invalid b0 ' + b0);\n}\n\n// Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\nfunction entriesToObject(entries) {\n    var o = {};\n    for (var i = 0; i < entries.length; i += 1) {\n        var key = entries[i][0];\n        var values = entries[i][1];\n        var value = (void 0);\n        if (values.length === 1) {\n            value = values[0];\n        } else {\n            value = values;\n        }\n\n        if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n            throw new Error('Object ' + o + ' already has key ' + key);\n        }\n\n        o[key] = value;\n    }\n\n    return o;\n}\n\n// Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\nfunction parseCFFDict(data, start, size) {\n    start = start !== undefined ? start : 0;\n    var parser = new parse.Parser(data, start);\n    var entries = [];\n    var operands = [];\n    size = size !== undefined ? size : data.length;\n\n    while (parser.relativeOffset < size) {\n        var op = parser.parseByte();\n\n        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n        // Values <= 21 are operators.\n        if (op <= 21) {\n            // Two-byte operators have an initial escape byte of 12.\n            if (op === 12) {\n                op = 1200 + parser.parseByte();\n            }\n\n            entries.push([op, operands]);\n            operands = [];\n        } else {\n            // Since the operands (values) come before the operators (keys), we store all operands in a list\n            // until we encounter an operator.\n            operands.push(parseOperand(parser, op));\n        }\n    }\n\n    return entriesToObject(entries);\n}\n\n// Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\nfunction getCFFString(strings, index) {\n    if (index <= 390) {\n        index = cffStandardStrings[index];\n    } else {\n        index = strings[index - 391];\n    }\n\n    return index;\n}\n\n// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\nfunction interpretDict(dict, meta, strings) {\n    var newDict = {};\n    var value;\n\n    // Because we also want to include missing values, we start out from the meta list\n    // and lookup values in the dict.\n    for (var i = 0; i < meta.length; i += 1) {\n        var m = meta[i];\n\n        if (Array.isArray(m.type)) {\n            var values = [];\n            values.length = m.type.length;\n            for (var j = 0; j < m.type.length; j++) {\n                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n                if (value === undefined) {\n                    value =\n                        m.value !== undefined && m.value[j] !== undefined\n                            ? m.value[j]\n                            : null;\n                }\n                if (m.type[j] === 'SID') {\n                    value = getCFFString(strings, value);\n                }\n                values[j] = value;\n            }\n            newDict[m.name] = values;\n        } else {\n            value = dict[m.op];\n            if (value === undefined) {\n                value = m.value !== undefined ? m.value : null;\n            }\n\n            if (m.type === 'SID') {\n                value = getCFFString(strings, value);\n            }\n            newDict[m.name] = value;\n        }\n    }\n\n    return newDict;\n}\n\n// Parse the CFF header.\nfunction parseCFFHeader(data, start) {\n    var header = {};\n    header.formatMajor = parse.getCard8(data, start);\n    header.formatMinor = parse.getCard8(data, start + 1);\n    header.size = parse.getCard8(data, start + 2);\n    header.offsetSize = parse.getCard8(data, start + 3);\n    header.startOffset = start;\n    header.endOffset = start + 4;\n    return header;\n}\n\nvar TOP_DICT_META = [\n    { name: 'version', op: 0, type: 'SID' },\n    { name: 'notice', op: 1, type: 'SID' },\n    { name: 'copyright', op: 1200, type: 'SID' },\n    { name: 'fullName', op: 2, type: 'SID' },\n    { name: 'familyName', op: 3, type: 'SID' },\n    { name: 'weight', op: 4, type: 'SID' },\n    { name: 'isFixedPitch', op: 1201, type: 'number', value: 0 },\n    { name: 'italicAngle', op: 1202, type: 'number', value: 0 },\n    { name: 'underlinePosition', op: 1203, type: 'number', value: -100 },\n    { name: 'underlineThickness', op: 1204, type: 'number', value: 50 },\n    { name: 'paintType', op: 1205, type: 'number', value: 0 },\n    { name: 'charstringType', op: 1206, type: 'number', value: 2 },\n    {\n        name: 'fontMatrix',\n        op: 1207,\n        type: ['real', 'real', 'real', 'real', 'real', 'real'],\n        value: [0.001, 0, 0, 0.001, 0, 0],\n    },\n    { name: 'uniqueId', op: 13, type: 'number' },\n    {\n        name: 'fontBBox',\n        op: 5,\n        type: ['number', 'number', 'number', 'number'],\n        value: [0, 0, 0, 0],\n    },\n    { name: 'strokeWidth', op: 1208, type: 'number', value: 0 },\n    { name: 'xuid', op: 14, type: [], value: null },\n    { name: 'charset', op: 15, type: 'offset', value: 0 },\n    { name: 'encoding', op: 16, type: 'offset', value: 0 },\n    { name: 'charStrings', op: 17, type: 'offset', value: 0 },\n    { name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0] },\n    { name: 'ros', op: 1230, type: ['SID', 'SID', 'number'] },\n    { name: 'cidFontVersion', op: 1231, type: 'number', value: 0 },\n    { name: 'cidFontRevision', op: 1232, type: 'number', value: 0 },\n    { name: 'cidFontType', op: 1233, type: 'number', value: 0 },\n    { name: 'cidCount', op: 1234, type: 'number', value: 8720 },\n    { name: 'uidBase', op: 1235, type: 'number' },\n    { name: 'fdArray', op: 1236, type: 'offset' },\n    { name: 'fdSelect', op: 1237, type: 'offset' },\n    { name: 'fontName', op: 1238, type: 'SID' } ];\n\nvar PRIVATE_DICT_META = [\n    { name: 'subrs', op: 19, type: 'offset', value: 0 },\n    { name: 'defaultWidthX', op: 20, type: 'number', value: 0 },\n    { name: 'nominalWidthX', op: 21, type: 'number', value: 0 } ];\n\n// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\nfunction parseCFFTopDict(data, strings) {\n    var dict = parseCFFDict(data, 0, data.byteLength);\n    return interpretDict(dict, TOP_DICT_META, strings);\n}\n\n// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\nfunction parseCFFPrivateDict(data, start, size, strings) {\n    var dict = parseCFFDict(data, start, size);\n    return interpretDict(dict, PRIVATE_DICT_META, strings);\n}\n\n// Returns a list of \"Top DICT\"s found using an INDEX list.\n// Used to read both the usual high-level Top DICTs and also the FDArray\n// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n// a Private DICT that is read and saved into the Top DICT.\n//\n// In addition to the expected/optional values as outlined in TOP_DICT_META\n// the following values might be saved into the Top DICT.\n//\n//    _subrs []        array of local CFF subroutines from Private DICT\n//    _subrsBias       bias value computed from number of subroutines\n//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n//    _defaultWidthX   default widths for CFF characters\n//    _nominalWidthX   bias added to width embedded within glyph description\n//\n//    _privateDict     saved copy of parsed Private DICT from Top DICT\nfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n    var topDictArray = [];\n    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n        var topDictData = new DataView(\n            new Uint8Array(cffIndex[iTopDict]).buffer\n        );\n        var topDict = parseCFFTopDict(topDictData, strings);\n        topDict._subrs = [];\n        topDict._subrsBias = 0;\n        topDict._defaultWidthX = 0;\n        topDict._nominalWidthX = 0;\n        var privateSize = topDict.private[0];\n        var privateOffset = topDict.private[1];\n        if (privateSize !== 0 && privateOffset !== 0) {\n            var privateDict = parseCFFPrivateDict(\n                data,\n                privateOffset + start,\n                privateSize,\n                strings\n            );\n            topDict._defaultWidthX = privateDict.defaultWidthX;\n            topDict._nominalWidthX = privateDict.nominalWidthX;\n            if (privateDict.subrs !== 0) {\n                var subrOffset = privateOffset + privateDict.subrs;\n                var subrIndex = parseCFFIndex(data, subrOffset + start);\n                topDict._subrs = subrIndex.objects;\n                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n            }\n            topDict._privateDict = privateDict;\n        }\n        topDictArray.push(topDict);\n    }\n    return topDictArray;\n}\n\n// Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n    var sid;\n    var count;\n    var parser = new parse.Parser(data, start);\n\n    // The .notdef glyph is not included, so subtract 1.\n    nGlyphs -= 1;\n    var charset = ['.notdef'];\n\n    var format = parser.parseCard8();\n    if (format === 0) {\n        for (var i = 0; i < nGlyphs; i += 1) {\n            sid = parser.parseSID();\n            charset.push(getCFFString(strings, sid));\n        }\n    } else if (format === 1) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard8();\n            for (var i$1 = 0; i$1 <= count; i$1 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else if (format === 2) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard16();\n            for (var i$2 = 0; i$2 <= count; i$2 += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown charset format ' + format);\n    }\n\n    return charset;\n}\n\n// Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\nfunction parseCFFEncoding(data, start, charset) {\n    var code;\n    var enc = {};\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        var nCodes = parser.parseCard8();\n        for (var i = 0; i < nCodes; i += 1) {\n            code = parser.parseCard8();\n            enc[code] = i;\n        }\n    } else if (format === 1) {\n        var nRanges = parser.parseCard8();\n        code = 1;\n        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {\n            var first = parser.parseCard8();\n            var nLeft = parser.parseCard8();\n            for (var j = first; j <= first + nLeft; j += 1) {\n                enc[j] = code;\n                code += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown encoding format ' + format);\n    }\n\n    return new CffEncoding(enc, charset);\n}\n\n// Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\nfunction parseCFFCharstring(font, glyph, code) {\n    var c1x;\n    var c1y;\n    var c2x;\n    var c2y;\n    var p = new Path();\n    var stack = [];\n    var nStems = 0;\n    var haveWidth = false;\n    var open = false;\n    var x = 0;\n    var y = 0;\n    var subrs;\n    var subrsBias;\n    var defaultWidthX;\n    var nominalWidthX;\n    if (font.isCIDFont) {\n        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n        subrs = fdDict._subrs;\n        subrsBias = fdDict._subrsBias;\n        defaultWidthX = fdDict._defaultWidthX;\n        nominalWidthX = fdDict._nominalWidthX;\n    } else {\n        subrs = font.tables.cff.topDict._subrs;\n        subrsBias = font.tables.cff.topDict._subrsBias;\n        defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n        nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n    }\n    var width = defaultWidthX;\n\n    function newContour(x, y) {\n        if (open) {\n            p.closePath();\n        }\n\n        p.moveTo(x, y);\n        open = true;\n    }\n\n    function parseStems() {\n        var hasWidthArg;\n\n        // The number of stem operators on the stack is always even.\n        // If the value is uneven, that means a width is specified.\n        hasWidthArg = stack.length % 2 !== 0;\n        if (hasWidthArg && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n        }\n\n        nStems += stack.length >> 1;\n        stack.length = 0;\n        haveWidth = true;\n    }\n\n    function parse(code) {\n        var b1;\n        var b2;\n        var b3;\n        var b4;\n        var codeIndex;\n        var subrCode;\n        var jpx;\n        var jpy;\n        var c3x;\n        var c3y;\n        var c4x;\n        var c4y;\n\n        var i = 0;\n        while (i < code.length) {\n            var v = code[i];\n            i += 1;\n            switch (v) {\n                case 1: // hstem\n                    parseStems();\n                    break;\n                case 3: // vstem\n                    parseStems();\n                    break;\n                case 4: // vmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 5: // rlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 6: // hlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 7: // vlineto\n                    while (stack.length > 0) {\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 8: // rrcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 10: // callsubr\n                    codeIndex = stack.pop() + subrsBias;\n                    subrCode = subrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 11: // return\n                    return;\n                case 12: // flex operators\n                    v = code[i];\n                    i += 1;\n                    switch (v) {\n                        case 35: // flex\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y + stack.shift(); // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y + stack.shift(); // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = jpy + stack.shift(); // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = c3y + stack.shift(); // dy5\n                            x = c4x + stack.shift(); // dx6\n                            y = c4y + stack.shift(); // dy6\n                            stack.shift(); // flex depth\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 34: // hflex\n                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y; // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y; // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = c2y; // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = y; // dy5\n                            x = c4x + stack.shift(); // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 36: // hflex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y + stack.shift(); // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y; // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = c2y; // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = c3y + stack.shift(); // dy5\n                            x = c4x + stack.shift(); // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 37: // flex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                            c1x = x + stack.shift(); // dx1\n                            c1y = y + stack.shift(); // dy1\n                            c2x = c1x + stack.shift(); // dx2\n                            c2y = c1y + stack.shift(); // dy2\n                            jpx = c2x + stack.shift(); // dx3\n                            jpy = c2y + stack.shift(); // dy3\n                            c3x = jpx + stack.shift(); // dx4\n                            c3y = jpy + stack.shift(); // dy4\n                            c4x = c3x + stack.shift(); // dx5\n                            c4y = c3y + stack.shift(); // dy5\n                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                                x = c4x + stack.shift();\n                            } else {\n                                y = c4y + stack.shift();\n                            }\n\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        default:\n                            console.log(\n                                'Glyph ' +\n                                    glyph.index +\n                                    ': unknown operator ' +\n                                    1200 +\n                                    v\n                            );\n                            stack.length = 0;\n                    }\n                    break;\n                case 14: // endchar\n                    if (stack.length > 0 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    if (open) {\n                        p.closePath();\n                        open = false;\n                    }\n\n                    break;\n                case 18: // hstemhm\n                    parseStems();\n                    break;\n                case 19: // hintmask\n                case 20: // cntrmask\n                    parseStems();\n                    i += (nStems + 7) >> 3;\n                    break;\n                case 21: // rmoveto\n                    if (stack.length > 2 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 22: // hmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 23: // vstemhm\n                    parseStems();\n                    break;\n                case 24: // rcurveline\n                    while (stack.length > 2) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                    break;\n                case 25: // rlinecurve\n                    while (stack.length > 6) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    break;\n                case 26: // vvcurveto\n                    if (stack.length % 2) {\n                        x += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x;\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 27: // hhcurveto\n                    if (stack.length % 2) {\n                        y += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y;\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 28: // shortint\n                    b1 = code[i];\n                    b2 = code[i + 1];\n                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n                    i += 2;\n                    break;\n                case 29: // callgsubr\n                    codeIndex = stack.pop() + font.gsubrsBias;\n                    subrCode = font.gsubrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 30: // vhcurveto\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 31: // hvcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                default:\n                    if (v < 32) {\n                        console.log(\n                            'Glyph ' + glyph.index + ': unknown operator ' + v\n                        );\n                    } else if (v < 247) {\n                        stack.push(v - 139);\n                    } else if (v < 251) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push((v - 247) * 256 + b1 + 108);\n                    } else if (v < 255) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push(-(v - 251) * 256 - b1 - 108);\n                    } else {\n                        b1 = code[i];\n                        b2 = code[i + 1];\n                        b3 = code[i + 2];\n                        b4 = code[i + 3];\n                        i += 4;\n                        stack.push(\n                            ((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536\n                        );\n                    }\n            }\n        }\n    }\n\n    parse(code);\n\n    glyph.advanceWidth = width;\n    return p;\n}\n\nfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n    var fdSelect = [];\n    var fdIndex;\n    var parser = new parse.Parser(data, start);\n    var format = parser.parseCard8();\n    if (format === 0) {\n        // Simple list of nGlyphs elements\n        for (var iGid = 0; iGid < nGlyphs; iGid++) {\n            fdIndex = parser.parseCard8();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error(\n                    'CFF table CID Font FDSelect has bad FD index value ' +\n                        fdIndex +\n                        ' (FD count ' +\n                        fdArrayCount +\n                        ')'\n                );\n            }\n            fdSelect.push(fdIndex);\n        }\n    } else if (format === 3) {\n        // Ranges\n        var nRanges = parser.parseCard16();\n        var first = parser.parseCard16();\n        if (first !== 0) {\n            throw new Error(\n                'CFF Table CID Font FDSelect format 3 range has bad initial GID ' +\n                    first\n            );\n        }\n        var next;\n        for (var iRange = 0; iRange < nRanges; iRange++) {\n            fdIndex = parser.parseCard8();\n            next = parser.parseCard16();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error(\n                    'CFF table CID Font FDSelect has bad FD index value ' +\n                        fdIndex +\n                        ' (FD count ' +\n                        fdArrayCount +\n                        ')'\n                );\n            }\n            if (next > nGlyphs) {\n                throw new Error(\n                    'CFF Table CID Font FDSelect format 3 range has bad GID ' +\n                        next\n                );\n            }\n            for (; first < next; first++) {\n                fdSelect.push(fdIndex);\n            }\n            first = next;\n        }\n        if (next !== nGlyphs) {\n            throw new Error(\n                'CFF Table CID Font FDSelect format 3 range has bad final GID ' +\n                    next\n            );\n        }\n    } else {\n        throw new Error(\n            'CFF Table CID Font FDSelect table has unsupported format ' + format\n        );\n    }\n    return fdSelect;\n}\n\n// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\nfunction parseCFFTable(data, start, font, opt) {\n    font.tables.cff = {};\n    var header = parseCFFHeader(data, start);\n    var nameIndex = parseCFFIndex(\n        data,\n        header.endOffset,\n        parse.bytesToString\n    );\n    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n    var stringIndex = parseCFFIndex(\n        data,\n        topDictIndex.endOffset,\n        parse.bytesToString\n    );\n    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n    font.gsubrs = globalSubrIndex.objects;\n    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n    var topDictArray = gatherCFFTopDicts(\n        data,\n        start,\n        topDictIndex.objects,\n        stringIndex.objects\n    );\n    if (topDictArray.length !== 1) {\n        throw new Error(\n            \"CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = \" +\n                topDictArray.length\n        );\n    }\n\n    var topDict = topDictArray[0];\n    font.tables.cff.topDict = topDict;\n\n    if (topDict._privateDict) {\n        font.defaultWidthX = topDict._privateDict.defaultWidthX;\n        font.nominalWidthX = topDict._privateDict.nominalWidthX;\n    }\n\n    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n        font.isCIDFont = true;\n    }\n\n    if (font.isCIDFont) {\n        var fdArrayOffset = topDict.fdArray;\n        var fdSelectOffset = topDict.fdSelect;\n        if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n            throw new Error(\n                'Font is marked as a CID font, but FDArray and/or FDSelect information is missing'\n            );\n        }\n        fdArrayOffset += start;\n        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n        var fdArray = gatherCFFTopDicts(\n            data,\n            start,\n            fdArrayIndex.objects,\n            stringIndex.objects\n        );\n        topDict._fdArray = fdArray;\n        fdSelectOffset += start;\n        topDict._fdSelect = parseCFFFDSelect(\n            data,\n            fdSelectOffset,\n            font.numGlyphs,\n            fdArray.length\n        );\n    }\n\n    var privateDictOffset = start + topDict.private[1];\n    var privateDict = parseCFFPrivateDict(\n        data,\n        privateDictOffset,\n        topDict.private[0],\n        stringIndex.objects\n    );\n    font.defaultWidthX = privateDict.defaultWidthX;\n    font.nominalWidthX = privateDict.nominalWidthX;\n\n    if (privateDict.subrs !== 0) {\n        var subrOffset = privateDictOffset + privateDict.subrs;\n        var subrIndex = parseCFFIndex(data, subrOffset);\n        font.subrs = subrIndex.objects;\n        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n    } else {\n        font.subrs = [];\n        font.subrsBias = 0;\n    }\n\n    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n    var charStringsIndex;\n    if (opt.lowMemory) {\n        charStringsIndex = parseCFFIndexLowMemory(\n            data,\n            start + topDict.charStrings\n        );\n        font.nGlyphs = charStringsIndex.offsets.length;\n    } else {\n        charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n        font.nGlyphs = charStringsIndex.objects.length;\n    }\n\n    var charset = parseCFFCharset(\n        data,\n        start + topDict.charset,\n        font.nGlyphs,\n        stringIndex.objects\n    );\n    if (topDict.encoding === 0) {\n        // Standard encoding\n        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n    } else if (topDict.encoding === 1) {\n        // Expert encoding\n        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n    } else {\n        font.cffEncoding = parseCFFEncoding(\n            data,\n            start + topDict.encoding,\n            charset\n        );\n    }\n\n    // Prefer the CMAP encoding to the CFF encoding.\n    font.encoding = font.encoding || font.cffEncoding;\n\n    font.glyphs = new glyphset.GlyphSet(font);\n    if (opt.lowMemory) {\n        font._push = function (i) {\n            var charString = getCffIndexObject(\n                i,\n                charStringsIndex.offsets,\n                data,\n                start + topDict.charStrings\n            );\n            font.glyphs.push(\n                i,\n                glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString)\n            );\n        };\n    } else {\n        for (var i = 0; i < font.nGlyphs; i += 1) {\n            var charString = charStringsIndex.objects[i];\n            font.glyphs.push(\n                i,\n                glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString)\n            );\n        }\n    }\n}\n\nvar cff = { parse: parseCFFTable };\n\n// The `fvar` table stores font variation axes and instances.\n\nfunction parseFvarAxis(data, start, names) {\n    var axis = {};\n    var p = new parse.Parser(data, start);\n    axis.tag = p.parseTag();\n    axis.minValue = p.parseFixed();\n    axis.defaultValue = p.parseFixed();\n    axis.maxValue = p.parseFixed();\n    p.skip('uShort', 1); // reserved for flags; no values defined\n    axis.name = names[p.parseUShort()] || {};\n    return axis;\n}\n\nfunction parseFvarInstance(data, start, axes, names) {\n    var inst = {};\n    var p = new parse.Parser(data, start);\n    inst.name = names[p.parseUShort()] || {};\n    p.skip('uShort', 1); // reserved for flags; no values defined\n\n    inst.coordinates = {};\n    for (var i = 0; i < axes.length; ++i) {\n        inst.coordinates[axes[i].tag] = p.parseFixed();\n    }\n\n    return inst;\n}\n\nfunction parseFvarTable(data, start, names) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(\n        tableVersion === 0x00010000,\n        'Unsupported fvar table version.'\n    );\n    var offsetToData = p.parseOffset16();\n    // Skip countSizePairs.\n    p.skip('uShort', 1);\n    var axisCount = p.parseUShort();\n    var axisSize = p.parseUShort();\n    var instanceCount = p.parseUShort();\n    var instanceSize = p.parseUShort();\n\n    var axes = [];\n    for (var i = 0; i < axisCount; i++) {\n        axes.push(\n            parseFvarAxis(data, start + offsetToData + i * axisSize, names)\n        );\n    }\n\n    var instances = [];\n    var instanceStart = start + offsetToData + axisCount * axisSize;\n    for (var j = 0; j < instanceCount; j++) {\n        instances.push(\n            parseFvarInstance(\n                data,\n                instanceStart + j * instanceSize,\n                axes,\n                names\n            )\n        );\n    }\n\n    return { axes: axes, instances: instances };\n}\n\nvar fvar = { parse: parseFvarTable };\n\n// The `GDEF` table contains various glyph properties\n\nvar attachList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        attachPoints: this.parseList(Parser.pointer(Parser.uShortList))\n    };\n};\n\nvar caretValue = function() {\n    var format = this.parseUShort();\n    check.argument(format === 1 || format === 2 || format === 3,\n        'Unsupported CaretValue table version.');\n    if (format === 1) {\n        return { coordinate: this.parseShort() };\n    } else if (format === 2) {\n        return { pointindex: this.parseShort() };\n    } else if (format === 3) {\n        // Device / Variation Index tables unsupported\n        return { coordinate: this.parseShort() };\n    }\n};\n\nvar ligGlyph = function() {\n    return this.parseList(Parser.pointer(caretValue));\n};\n\nvar ligCaretList = function() {\n    return {\n        coverage: this.parsePointer(Parser.coverage),\n        ligGlyphs: this.parseList(Parser.pointer(ligGlyph))\n    };\n};\n\nvar markGlyphSets = function() {\n    this.parseUShort(); // Version\n    return this.parseList(Parser.pointer(Parser.coverage));\n};\n\nfunction parseGDEFTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,\n        'Unsupported GDEF table version.');\n    var gdef = {\n        version: tableVersion,\n        classDef: p.parsePointer(Parser.classDef),\n        attachList: p.parsePointer(attachList),\n        ligCaretList: p.parsePointer(ligCaretList),\n        markAttachClassDef: p.parsePointer(Parser.classDef)\n    };\n    if (tableVersion >= 1.2) {\n        gdef.markGlyphSets = p.parsePointer(markGlyphSets);\n    }\n    return gdef;\n}\nvar gdef = { parse: parseGDEFTable };\n\n// The `GPOS` table contains kerning pairs, among other things.\n\nvar subtableParsers = new Array(10); // subtableParsers[0] is unused\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable\n// this = Parser instance\nsubtableParsers[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var posformat = this.parseUShort();\n    if (posformat === 1) {\n        return {\n            posFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            value: this.parseValueRecord(),\n        };\n    } else if (posformat === 2) {\n        return {\n            posFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            values: this.parseValueRecordList(),\n        };\n    }\n    check.assert(\n        false,\n        '0x' +\n            start.toString(16) +\n            ': GPOS lookup type 1 format must be 1 or 2.'\n    );\n};\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable\nsubtableParsers[2] = function parseLookup2() {\n    var start = this.offset + this.relativeOffset;\n    var posFormat = this.parseUShort();\n    check.assert(\n        posFormat === 1 || posFormat === 2,\n        '0x' +\n            start.toString(16) +\n            ': GPOS lookup type 2 format must be 1 or 2.'\n    );\n    var coverage = this.parsePointer(Parser.coverage);\n    var valueFormat1 = this.parseUShort();\n    var valueFormat2 = this.parseUShort();\n    if (posFormat === 1) {\n        // Adjustments for Glyph Pairs\n        return {\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            pairSets: this.parseList(\n                Parser.pointer(\n                    Parser.list(function () {\n                        return {\n                            // pairValueRecord\n                            secondGlyph: this.parseUShort(),\n                            value1: this.parseValueRecord(valueFormat1),\n                            value2: this.parseValueRecord(valueFormat2),\n                        };\n                    })\n                )\n            ),\n        };\n    } else if (posFormat === 2) {\n        var classDef1 = this.parsePointer(Parser.classDef);\n        var classDef2 = this.parsePointer(Parser.classDef);\n        var class1Count = this.parseUShort();\n        var class2Count = this.parseUShort();\n        return {\n            // Class Pair Adjustment\n            posFormat: posFormat,\n            coverage: coverage,\n            valueFormat1: valueFormat1,\n            valueFormat2: valueFormat2,\n            classDef1: classDef1,\n            classDef2: classDef2,\n            class1Count: class1Count,\n            class2Count: class2Count,\n            classRecords: this.parseList(\n                class1Count,\n                Parser.list(class2Count, function () {\n                    return {\n                        value1: this.parseValueRecord(valueFormat1),\n                        value2: this.parseValueRecord(valueFormat2),\n                    };\n                })\n            ),\n        };\n    }\n};\n\nsubtableParsers[3] = function parseLookup3() {\n    return { error: 'GPOS Lookup 3 not supported' };\n};\nsubtableParsers[4] = function parseLookup4() {\n    return { error: 'GPOS Lookup 4 not supported' };\n};\nsubtableParsers[5] = function parseLookup5() {\n    return { error: 'GPOS Lookup 5 not supported' };\n};\nsubtableParsers[6] = function parseLookup6() {\n    return { error: 'GPOS Lookup 6 not supported' };\n};\nsubtableParsers[7] = function parseLookup7() {\n    return { error: 'GPOS Lookup 7 not supported' };\n};\nsubtableParsers[8] = function parseLookup8() {\n    return { error: 'GPOS Lookup 8 not supported' };\n};\nsubtableParsers[9] = function parseLookup9() {\n    return { error: 'GPOS Lookup 9 not supported' };\n};\n\n// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos\nfunction parseGposTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(\n        tableVersion === 1 || tableVersion === 1.1,\n        'Unsupported GPOS table version ' + tableVersion\n    );\n\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers),\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers),\n            variations: p.parseFeatureVariationsList(),\n        };\n    }\n}\n\nvar gpos = { parse: parseGposTable };\n\n// The `GSUB` table contains ligatures, among other things.\n\nvar subtableParsers$1 = new Array(9); // subtableParsers[0] is unused\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\nsubtableParsers$1[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            deltaGlyphId: this.parseUShort(),\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            substitute: this.parseOffset16List(),\n        };\n    }\n    check.assert(\n        false,\n        '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.'\n    );\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\nsubtableParsers$1[2] = function parseLookup2() {\n    var substFormat = this.parseUShort();\n    check.argument(\n        substFormat === 1,\n        'GSUB Multiple Substitution Subtable identifier-format must be 1'\n    );\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        sequences: this.parseListOfLists(),\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\nsubtableParsers$1[3] = function parseLookup3() {\n    var substFormat = this.parseUShort();\n    check.argument(\n        substFormat === 1,\n        'GSUB Alternate Substitution Subtable identifier-format must be 1'\n    );\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        alternateSets: this.parseListOfLists(),\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\nsubtableParsers$1[4] = function parseLookup4() {\n    var substFormat = this.parseUShort();\n    check.argument(\n        substFormat === 1,\n        'GSUB ligature table identifier-format must be 1'\n    );\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        ligatureSets: this.parseListOfLists(function () {\n            return {\n                ligGlyph: this.parseUShort(),\n                components: this.parseUShortList(this.parseUShort() - 1),\n            };\n        }),\n    };\n};\n\nvar lookupRecordDesc = {\n    sequenceIndex: Parser.uShort,\n    lookupListIndex: Parser.uShort,\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\nsubtableParsers$1[5] = function parseLookup5() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n\n    if (substFormat === 1) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            ruleSets: this.parseListOfLists(function () {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    input: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(\n                        substCount,\n                        lookupRecordDesc\n                    ),\n                };\n            }),\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            classDef: this.parsePointer(Parser.classDef),\n            classSets: this.parseListOfLists(function () {\n                var glyphCount = this.parseUShort();\n                var substCount = this.parseUShort();\n                return {\n                    classes: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(\n                        substCount,\n                        lookupRecordDesc\n                    ),\n                };\n            }),\n        };\n    } else if (substFormat === 3) {\n        var glyphCount = this.parseUShort();\n        var substCount = this.parseUShort();\n        return {\n            substFormat: substFormat,\n            coverages: this.parseList(\n                glyphCount,\n                Parser.pointer(Parser.coverage)\n            ),\n            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc),\n        };\n    }\n    check.assert(\n        false,\n        '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.'\n    );\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\nsubtableParsers$1[6] = function parseLookup6() {\n    var start = this.offset + this.relativeOffset;\n    var substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            chainRuleSets: this.parseListOfLists(function () {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc),\n                };\n            }),\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            backtrackClassDef: this.parsePointer(Parser.classDef),\n            inputClassDef: this.parsePointer(Parser.classDef),\n            lookaheadClassDef: this.parsePointer(Parser.classDef),\n            chainClassSet: this.parseListOfLists(function () {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc),\n                };\n            }),\n        };\n    } else if (substFormat === 3) {\n        return {\n            substFormat: 3,\n            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(lookupRecordDesc),\n        };\n    }\n    check.assert(\n        false,\n        '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.'\n    );\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\nsubtableParsers$1[7] = function parseLookup7() {\n    // Extension Substitution subtable\n    var substFormat = this.parseUShort();\n    check.argument(\n        substFormat === 1,\n        'GSUB Extension Substitution subtable identifier-format must be 1'\n    );\n    var extensionLookupType = this.parseUShort();\n    var extensionParser = new Parser(\n        this.data,\n        this.offset + this.parseULong()\n    );\n    return {\n        substFormat: 1,\n        lookupType: extensionLookupType,\n        extension: subtableParsers$1[extensionLookupType].call(extensionParser),\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\nsubtableParsers$1[8] = function parseLookup8() {\n    var substFormat = this.parseUShort();\n    check.argument(\n        substFormat === 1,\n        'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1'\n    );\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        substitutes: this.parseUShortList(),\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/gsub.htm\nfunction parseGsubTable(data, start) {\n    start = start || 0;\n    var p = new Parser(data, start);\n    var tableVersion = p.parseVersion(1);\n    check.argument(\n        tableVersion === 1 || tableVersion === 1.1,\n        'Unsupported GSUB table version.'\n    );\n    if (tableVersion === 1) {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1),\n        };\n    } else {\n        return {\n            version: tableVersion,\n            scripts: p.parseScriptList(),\n            features: p.parseFeatureList(),\n            lookups: p.parseLookupList(subtableParsers$1),\n            variations: p.parseFeatureVariationsList(),\n        };\n    }\n}\n\nvar gsub = { parse: parseGsubTable };\n\n// The `head` table contains global information about the font.\n\n// Parse the header `head` table\nfunction parseHeadTable(data, start) {\n    var head = {};\n    var p = new parse.Parser(data, start);\n    head.version = p.parseVersion();\n    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n    head.checkSumAdjustment = p.parseULong();\n    head.magicNumber = p.parseULong();\n    check.argument(\n        head.magicNumber === 0x5f0f3cf5,\n        'Font header has wrong magic number.'\n    );\n    head.flags = p.parseUShort();\n    head.unitsPerEm = p.parseUShort();\n    head.created = p.parseLongDateTime();\n    head.modified = p.parseLongDateTime();\n    head.xMin = p.parseShort();\n    head.yMin = p.parseShort();\n    head.xMax = p.parseShort();\n    head.yMax = p.parseShort();\n    head.macStyle = p.parseUShort();\n    head.lowestRecPPEM = p.parseUShort();\n    head.fontDirectionHint = p.parseShort();\n    head.indexToLocFormat = p.parseShort();\n    head.glyphDataFormat = p.parseShort();\n    return head;\n}\n\nvar head = { parse: parseHeadTable };\n\n// The `hhea` table contains information for horizontal layout.\n\n// Parse the horizontal header `hhea` table\nfunction parseHheaTable(data, start) {\n    var hhea = {};\n    var p = new parse.Parser(data, start);\n    hhea.version = p.parseVersion();\n    hhea.ascender = p.parseShort();\n    hhea.descender = p.parseShort();\n    hhea.lineGap = p.parseShort();\n    hhea.advanceWidthMax = p.parseUShort();\n    hhea.minLeftSideBearing = p.parseShort();\n    hhea.minRightSideBearing = p.parseShort();\n    hhea.xMaxExtent = p.parseShort();\n    hhea.caretSlopeRise = p.parseShort();\n    hhea.caretSlopeRun = p.parseShort();\n    hhea.caretOffset = p.parseShort();\n    p.relativeOffset += 8;\n    hhea.metricDataFormat = p.parseShort();\n    hhea.numberOfHMetrics = p.parseUShort();\n    return hhea;\n}\n\nvar hhea = { parse: parseHheaTable };\n\n// The `hmtx` table contains the horizontal metrics for all glyphs.\n\nfunction parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        var glyph = glyphs.get(i);\n        glyph.advanceWidth = advanceWidth;\n        glyph.leftSideBearing = leftSideBearing;\n    }\n}\n\nfunction parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {\n    font._hmtxTableData = {};\n\n    var advanceWidth;\n    var leftSideBearing;\n    var p = new parse.Parser(data, start);\n    for (var i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        font._hmtxTableData[i] = {\n            advanceWidth: advanceWidth,\n            leftSideBearing: leftSideBearing,\n        };\n    }\n}\n\n// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\nfunction parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {\n    if (opt.lowMemory)\n        { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }\n    else { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }\n}\n\nvar hmtx = { parse: parseHmtxTable };\n\n// The `kern` table contains kerning pairs.\n\nfunction parseWindowsKernTable(p) {\n    var pairs = {};\n    // Skip nTables.\n    p.skip('uShort');\n    var subtableVersion = p.parseUShort();\n    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');\n    // Skip subtableLength, subtableCoverage\n    p.skip('uShort', 2);\n    var nPairs = p.parseUShort();\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n    for (var i = 0; i < nPairs; i += 1) {\n        var leftIndex = p.parseUShort();\n        var rightIndex = p.parseUShort();\n        var value = p.parseShort();\n        pairs[leftIndex + ',' + rightIndex] = value;\n    }\n    return pairs;\n}\n\nfunction parseMacKernTable(p) {\n    var pairs = {};\n    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n    // Skip the rest.\n    p.skip('uShort');\n    var nTables = p.parseULong();\n    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n    if (nTables > 1) {\n        console.warn('Only the first kern subtable is supported.');\n    }\n    p.skip('uLong');\n    var coverage = p.parseUShort();\n    var subtableVersion = coverage & 0xFF;\n    p.skip('uShort');\n    if (subtableVersion === 0) {\n        var nPairs = p.parseUShort();\n        // Skip searchRange, entrySelector, rangeShift.\n        p.skip('uShort', 3);\n        for (var i = 0; i < nPairs; i += 1) {\n            var leftIndex = p.parseUShort();\n            var rightIndex = p.parseUShort();\n            var value = p.parseShort();\n            pairs[leftIndex + ',' + rightIndex] = value;\n        }\n    }\n    return pairs;\n}\n\n// Parse the `kern` table which contains kerning pairs.\nfunction parseKernTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseUShort();\n    if (tableVersion === 0) {\n        return parseWindowsKernTable(p);\n    } else if (tableVersion === 1) {\n        return parseMacKernTable(p);\n    } else {\n        throw new Error('Unsupported kern table version (' + tableVersion + ').');\n    }\n}\n\nvar kern = { parse: parseKernTable };\n\n// The `ltag` table stores IETF BCP-47 language tags. It allows supporting\n\nfunction parseLtagTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported ltag table version.');\n    // The 'ltag' specification does not define any flags; skip the field.\n    p.skip('uLong', 1);\n    var numTags = p.parseULong();\n\n    var tags = [];\n    for (var i = 0; i < numTags; i++) {\n        var tag = '';\n        var offset = start + p.parseUShort();\n        var length = p.parseUShort();\n        for (var j = offset; j < offset + length; ++j) {\n            tag += String.fromCharCode(data.getInt8(j));\n        }\n\n        tags.push(tag);\n    }\n\n    return tags;\n}\n\nvar ltag = { parse: parseLtagTable };\n\n// The `loca` table stores the offsets to the locations of the glyphs in the font.\n\n// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n// relative to the beginning of the glyphData table.\n// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n// The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n// version where offsets are stored as uLongs. The `head` table specifies which version to use\n// (under indexToLocFormat).\nfunction parseLocaTable(data, start, numGlyphs, shortVersion) {\n    var p = new parse.Parser(data, start);\n    var parseFn = shortVersion ? p.parseUShort : p.parseULong;\n    // There is an extra entry after the last index element to compute the length of the last glyph.\n    // That's why we use numGlyphs + 1.\n    var glyphOffsets = [];\n    for (var i = 0; i < numGlyphs + 1; i += 1) {\n        var glyphOffset = parseFn.call(p);\n        if (shortVersion) {\n            // The short table version stores the actual offset divided by 2.\n            glyphOffset *= 2;\n        }\n\n        glyphOffsets.push(glyphOffset);\n    }\n\n    return glyphOffsets;\n}\n\nvar loca = { parse: parseLocaTable };\n\n// The `maxp` table establishes the memory requirements for the font.\n\n// Parse the maximum profile `maxp` table.\nfunction parseMaxpTable(data, start) {\n    var maxp = {};\n    var p = new parse.Parser(data, start);\n    maxp.version = p.parseVersion();\n    maxp.numGlyphs = p.parseUShort();\n    if (maxp.version === 1.0) {\n        maxp.maxPoints = p.parseUShort();\n        maxp.maxContours = p.parseUShort();\n        maxp.maxCompositePoints = p.parseUShort();\n        maxp.maxCompositeContours = p.parseUShort();\n        maxp.maxZones = p.parseUShort();\n        maxp.maxTwilightPoints = p.parseUShort();\n        maxp.maxStorage = p.parseUShort();\n        maxp.maxFunctionDefs = p.parseUShort();\n        maxp.maxInstructionDefs = p.parseUShort();\n        maxp.maxStackElements = p.parseUShort();\n        maxp.maxSizeOfInstructions = p.parseUShort();\n        maxp.maxComponentElements = p.parseUShort();\n        maxp.maxComponentDepth = p.parseUShort();\n    }\n\n    return maxp;\n}\n\nvar maxp = { parse: parseMaxpTable };\n\n// The `OS/2` table contains metrics required in OpenType fonts.\n\n// Parse the OS/2 and Windows metrics `OS/2` table\nfunction parseOS2Table(data, start) {\n    var os2 = {};\n    var p = new parse.Parser(data, start);\n    os2.version = p.parseUShort();\n    os2.xAvgCharWidth = p.parseShort();\n    os2.usWeightClass = p.parseUShort();\n    os2.usWidthClass = p.parseUShort();\n    os2.fsType = p.parseUShort();\n    os2.ySubscriptXSize = p.parseShort();\n    os2.ySubscriptYSize = p.parseShort();\n    os2.ySubscriptXOffset = p.parseShort();\n    os2.ySubscriptYOffset = p.parseShort();\n    os2.ySuperscriptXSize = p.parseShort();\n    os2.ySuperscriptYSize = p.parseShort();\n    os2.ySuperscriptXOffset = p.parseShort();\n    os2.ySuperscriptYOffset = p.parseShort();\n    os2.yStrikeoutSize = p.parseShort();\n    os2.yStrikeoutPosition = p.parseShort();\n    os2.sFamilyClass = p.parseShort();\n    os2.panose = [];\n    for (var i = 0; i < 10; i++) {\n        os2.panose[i] = p.parseByte();\n    }\n\n    os2.ulUnicodeRange1 = p.parseULong();\n    os2.ulUnicodeRange2 = p.parseULong();\n    os2.ulUnicodeRange3 = p.parseULong();\n    os2.ulUnicodeRange4 = p.parseULong();\n    os2.achVendID = String.fromCharCode(\n        p.parseByte(),\n        p.parseByte(),\n        p.parseByte(),\n        p.parseByte()\n    );\n    os2.fsSelection = p.parseUShort();\n    os2.usFirstCharIndex = p.parseUShort();\n    os2.usLastCharIndex = p.parseUShort();\n    os2.sTypoAscender = p.parseShort();\n    os2.sTypoDescender = p.parseShort();\n    os2.sTypoLineGap = p.parseShort();\n    os2.usWinAscent = p.parseUShort();\n    os2.usWinDescent = p.parseUShort();\n    if (os2.version >= 1) {\n        os2.ulCodePageRange1 = p.parseULong();\n        os2.ulCodePageRange2 = p.parseULong();\n    }\n\n    if (os2.version >= 2) {\n        os2.sxHeight = p.parseShort();\n        os2.sCapHeight = p.parseShort();\n        os2.usDefaultChar = p.parseUShort();\n        os2.usBreakChar = p.parseUShort();\n        os2.usMaxContent = p.parseUShort();\n    }\n\n    return os2;\n}\n\nvar os2 = { parse: parseOS2Table };\n\n// The `post` table stores additional PostScript information, such as glyph names.\n\n// Parse the PostScript `post` table\nfunction parsePostTable(data, start) {\n    var post = {};\n    var p = new parse.Parser(data, start);\n    post.version = p.parseVersion();\n    post.italicAngle = p.parseFixed();\n    post.underlinePosition = p.parseShort();\n    post.underlineThickness = p.parseShort();\n    post.isFixedPitch = p.parseULong();\n    post.minMemType42 = p.parseULong();\n    post.maxMemType42 = p.parseULong();\n    post.minMemType1 = p.parseULong();\n    post.maxMemType1 = p.parseULong();\n    post.names = [];\n    switch (post.version) {\n        case 1:\n            break;\n        case 2:\n            post.numberOfGlyphs = p.parseUShort();\n            post.glyphNameIndex = new Array(post.numberOfGlyphs);\n            for (var i = 0; i < post.numberOfGlyphs; i++) {\n                post.glyphNameIndex[i] = p.parseUShort();\n            }\n            break;\n        case 2.5:\n            post.numberOfGlyphs = p.parseUShort();\n            post.offset = new Array(post.numberOfGlyphs);\n            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n                post.offset[i$1] = p.parseChar();\n            }\n            break;\n    }\n    return post;\n}\n\nvar post = { parse: parsePostTable };\n\n// Data types used in the OpenType font file.\n\n/**\n * @exports opentype.decode\n * @class\n */\nvar decode = {};\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF8 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes;\n    for (var j = 0; j < numChars; j++, offset += 1) {\n        codePoints[j] = data.getUint8(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF16 = function(data, offset, numBytes) {\n    var codePoints = [];\n    var numChars = numBytes / 2;\n    for (var j = 0; j < numChars; j++, offset += 2) {\n        codePoints[j] = data.getUint16(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n// Data for converting old eight-bit Macintosh encodings to Unicode.\n// This representation is optimized for decoding; encoding is slower\n// and needs more memory. The assumption is that all opentype.js users\n// want to open fonts, but saving a font will be comparatively rare\n// so it can be more expensive. Keyed by IANA character set name.\n//\n// Python script for generating these strings:\n//\n//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n//     print(s.encode('utf-8'))\n/**\n * @private\n */\nvar eightBitMacEncodings = {\n    'x-mac-croatian':  // Python: 'mac_croatian'\n    'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Å â¢Â´Â¨â Å½ÃâÂ±â¤â¥âÂµâââÅ¡â«ÂªÂºÎ©Å¾Ã¸' +\n    'Â¿Â¡Â¬âÆâÄÂ«Äâ¦Â ÃÃÃÅÅÄâââââÃ·âï£¿Â©ââ¬â¹âºÃÂ»âÂ·âââ°ÃÄÃÄÃÃÃÃÃÃÃÄÃÃÃÃÄ±ËËÂ¯ÏÃËÂ¸ÃÃ¦Ë',\n    'x-mac-cyrillic':  // Python: 'mac_cyrillic'\n    'ÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â Â°ÒÂ£Â§â¢Â¶ÐÂ®Â©â¢ÐÑâ ÐÑâÂ±â¤â¥ÑÂµÒÐÐÑÐÑÐÑÐÑ' +\n    'ÑÐÂ¬âÆââÂ«Â»â¦Â ÐÑÐÑÑââââââÃ·âÐÑÐÑâÐÑÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ',\n    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n    'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃá¸Â±â¤â¥á¸ÄÄá¸á¸á¸á¸Ä Ä¡á¹Ã¦Ã¸' +\n    'á¹á¹á¹É¼ÆÅ¿á¹ Â«Â»â¦Â ÃÃÃÅÅââââââá¹¡áºÃ¿Å¸á¹ªâ¬â¹âºÅ¶Å·á¹«Â·á»²á»³âÃÃÃÃÃÃÃÃÃÃÃâ£ÃÃÃÃÄ±ÃÃ½Å´Åµáºáºáºáºáºáº',\n    'x-mac-greek':  // Python: 'mac_greek'\n    'ÃÂ¹Â²ÃÂ³ÃÃÎÃ Ã¢Ã¤ÎÂ¨Ã§Ã©Ã¨ÃªÃ«Â£â¢Ã®Ã¯â¢Â½â°Ã´Ã¶Â¦â¬Ã¹Ã»Ã¼â ÎÎÎÎÎÎ ÃÂ®Â©Î£ÎªÂ§â Â°Â·ÎÂ±â¤â¥Â¥ÎÎÎÎÎÎÎÎ¦Î«Î¨Î©' +\n    'Î¬ÎÂ¬ÎÎ¡âÎ¤Â«Â»â¦Â Î¥Î§ÎÎÅââââââÃ·ÎÎÎÎÎ­Î®Î¯ÏÎÏÎ±Î²ÏÎ´ÎµÏÎ³Î·Î¹Î¾ÎºÎ»Î¼Î½Î¿ÏÏÏÏÏÎ¸ÏÏÏÏÎ¶ÏÏÎÎ°\\u00AD',\n    'x-mac-icelandic':  // Python: 'mac_iceland'\n    'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼ÃÂ°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºÎ©Ã¦Ã¸' +\n    'Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸ââ¬ÃÃ°ÃÃ¾Ã½Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï£¿ÃÃÃÃÄ±ËËÂ¯ËËËÂ¸ËËË',\n    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n    'ááááááá±á²á³á´á¸á¹áááááááá¦á­á®á¯á°á²á³áááááááÂ°á¡á¥á¦â¢Â¶á§Â®Â©â¢á¨áªá«á»áááááááá¯á°á±á²á´áµáááá' +\n    'ááááªá¨á©áªá«á­â¦Â á®á¾áááââââââáááááááááááá¿áááááááááááááá±á²á³á´áµá¶áá á¡á¢á£á¤á¥á¦á¼ÅÅ',\n    'x-mac-ce':  // Python: 'mac_latin2'\n    'ÃÄÄÃÄÃÃÃ¡ÄÄÃ¤ÄÄÄÃ©Å¹ÅºÄÃ­ÄÄÄÄÃ³ÄÃ´Ã¶ÃµÃºÄÄÃ¼â Â°ÄÂ£Â§â¢Â¶ÃÂ®Â©â¢ÄÂ¨â Ä£Ä®Ä¯Äªâ¤â¥Ä«Ä¶ââÅÄ»Ä¼Ä½Ä¾Ä¹ÄºÅ' +\n    'ÅÅÂ¬âÅÅâÂ«Â»â¦Â ÅÅÃÅÅââââââÃ·âÅÅÅÅâ¹âºÅÅÅÅ ââÅ¡ÅÅÃÅ¤Å¥ÃÅ½Å¾ÅªÃÃÅ«Å®ÃÅ¯Å°Å±Å²Å³ÃÃ½Ä·Å»ÅÅ¼Ä¢Ë',\n    macintosh:  // Python: 'mac_roman'\n    'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºÎ©Ã¦Ã¸' +\n    'Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸ââ¬â¹âºï¬ï¬â¡Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï£¿ÃÃÃÃÄ±ËËÂ¯ËËËÂ¸ËËË',\n    'x-mac-romanian':  // Python: 'mac_romanian'\n    'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÄÈâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºÎ©ÄÈ' +\n    'Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸ââ¬â¹âºÈÈâ¡Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï£¿ÃÃÃÃÄ±ËËÂ¯ËËËÂ¸ËËË',\n    'x-mac-turkish':  // Python: 'mac_turkish'\n    'ÃÃÃÃÃÃÃÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â Â°Â¢Â£Â§â¢Â¶ÃÂ®Â©â¢Â´Â¨â ÃÃâÂ±â¤â¥Â¥ÂµâââÏâ«ÂªÂºÎ©Ã¦Ã¸' +\n    'Â¿Â¡Â¬âÆââÂ«Â»â¦Â ÃÃÃÅÅââââââÃ·âÃ¿Å¸ÄÄÄ°Ä±ÅÅâ¡Â·âââ°ÃÃÃÃÃÃÃÃÃÃÃï£¿ÃÃÃÃï¢ ËËÂ¯ËËËÂ¸ËËË'\n};\n\n/**\n * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n * string, or 'undefined' if the encoding is unsupported. For example, we do\n * not support Chinese, Japanese or Korean because these would need large\n * mapping tables.\n * @param {DataView} dataView\n * @param {number} offset\n * @param {number} dataLength\n * @param {string} encoding\n * @returns {string}\n */\ndecode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n    var table = eightBitMacEncodings[encoding];\n    if (table === undefined) {\n        return undefined;\n    }\n\n    var result = '';\n    for (var i = 0; i < dataLength; i++) {\n        var c = dataView.getUint8(offset + i);\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c <= 0x7F) {\n            result += String.fromCharCode(c);\n        } else {\n            result += table[c & 0x7F];\n        }\n    }\n\n    return result;\n};\n\n// The `GPOS` table contains kerning pairs, among other things.\n\n// Parse the metadata `meta` table.\n// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\nfunction parseMetaTable(data, start) {\n    var p = new parse.Parser(data, start);\n    var tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported META table version.');\n    p.parseULong(); // flags - currently unused and set to 0\n    p.parseULong(); // tableOffset\n    var numDataMaps = p.parseULong();\n\n    var tags = {};\n    for (var i = 0; i < numDataMaps; i++) {\n        var tag = p.parseTag();\n        var dataOffset = p.parseULong();\n        var dataLength = p.parseULong();\n        var text = decode.UTF8(data, start + dataOffset, dataLength);\n\n        tags[tag] = text;\n    }\n    return tags;\n}\n\nvar meta = { parse: parseMetaTable };\n\n// opentype.js\n\n/**\n * The opentype library.\n * @namespace opentype\n */\n\n// Table Directory Entries //////////////////////////////////////////////\n/**\n * Parses OpenType table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseOpenTypeTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 12;\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var checksum = parse.getULong(data, p + 4);\n        var offset = parse.getULong(data, p + 8);\n        var length = parse.getULong(data, p + 12);\n        tableEntries.push({\n            tag: tag,\n            checksum: checksum,\n            offset: offset,\n            length: length,\n            compression: false,\n        });\n        p += 16;\n    }\n\n    return tableEntries;\n}\n\n/**\n * Parses WOFF table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseWOFFTableEntries(data, numTables) {\n    var tableEntries = [];\n    var p = 44; // offset to the first table directory entry.\n    for (var i = 0; i < numTables; i += 1) {\n        var tag = parse.getTag(data, p);\n        var offset = parse.getULong(data, p + 4);\n        var compLength = parse.getULong(data, p + 8);\n        var origLength = parse.getULong(data, p + 12);\n        var compression = (void 0);\n        if (compLength < origLength) {\n            compression = 'WOFF';\n        } else {\n            compression = false;\n        }\n\n        tableEntries.push({\n            tag: tag,\n            offset: offset,\n            compression: compression,\n            compressedLength: compLength,\n            length: origLength,\n        });\n        p += 20;\n    }\n\n    return tableEntries;\n}\n\n/**\n * @typedef TableData\n * @type Object\n * @property {DataView} data - The DataView\n * @property {number} offset - The data offset.\n */\n\n/**\n * @param  {DataView}\n * @param  {Object}\n * @return {TableData}\n */\nfunction uncompressTable(data, tableEntry) {\n    if (tableEntry.compression === 'WOFF') {\n        var inBuffer = new Uint8Array(\n            data.buffer,\n            tableEntry.offset + 2,\n            tableEntry.compressedLength - 2\n        );\n        var outBuffer = new Uint8Array(tableEntry.length);\n        inflateSync(inBuffer, outBuffer);\n        if (outBuffer.byteLength !== tableEntry.length) {\n            throw new Error(\n                'Decompression error: ' +\n                    tableEntry.tag +\n                    \" decompressed length doesn't match recorded length\"\n            );\n        }\n\n        var view = new DataView(outBuffer.buffer, 0);\n        return { data: view, offset: 0 };\n    } else {\n        return { data: data, offset: tableEntry.offset };\n    }\n}\n\n// Public API ///////////////////////////////////////////////////////////\n\n/**\n * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n * Throws an error if the font could not be parsed.\n * @param  {ArrayBuffer}\n * @param  {Object} opt - options for parsing\n * @return {opentype.Font}\n */\nfunction parseBuffer(buffer, opt) {\n    opt = opt === undefined || opt === null ? {} : opt;\n\n    var indexToLocFormat;\n\n    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n    // should be an empty font that we'll fill with our own data.\n    var font = new Font({ empty: true });\n\n    // OpenType fonts use big endian byte ordering.\n    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n    // Instead we use DataViews where we can specify endianness.\n    var data = new DataView(buffer, 0);\n    var numTables;\n    var tableEntries = [];\n    var signature = parse.getTag(data, 0);\n    if (\n        signature === String.fromCharCode(0, 1, 0, 0) ||\n        signature === 'true' ||\n        signature === 'typ1'\n    ) {\n        font.outlinesFormat = 'truetype';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'OTTO') {\n        font.outlinesFormat = 'cff';\n        numTables = parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'wOFF') {\n        var flavor = parse.getTag(data, 4);\n        if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n            font.outlinesFormat = 'truetype';\n        } else if (flavor === 'OTTO') {\n            font.outlinesFormat = 'cff';\n        } else {\n            throw new Error('Unsupported OpenType flavor ' + signature);\n        }\n\n        numTables = parse.getUShort(data, 12);\n        tableEntries = parseWOFFTableEntries(data, numTables);\n    } else {\n        throw new Error('Unsupported OpenType signature ' + signature);\n    }\n\n    var cffTableEntry;\n    var fvarTableEntry;\n    var glyfTableEntry;\n    var gdefTableEntry;\n    var gposTableEntry;\n    var gsubTableEntry;\n    var hmtxTableEntry;\n    var kernTableEntry;\n    var locaTableEntry;\n    var metaTableEntry;\n    var p;\n\n    for (var i = 0; i < numTables; i += 1) {\n        var tableEntry = tableEntries[i];\n        var table = (void 0);\n        switch (tableEntry.tag) {\n            case 'cmap':\n                table = uncompressTable(data, tableEntry);\n                font.tables.cmap = cmap.parse(table.data, table.offset);\n                font.encoding = new CmapEncoding(font.tables.cmap);\n                break;\n            case 'cvt ':\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n                break;\n            case 'fvar':\n                fvarTableEntry = tableEntry;\n                break;\n            case 'fpgm':\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.fpgm = p.parseByteList(tableEntry.length);\n                break;\n            case 'head':\n                table = uncompressTable(data, tableEntry);\n                font.tables.head = head.parse(table.data, table.offset);\n                font.unitsPerEm = font.tables.head.unitsPerEm;\n                indexToLocFormat = font.tables.head.indexToLocFormat;\n                break;\n            case 'hhea':\n                table = uncompressTable(data, tableEntry);\n                font.tables.hhea = hhea.parse(table.data, table.offset);\n                font.ascender = font.tables.hhea.ascender;\n                font.descender = font.tables.hhea.descender;\n                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n                break;\n            case 'hmtx':\n                hmtxTableEntry = tableEntry;\n                break;\n            case 'ltag':\n                table = uncompressTable(data, tableEntry);\n                ltagTable = ltag.parse(table.data, table.offset);\n                break;\n            case 'maxp':\n                table = uncompressTable(data, tableEntry);\n                font.tables.maxp = maxp.parse(table.data, table.offset);\n                font.numGlyphs = font.tables.maxp.numGlyphs;\n                break;\n            case 'OS/2':\n                table = uncompressTable(data, tableEntry);\n                font.tables.os2 = os2.parse(table.data, table.offset);\n                break;\n            case 'post':\n                table = uncompressTable(data, tableEntry);\n                font.tables.post = post.parse(table.data, table.offset);\n                break;\n            case 'prep':\n                table = uncompressTable(data, tableEntry);\n                p = new parse.Parser(table.data, table.offset);\n                font.tables.prep = p.parseByteList(tableEntry.length);\n                break;\n            case 'glyf':\n                glyfTableEntry = tableEntry;\n                break;\n            case 'loca':\n                locaTableEntry = tableEntry;\n                break;\n            case 'CFF ':\n                cffTableEntry = tableEntry;\n                break;\n            case 'kern':\n                kernTableEntry = tableEntry;\n                break;\n            case 'GDEF':\n                gdefTableEntry = tableEntry;\n                break;\n            case 'GPOS':\n                gposTableEntry = tableEntry;\n                break;\n            case 'GSUB':\n                gsubTableEntry = tableEntry;\n                break;\n            case 'meta':\n                metaTableEntry = tableEntry;\n                break;\n        }\n    }\n\n    if (glyfTableEntry && locaTableEntry) {\n        var shortVersion = indexToLocFormat === 0;\n        var locaTable = uncompressTable(data, locaTableEntry);\n        var locaOffsets = loca.parse(\n            locaTable.data,\n            locaTable.offset,\n            font.numGlyphs,\n            shortVersion\n        );\n        var glyfTable = uncompressTable(data, glyfTableEntry);\n        font.glyphs = glyf.parse(\n            glyfTable.data,\n            glyfTable.offset,\n            locaOffsets,\n            font,\n            opt\n        );\n    } else if (cffTableEntry) {\n        var cffTable = uncompressTable(data, cffTableEntry);\n        cff.parse(cffTable.data, cffTable.offset, font, opt);\n    } else {\n        throw new Error(\"Font doesn't contain TrueType or CFF outlines.\");\n    }\n\n    var hmtxTable = uncompressTable(data, hmtxTableEntry);\n    hmtx.parse(\n        font,\n        hmtxTable.data,\n        hmtxTable.offset,\n        font.numberOfHMetrics,\n        font.numGlyphs,\n        font.glyphs,\n        opt\n    );\n    addGlyphNames(font, opt);\n\n    if (kernTableEntry) {\n        var kernTable = uncompressTable(data, kernTableEntry);\n        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n    } else {\n        font.kerningPairs = {};\n    }\n\n    if (gdefTableEntry) {\n        var gdefTable = uncompressTable(data, gdefTableEntry);\n        font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);\n    }\n\n    if (gposTableEntry) {\n        var gposTable = uncompressTable(data, gposTableEntry);\n        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);\n        font.position.init();\n    }\n\n    if (gsubTableEntry) {\n        var gsubTable = uncompressTable(data, gsubTableEntry);\n        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n    }\n\n    if (fvarTableEntry) {\n        var fvarTable = uncompressTable(data, fvarTableEntry);\n        font.tables.fvar = fvar.parse(\n            fvarTable.data,\n            fvarTable.offset,\n            font.names\n        );\n    }\n\n    if (metaTableEntry) {\n        var metaTable = uncompressTable(data, metaTableEntry);\n        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n        font.metas = font.tables.meta;\n    }\n\n    return font;\n}\n\nfunction load() {}\nfunction loadSync() {}\n\nvar opentype = /*#__PURE__*/Object.freeze({\n   __proto__: null,\n   Font: Font,\n   Glyph: Glyph,\n   Path: Path,\n   _parse: parse,\n   parse: parseBuffer,\n   load: load,\n   loadSync: loadSync\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (opentype);\n\n//# sourceMappingURL=opentype.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNodWRpbmcvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixNQUFNO0FBQ04sa0JBQWtCLFNBQVM7QUFDM0IsTUFBTTtBQUNOLGtCQUFrQixTQUFTO0FBQzNCLE1BQU07QUFDTixrQkFBa0IsU0FBUztBQUMzQixNQUFNO0FBQ047QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLGdDQUFnQyxvQ0FBb0M7QUFDcEUsZ0NBQWdDLG9DQUFvQztBQUNwRSxnQ0FBZ0Msb0NBQW9DO0FBQ3BFLGdDQUFnQyxvQ0FBb0M7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7O0FBRUEsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLG1DQUFtQztBQUNuQyxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2QsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtB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QUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLHFDQUFxQztBQUMzQyxNQUFNLG9DQUFvQztBQUMxQyxNQUFNLDBDQUEwQztBQUNoRCxNQUFNLHNDQUFzQztBQUM1QyxNQUFNLHdDQUF3QztBQUM5QyxNQUFNLG9DQUFvQztBQUMxQyxNQUFNLDBEQUEwRDtBQUNoRSxNQUFNLHlEQUF5RDtBQUMvRCxNQUFNLGtFQUFrRTtBQUN4RSxNQUFNLGlFQUFpRTtBQUN2RSxNQUFNLHVEQUF1RDtBQUM3RCxNQUFNLDREQUE0RDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU0sMENBQTBDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSxvREFBb0Q7QUFDMUQsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSxvRUFBb0U7QUFDMUUsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSw0REFBNEQ7QUFDbEUsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSw0Q0FBNEM7QUFDbEQsTUFBTSwwQ0FBMEM7O0FBRWhEO0FBQ0EsTUFBTSxpREFBaUQ7QUFDdkQsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSwwREFBMEQ7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQscUNBQXFDO0FBQ3JDLHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVDQUF1QztBQUN2Qyx1REFBdUQ7QUFDdkQsdUNBQXVDO0FBQ3ZDLHVEQUF1RDtBQUN2RCxxQ0FBcUM7QUFDckMscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVDQUF1QztBQUN2Qyx1REFBdUQ7QUFDdkQsdUNBQXVDO0FBQ3ZDLHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCOztBQUVoRDtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLGlCQUFpQjtBQUNqQixNQUFNO0FBQ047QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGlFQUFlLFFBQVEsRUFBQztBQUM0RDtBQUNwRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2h1ZGluZy9vcGVudHlwZS5qcy9kaXN0L29wZW50eXBlLm1vZHVsZS5qcz8yM2Y1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogaHR0cHM6Ly9vcGVudHlwZS5qcy5vcmcgdjEuMy41IHwgKGMpIEZyZWRlcmlrIERlIEJsZXNlciBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwgTUlUIExpY2Vuc2UgfCBVc2VzIGZmbGF0ZSBieSAxMDFhcnJvd3ogYW5kIHN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXQgcG9seWZpbGwgYnkgTWF0aGlhcyBCeW5lbnNcbiAqL1xuXG4vLyBERUZMQVRFIGlzIGEgY29tcGxleCBmb3JtYXQ7IHRvIHJlYWQgdGhpcyBjb2RlLCB5b3Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoZSBSRkMgZmlyc3Q6XG5cbi8vIGFsaWFzZXMgZm9yIHNob3J0ZXIgY29tcHJlc3NlZCBjb2RlIChtb3N0IG1pbmlmZXJzIGRvbid0IGRvIHRoaXMpXG52YXIgdTggPSBVaW50OEFycmF5LCB1MTYgPSBVaW50MTZBcnJheSwgdTMyID0gVWludDMyQXJyYXk7XG4vLyBmaXhlZCBsZW5ndGggZXh0cmEgYml0c1xudmFyIGZsZWIgPSBuZXcgdTgoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDAsIC8qIHVudXNlZCAqLyAwLCAwLCAvKiBpbXBvc3NpYmxlICovIDBdKTtcbi8vIGZpeGVkIGRpc3RhbmNlIGV4dHJhIGJpdHNcbi8vIHNlZSBmbGViIG5vdGVcbnZhciBmZGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTMsIC8qIHVudXNlZCAqLyAwLCAwXSk7XG4vLyBjb2RlIGxlbmd0aCBpbmRleCBtYXBcbnZhciBjbGltID0gbmV3IHU4KFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XSk7XG4vLyBnZXQgYmFzZSwgcmV2ZXJzZSBpbmRleCBtYXAgZnJvbSBleHRyYSBiaXRzXG52YXIgZnJlYiA9IGZ1bmN0aW9uIChlYiwgc3RhcnQpIHtcbiAgICB2YXIgYiA9IG5ldyB1MTYoMzEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzE7ICsraSkge1xuICAgICAgICBiW2ldID0gc3RhcnQgKz0gMSA8PCBlYltpIC0gMV07XG4gICAgfVxuICAgIC8vIG51bWJlcnMgaGVyZSBhcmUgYXQgbWF4IDE4IGJpdHNcbiAgICB2YXIgciA9IG5ldyB1MzIoYlszMF0pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMzA7ICsraSkge1xuICAgICAgICBmb3IgKHZhciBqID0gYltpXTsgaiA8IGJbaSArIDFdOyArK2opIHtcbiAgICAgICAgICAgIHJbal0gPSAoKGogLSBiW2ldKSA8PCA1KSB8IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtiLCByXTtcbn07XG52YXIgX2EgPSBmcmViKGZsZWIsIDIpLCBmbCA9IF9hWzBdLCByZXZmbCA9IF9hWzFdO1xuLy8gd2UgY2FuIGlnbm9yZSB0aGUgZmFjdCB0aGF0IHRoZSBvdGhlciBudW1iZXJzIGFyZSB3cm9uZzsgdGhleSBuZXZlciBoYXBwZW4gYW55d2F5XG5mbFsyOF0gPSAyNTgsIHJldmZsWzI1OF0gPSAyODtcbnZhciBfYiA9IGZyZWIoZmRlYiwgMCksIGZkID0gX2JbMF07XG4vLyBtYXAgb2YgdmFsdWUgdG8gcmV2ZXJzZSAoYXNzdW1pbmcgMTYgYml0cylcbnZhciByZXYgPSBuZXcgdTE2KDMyNzY4KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMzI3Njg7ICsraSkge1xuICAgIC8vIHJldmVyc2UgdGFibGUgYWxnb3JpdGhtIGZyb20gU09cbiAgICB2YXIgeCA9ICgoaSAmIDB4QUFBQSkgPj4+IDEpIHwgKChpICYgMHg1NTU1KSA8PCAxKTtcbiAgICB4ID0gKCh4ICYgMHhDQ0NDKSA+Pj4gMikgfCAoKHggJiAweDMzMzMpIDw8IDIpO1xuICAgIHggPSAoKHggJiAweEYwRjApID4+PiA0KSB8ICgoeCAmIDB4MEYwRikgPDwgNCk7XG4gICAgcmV2W2ldID0gKCgoeCAmIDB4RkYwMCkgPj4+IDgpIHwgKCh4ICYgMHgwMEZGKSA8PCA4KSkgPj4+IDE7XG59XG4vLyBjcmVhdGUgaHVmZm1hbiB0cmVlIGZyb20gdTggXCJtYXBcIjogaW5kZXggLT4gY29kZSBsZW5ndGggZm9yIGNvZGUgaW5kZXhcbi8vIG1iIChtYXggYml0cykgbXVzdCBiZSBhdCBtb3N0IDE1XG4vLyBUT0RPOiBvcHRpbWl6ZS9zcGxpdCB1cD9cbnZhciBoTWFwID0gKGZ1bmN0aW9uIChjZCwgbWIsIHIpIHtcbiAgICB2YXIgcyA9IGNkLmxlbmd0aDtcbiAgICAvLyBpbmRleFxuICAgIHZhciBpID0gMDtcbiAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gIyBvZiBjb2RlcyB3aXRoIGJpdCBsZW5ndGggPSBpbmRleFxuICAgIHZhciBsID0gbmV3IHUxNihtYik7XG4gICAgLy8gbGVuZ3RoIG9mIGNkIG11c3QgYmUgMjg4ICh0b3RhbCAjIG9mIGNvZGVzKVxuICAgIGZvciAoOyBpIDwgczsgKytpKSB7XG4gICAgICAgIGlmIChjZFtpXSlcbiAgICAgICAgICAgIHsgKytsW2NkW2ldIC0gMV07IH1cbiAgICB9XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG1pbmltdW0gY29kZSBmb3IgYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGxlID0gbmV3IHUxNihtYik7XG4gICAgZm9yIChpID0gMDsgaSA8IG1iOyArK2kpIHtcbiAgICAgICAgbGVbaV0gPSAobGVbaSAtIDFdICsgbFtpIC0gMV0pIDw8IDE7XG4gICAgfVxuICAgIHZhciBjbztcbiAgICBpZiAocikge1xuICAgICAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbnVtYmVyIG9mIGFjdHVhbCBiaXRzLCBzeW1ib2wgZm9yIGNvZGVcbiAgICAgICAgY28gPSBuZXcgdTE2KDEgPDwgbWIpO1xuICAgICAgICAvLyBiaXRzIHRvIHJlbW92ZSBmb3IgcmV2ZXJzZXJcbiAgICAgICAgdmFyIHJ2YiA9IDE1IC0gbWI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSAwIGxlbmd0aHNcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIC8vIG51bSBlbmNvZGluZyBib3RoIHN5bWJvbCBhbmQgYml0cyByZWFkXG4gICAgICAgICAgICAgICAgdmFyIHN2ID0gKGkgPDwgNCkgfCBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBmcmVlIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgcl8xID0gbWIgLSBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciB2ID0gbGVbY2RbaV0gLSAxXSsrIDw8IHJfMTtcbiAgICAgICAgICAgICAgICAvLyBtIGlzIGVuZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSB2IHwgKCgxIDw8IHJfMSkgLSAxKTsgdiA8PSBtOyArK3YpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlcnkgMTYgYml0IHZhbHVlIHN0YXJ0aW5nIHdpdGggdGhlIGNvZGUgeWllbGRzIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBjb1tyZXZbdl0gPj4+IHJ2Yl0gPSBzdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvID0gbmV3IHUxNihzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgICAgICAgY29baV0gPSByZXZbbGVbY2RbaV0gLSAxXSsrXSA+Pj4gKDE1IC0gY2RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbztcbn0pO1xuLy8gZml4ZWQgbGVuZ3RoIHRyZWVcbnZhciBmbHQgPSBuZXcgdTgoMjg4KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMTQ0OyArK2kpXG4gICAgeyBmbHRbaV0gPSA4OyB9XG5mb3IgKHZhciBpID0gMTQ0OyBpIDwgMjU2OyArK2kpXG4gICAgeyBmbHRbaV0gPSA5OyB9XG5mb3IgKHZhciBpID0gMjU2OyBpIDwgMjgwOyArK2kpXG4gICAgeyBmbHRbaV0gPSA3OyB9XG5mb3IgKHZhciBpID0gMjgwOyBpIDwgMjg4OyArK2kpXG4gICAgeyBmbHRbaV0gPSA4OyB9XG4vLyBmaXhlZCBkaXN0YW5jZSB0cmVlXG52YXIgZmR0ID0gbmV3IHU4KDMyKTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMzI7ICsraSlcbiAgICB7IGZkdFtpXSA9IDU7IH1cbi8vIGZpeGVkIGxlbmd0aCBtYXBcbnZhciBmbHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBtYXBcbnZhciBmZHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZkdCwgNSwgMSk7XG4vLyBmaW5kIG1heCBvZiBhcnJheVxudmFyIG1heCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIG0gPSBhWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYVtpXSA+IG0pXG4gICAgICAgICAgICB7IG0gPSBhW2ldOyB9XG4gICAgfVxuICAgIHJldHVybiBtO1xufTtcbi8vIHJlYWQgZCwgc3RhcnRpbmcgYXQgYml0IHAgYW5kIG1hc2sgd2l0aCBtXG52YXIgYml0cyA9IGZ1bmN0aW9uIChkLCBwLCBtKSB7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICByZXR1cm4gKChkW29dIHwgKGRbbyArIDFdIDw8IDgpKSA+PiAocCAmIDcpKSAmIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBjb250aW51aW5nIGZvciBhdCBsZWFzdCAxNiBiaXRzXG52YXIgYml0czE2ID0gZnVuY3Rpb24gKGQsIHApIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkgfCAoZFtvICsgMl0gPDwgMTYpKSA+PiAocCAmIDcpKTtcbn07XG4vLyBnZXQgZW5kIG9mIGJ5dGVcbnZhciBzaGZ0ID0gZnVuY3Rpb24gKHApIHsgcmV0dXJuICgocCArIDcpIC8gOCkgfCAwOyB9O1xuLy8gdHlwZWQgYXJyYXkgc2xpY2UgLSBhbGxvd3MgZ2FyYmFnZSBjb2xsZWN0b3IgdG8gZnJlZSBvcmlnaW5hbCByZWZlcmVuY2UsXG4vLyB3aGlsZSBiZWluZyBtb3JlIGNvbXBhdGlibGUgdGhhbiAuc2xpY2VcbnZhciBzbGMgPSBmdW5jdGlvbiAodiwgcywgZSkge1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApXG4gICAgICAgIHsgcyA9IDA7IH1cbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPiB2Lmxlbmd0aClcbiAgICAgICAgeyBlID0gdi5sZW5ndGg7IH1cbiAgICAvLyBjYW4ndCB1c2UgLmNvbnN0cnVjdG9yIGluIGNhc2UgdXNlci1zdXBwbGllZFxuICAgIHZhciBuID0gbmV3ICh2LkJZVEVTX1BFUl9FTEVNRU5UID09IDIgPyB1MTYgOiB2LkJZVEVTX1BFUl9FTEVNRU5UID09IDQgPyB1MzIgOiB1OCkoZSAtIHMpO1xuICAgIG4uc2V0KHYuc3ViYXJyYXkocywgZSkpO1xuICAgIHJldHVybiBuO1xufTtcbi8vIGVycm9yIGNvZGVzXG52YXIgZWMgPSBbXG4gICAgJ3VuZXhwZWN0ZWQgRU9GJyxcbiAgICAnaW52YWxpZCBibG9jayB0eXBlJyxcbiAgICAnaW52YWxpZCBsZW5ndGgvbGl0ZXJhbCcsXG4gICAgJ2ludmFsaWQgZGlzdGFuY2UnLFxuICAgICdzdHJlYW0gZmluaXNoZWQnLFxuICAgICdubyBzdHJlYW0gaGFuZGxlcicsXG4gICAgLFxuICAgICdubyBjYWxsYmFjaycsXG4gICAgJ2ludmFsaWQgVVRGLTggZGF0YScsXG4gICAgJ2V4dHJhIGZpZWxkIHRvbyBsb25nJyxcbiAgICAnZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5JyxcbiAgICAnZmlsZW5hbWUgdG9vIGxvbmcnLFxuICAgICdzdHJlYW0gZmluaXNoaW5nJyxcbiAgICAnaW52YWxpZCB6aXAgZGF0YSdcbiAgICAvLyBkZXRlcm1pbmVkIGJ5IHVua25vd24gY29tcHJlc3Npb24gbWV0aG9kXG5dO1xudmFyIGVyciA9IGZ1bmN0aW9uIChpbmQsIG1zZywgbnQpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtc2cgfHwgZWNbaW5kXSk7XG4gICAgZS5jb2RlID0gaW5kO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICAgICAgeyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlLCBlcnIpOyB9XG4gICAgaWYgKCFudClcbiAgICAgICAgeyB0aHJvdyBlOyB9XG4gICAgcmV0dXJuIGU7XG59O1xuLy8gZXhwYW5kcyByYXcgREVGTEFURSBkYXRhXG52YXIgaW5mbHQgPSBmdW5jdGlvbiAoZGF0LCBidWYsIHN0KSB7XG4gICAgLy8gc291cmNlIGxlbmd0aFxuICAgIHZhciBzbCA9IGRhdC5sZW5ndGg7XG4gICAgaWYgKCFzbCB8fCAoc3QgJiYgc3QuZiAmJiAhc3QubCkpXG4gICAgICAgIHsgcmV0dXJuIGJ1ZiB8fCBuZXcgdTgoMCk7IH1cbiAgICAvLyBoYXZlIHRvIGVzdGltYXRlIHNpemVcbiAgICB2YXIgbm9CdWYgPSAhYnVmIHx8IHN0O1xuICAgIC8vIG5vIHN0YXRlXG4gICAgdmFyIG5vU3QgPSAhc3QgfHwgc3QuaTtcbiAgICBpZiAoIXN0KVxuICAgICAgICB7IHN0ID0ge307IH1cbiAgICAvLyBBc3N1bWVzIHJvdWdobHkgMzMlIGNvbXByZXNzaW9uIHJhdGlvIGF2ZXJhZ2VcbiAgICBpZiAoIWJ1ZilcbiAgICAgICAgeyBidWYgPSBuZXcgdTgoc2wgKiAzKTsgfVxuICAgIC8vIGVuc3VyZSBidWZmZXIgY2FuIGZpdCBhdCBsZWFzdCBsIGVsZW1lbnRzXG4gICAgdmFyIGNidWYgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICB2YXIgYmwgPSBidWYubGVuZ3RoO1xuICAgICAgICAvLyBuZWVkIHRvIGluY3JlYXNlIHNpemUgdG8gZml0XG4gICAgICAgIGlmIChsID4gYmwpIHtcbiAgICAgICAgICAgIC8vIERvdWJsZSBvciBzZXQgdG8gbmVjZXNzYXJ5LCB3aGljaGV2ZXIgaXMgZ3JlYXRlclxuICAgICAgICAgICAgdmFyIG5idWYgPSBuZXcgdTgoTWF0aC5tYXgoYmwgKiAyLCBsKSk7XG4gICAgICAgICAgICBuYnVmLnNldChidWYpO1xuICAgICAgICAgICAgYnVmID0gbmJ1ZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gIGxhc3QgY2h1bmsgICAgICAgICBiaXRwb3MgICAgICAgICAgIGJ5dGVzXG4gICAgdmFyIGZpbmFsID0gc3QuZiB8fCAwLCBwb3MgPSBzdC5wIHx8IDAsIGJ0ID0gc3QuYiB8fCAwLCBsbSA9IHN0LmwsIGRtID0gc3QuZCwgbGJ0ID0gc3QubSwgZGJ0ID0gc3QubjtcbiAgICAvLyB0b3RhbCBiaXRzXG4gICAgdmFyIHRidHMgPSBzbCAqIDg7XG4gICAgZG8ge1xuICAgICAgICBpZiAoIWxtKSB7XG4gICAgICAgICAgICAvLyBCRklOQUwgLSB0aGlzIGlzIG9ubHkgMSB3aGVuIGxhc3QgY2h1bmsgaXMgbmV4dFxuICAgICAgICAgICAgZmluYWwgPSBiaXRzKGRhdCwgcG9zLCAxKTtcbiAgICAgICAgICAgIC8vIHR5cGU6IDAgPSBubyBjb21wcmVzc2lvbiwgMSA9IGZpeGVkIGh1ZmZtYW4sIDIgPSBkeW5hbWljIGh1ZmZtYW5cbiAgICAgICAgICAgIHZhciB0eXBlID0gYml0cyhkYXQsIHBvcyArIDEsIDMpO1xuICAgICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBnbyB0byBlbmQgb2YgYnl0ZSBib3VuZGFyeVxuICAgICAgICAgICAgICAgIHZhciBzID0gc2hmdChwb3MpICsgNCwgbCA9IGRhdFtzIC0gNF0gfCAoZGF0W3MgLSAzXSA8PCA4KSwgdCA9IHMgKyBsO1xuICAgICAgICAgICAgICAgIGlmICh0ID4gc2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGVycigwKTsgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHNpemVcbiAgICAgICAgICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICAgICAgICAgIHsgY2J1ZihidCArIGwpOyB9XG4gICAgICAgICAgICAgICAgLy8gQ29weSBvdmVyIHVuY29tcHJlc3NlZCBkYXRhXG4gICAgICAgICAgICAgICAgYnVmLnNldChkYXQuc3ViYXJyYXkocywgdCksIGJ0KTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgbmV3IGJpdHBvcywgdXBkYXRlIGJ5dGUgY291bnRcbiAgICAgICAgICAgICAgICBzdC5iID0gYnQgKz0gbCwgc3QucCA9IHBvcyA9IHQgKiA4LCBzdC5mID0gZmluYWw7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDEpXG4gICAgICAgICAgICAgICAgeyBsbSA9IGZscm0sIGRtID0gZmRybSwgbGJ0ID0gOSwgZGJ0ID0gNTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gIGxpdGVyYWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3Roc1xuICAgICAgICAgICAgICAgIHZhciBoTGl0ID0gYml0cyhkYXQsIHBvcywgMzEpICsgMjU3LCBoY0xlbiA9IGJpdHMoZGF0LCBwb3MgKyAxMCwgMTUpICsgNDtcbiAgICAgICAgICAgICAgICB2YXIgdGwgPSBoTGl0ICsgYml0cyhkYXQsIHBvcyArIDUsIDMxKSArIDE7XG4gICAgICAgICAgICAgICAgcG9zICs9IDE0O1xuICAgICAgICAgICAgICAgIC8vIGxlbmd0aCtkaXN0YW5jZSB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGxkdCA9IG5ldyB1OCh0bCk7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGggdHJlZVxuICAgICAgICAgICAgICAgIHZhciBjbHQgPSBuZXcgdTgoMTkpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGNMZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaW5kZXggbWFwIHRvIGdldCByZWFsIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgY2x0W2NsaW1baV1dID0gYml0cyhkYXQsIHBvcyArIGkgKiAzLCA3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zICs9IGhjTGVuICogMztcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aHMgYml0c1xuICAgICAgICAgICAgICAgIHZhciBjbGIgPSBtYXgoY2x0KSwgY2xibXNrID0gKDEgPDwgY2xiKSAtIDE7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGhzIG1hcFxuICAgICAgICAgICAgICAgIHZhciBjbG0gPSBoTWFwKGNsdCwgY2xiLCAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRsOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGNsbVtiaXRzKGRhdCwgcG9zLCBjbGJtc2spXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0cyByZWFkXG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSByICYgMTU7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHIgPj4+IDQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RoIHRvIGNvcHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPCAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGR0W2krK10gPSBzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGNvcHkgICBjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSAwLCBuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID09IDE2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbiA9IDMgKyBiaXRzKGRhdCwgcG9zLCAzKSwgcG9zICs9IDIsIGMgPSBsZHRbaSAtIDFdOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzID09IDE3KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbiA9IDMgKyBiaXRzKGRhdCwgcG9zLCA3KSwgcG9zICs9IDM7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gMTgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuID0gMTEgKyBiaXRzKGRhdCwgcG9zLCAxMjcpLCBwb3MgKz0gNzsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG4tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGxkdFtpKytdID0gYzsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgIGxlbmd0aCB0cmVlICAgICAgICAgICAgICAgICBkaXN0YW5jZSB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGx0ID0gbGR0LnN1YmFycmF5KDAsIGhMaXQpLCBkdCA9IGxkdC5zdWJhcnJheShoTGl0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggbGVuZ3RoIGJpdHNcbiAgICAgICAgICAgICAgICBsYnQgPSBtYXgobHQpO1xuICAgICAgICAgICAgICAgIC8vIG1heCBkaXN0IGJpdHNcbiAgICAgICAgICAgICAgICBkYnQgPSBtYXgoZHQpO1xuICAgICAgICAgICAgICAgIGxtID0gaE1hcChsdCwgbGJ0LCAxKTtcbiAgICAgICAgICAgICAgICBkbSA9IGhNYXAoZHQsIGRidCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgeyBlcnIoMSk7IH1cbiAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgIHsgZXJyKDApOyB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBidWZmZXIgY2FuIGhvbGQgdGhpcyArIHRoZSBsYXJnZXN0IHBvc3NpYmxlIGFkZGl0aW9uXG4gICAgICAgIC8vIE1heGltdW0gY2h1bmsgc2l6ZSAocHJhY3RpY2FsbHksIHRoZW9yZXRpY2FsbHkgaW5maW5pdGUpIGlzIDJeMTc7XG4gICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgIHsgY2J1ZihidCArIDEzMTA3Mik7IH1cbiAgICAgICAgdmFyIGxtcyA9ICgxIDw8IGxidCkgLSAxLCBkbXMgPSAoMSA8PCBkYnQpIC0gMTtcbiAgICAgICAgdmFyIGxwb3MgPSBwb3M7XG4gICAgICAgIGZvciAoOzsgbHBvcyA9IHBvcykge1xuICAgICAgICAgICAgLy8gYml0cyByZWFkLCBjb2RlXG4gICAgICAgICAgICB2YXIgYyA9IGxtW2JpdHMxNihkYXQsIHBvcykgJiBsbXNdLCBzeW0gPSBjID4+PiA0O1xuICAgICAgICAgICAgcG9zICs9IGMgJiAxNTtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgIHsgZXJyKDApOyB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWMpXG4gICAgICAgICAgICAgICAgeyBlcnIoMik7IH1cbiAgICAgICAgICAgIGlmIChzeW0gPCAyNTYpXG4gICAgICAgICAgICAgICAgeyBidWZbYnQrK10gPSBzeW07IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN5bSA9PSAyNTYpIHtcbiAgICAgICAgICAgICAgICBscG9zID0gcG9zLCBsbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkID0gc3ltIC0gMjU0O1xuICAgICAgICAgICAgICAgIC8vIG5vIGV4dHJhIGJpdHMgbmVlZGVkIGlmIGxlc3NcbiAgICAgICAgICAgICAgICBpZiAoc3ltID4gMjY0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gc3ltIC0gMjU3LCBiID0gZmxlYltpXTtcbiAgICAgICAgICAgICAgICAgICAgYWRkID0gYml0cyhkYXQsIHBvcywgKDEgPDwgYikgLSAxKSArIGZsW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZGlzdFxuICAgICAgICAgICAgICAgIHZhciBkID0gZG1bYml0czE2KGRhdCwgcG9zKSAmIGRtc10sIGRzeW0gPSBkID4+PiA0O1xuICAgICAgICAgICAgICAgIGlmICghZClcbiAgICAgICAgICAgICAgICAgICAgeyBlcnIoMyk7IH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gZCAmIDE1O1xuICAgICAgICAgICAgICAgIHZhciBkdCA9IGZkW2RzeW1dO1xuICAgICAgICAgICAgICAgIGlmIChkc3ltID4gMykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGZkZWJbZHN5bV07XG4gICAgICAgICAgICAgICAgICAgIGR0ICs9IGJpdHMxNihkYXQsIHBvcykgJiAoKDEgPDwgYikgLSAxKSwgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgeyBlcnIoMCk7IH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgeyBjYnVmKGJ0ICsgMTMxMDcyKTsgfVxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBidCArIGFkZDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYnQgPCBlbmQ7IGJ0ICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0XSA9IGJ1ZltidCAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgMV0gPSBidWZbYnQgKyAxIC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAyXSA9IGJ1ZltidCArIDIgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDNdID0gYnVmW2J0ICsgMyAtIGR0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3QubCA9IGxtLCBzdC5wID0gbHBvcywgc3QuYiA9IGJ0LCBzdC5mID0gZmluYWw7XG4gICAgICAgIGlmIChsbSlcbiAgICAgICAgICAgIHsgZmluYWwgPSAxLCBzdC5tID0gbGJ0LCBzdC5kID0gZG0sIHN0Lm4gPSBkYnQ7IH1cbiAgICB9IHdoaWxlICghZmluYWwpO1xuICAgIHJldHVybiBidCA9PSBidWYubGVuZ3RoID8gYnVmIDogc2xjKGJ1ZiwgMCwgYnQpO1xufTtcbi8vIGVtcHR5XG52YXIgZXQgPSAvKiNfX1BVUkVfXyovIG5ldyB1OCgwKTtcbi8qKlxuICogRXhwYW5kcyBERUZMQVRFIGRhdGEgd2l0aCBubyB3cmFwcGVyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBTYXZlcyBtZW1vcnkgaWYgeW91IGtub3cgdGhlIGRlY29tcHJlc3NlZCBzaXplIGFuZCBwcm92aWRlIGFuIG91dHB1dCBidWZmZXIgb2YgdGhhdCBsZW5ndGguXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZVN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEsIG91dCk7XG59XG4vLyB0ZXh0IGRlY29kZXJcbnZhciB0ZCA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPSAndW5kZWZpbmVkJyAmJiAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RGVjb2RlcigpO1xuLy8gdGV4dCBkZWNvZGVyIHN0cmVhbVxudmFyIHRkcyA9IDA7XG50cnkge1xuICAgIHRkLmRlY29kZShldCwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgdGRzID0gMTtcbn1cbmNhdGNoIChlKSB7IH1cblxuLy8gR2VvbWV0cmljIG9iamVjdHNcblxuLy8gaW1wb3J0IEJvdW5kaW5nQm94IGZyb20gJy4vYmJveCc7XG5cbi8qKlxuICogQSBiw6l6aWVyIHBhdGggY29udGFpbmluZyBhIHNldCBvZiBwYXRoIGNvbW1hbmRzIHNpbWlsYXIgdG8gYSBTVkcgcGF0aC5cbiAqIFBhdGhzIGNhbiBiZSBkcmF3biBvbiBhIGNvbnRleHQgdXNpbmcgYGRyYXdgLlxuICogQGV4cG9ydHMgb3BlbnR5cGUuUGF0aFxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUGF0aCgpIHtcbiAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgdGhpcy5maWxsID0gJ2JsYWNrJztcbiAgICB0aGlzLnN0cm9rZSA9IG51bGw7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG59XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAqL1xuUGF0aC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnTScsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0geFxuICogQHBhcmFtICB7bnVtYmVyfSB5XG4gKi9cblBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0wnLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmF3cyBjdWJpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBjdXJ2ZVRvXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgyIC0geCBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geTIgLSB5IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqL1xuXG4vKipcbiAqIERyYXdzIGN1YmljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIGJlemllckN1cnZlVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sIDFcbiAqIEBwYXJhbSAge251bWJlcn0geDIgLSB4IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB5MiAtIHkgb2YgY29udHJvbCAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICogQHNlZSBjdXJ2ZVRvXG4gKi9cblBhdGgucHJvdG90eXBlLmN1cnZlVG8gPSBQYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKFxuICAgIHgxLFxuICAgIHkxLFxuICAgIHgyLFxuICAgIHkyLFxuICAgIHgsXG4gICAgeVxuKSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0MnLFxuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYXdzIHF1YWRyYXRpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBxdWFkcmF0aWNDdXJ2ZVRvXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2xcbiAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2xcbiAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG4gKi9cblxuLyoqXG4gKiBEcmF3cyBxdWFkcmF0aWMgY3VydmVcbiAqIEBmdW5jdGlvblxuICogcXVhZFRvXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2xcbiAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2xcbiAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG4gKi9cblBhdGgucHJvdG90eXBlLnF1YWRUbyA9IFBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiAoXG4gICAgeDEsXG4gICAgeTEsXG4gICAgeCxcbiAgICB5XG4pIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnUScsXG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHBhdGhcbiAqIEBmdW5jdGlvbiBjbG9zZVBhdGhcbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICovXG5cbi8qKlxuICogQ2xvc2UgdGhlIHBhdGhcbiAqIEBmdW5jdGlvbiBjbG9zZVxuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKi9cblBhdGgucHJvdG90eXBlLmNsb3NlID0gUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdaJyxcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBwYXRoIG9yIGxpc3Qgb2YgY29tbWFuZHMgdG8gdGhlIGNvbW1hbmRzIG9mIHRoaXMgcGF0aC5cbiAqIEBwYXJhbSAge0FycmF5fSBwYXRoT3JDb21tYW5kcyAtIGFub3RoZXIgb3BlbnR5cGUuUGF0aCwgYW4gb3BlbnR5cGUuQm91bmRpbmdCb3gsIG9yIGFuIGFycmF5IG9mIGNvbW1hbmRzLlxuICovXG5QYXRoLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAocGF0aE9yQ29tbWFuZHMpIHtcbiAgICBpZiAocGF0aE9yQ29tbWFuZHMuY29tbWFuZHMpIHtcbiAgICAgICAgcGF0aE9yQ29tbWFuZHMgPSBwYXRoT3JDb21tYW5kcy5jb21tYW5kcztcbiAgICB9XG4gICAgLy8gZWxzZSBpZiAocGF0aE9yQ29tbWFuZHMgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xuICAgIC8vICAgICBjb25zdCBib3ggPSBwYXRoT3JDb21tYW5kcztcbiAgICAvLyAgICAgdGhpcy5tb3ZlVG8oYm94LngxLCBib3gueTEpO1xuICAgIC8vICAgICB0aGlzLmxpbmVUbyhib3gueDIsIGJveC55MSk7XG4gICAgLy8gICAgIHRoaXMubGluZVRvKGJveC54MiwgYm94LnkyKTtcbiAgICAvLyAgICAgdGhpcy5saW5lVG8oYm94LngxLCBib3gueTIpO1xuICAgIC8vICAgICB0aGlzLmNsb3NlKCk7XG4gICAgLy8gICAgIHJldHVybjtcbiAgICAvLyB9XG5cbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLmNvbW1hbmRzLCBwYXRoT3JDb21tYW5kcyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIFBhdGggdG8gYSBzdHJpbmcgb2YgcGF0aCBkYXRhIGluc3RydWN0aW9uc1xuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtkZWNpbWFsUGxhY2VzPTJdIC0gVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBhdGgucHJvdG90eXBlLnRvUGF0aERhdGEgPSBmdW5jdGlvbiAoZGVjaW1hbFBsYWNlcykge1xuICAgIGRlY2ltYWxQbGFjZXMgPSBkZWNpbWFsUGxhY2VzICE9PSB1bmRlZmluZWQgPyBkZWNpbWFsUGxhY2VzIDogMjtcblxuICAgIGZ1bmN0aW9uIGZsb2F0VG9TdHJpbmcodikge1xuICAgICAgICBpZiAoTWF0aC5yb3VuZCh2KSA9PT0gdikge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgTWF0aC5yb3VuZCh2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvRml4ZWQoZGVjaW1hbFBsYWNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWNrVmFsdWVzKCkge1xuICAgICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgdmFyIHMgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB2ID0gYXJndW1lbnRzJDFbaV07XG4gICAgICAgICAgICBpZiAodiA+PSAwICYmIGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHMgKz0gZmxvYXRUb1N0cmluZyh2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIHZhciBkID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSB0aGlzLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgZCArPSAnTScgKyBwYWNrVmFsdWVzKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgZCArPSAnTCcgKyBwYWNrVmFsdWVzKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgZCArPSAnQycgKyBwYWNrVmFsdWVzKGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICBkICs9ICdRJyArIHBhY2tWYWx1ZXMoY21kLngxLCBjbWQueTEsIGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgZCArPSAnWic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8vIEdseXBoIGVuY29kaW5nXG5cbnZhciBjZmZTdGFuZGFyZFN0cmluZ3MgPSBbXG4gICAgJy5ub3RkZWYnLFxuICAgICdzcGFjZScsXG4gICAgJ2V4Y2xhbScsXG4gICAgJ3F1b3RlZGJsJyxcbiAgICAnbnVtYmVyc2lnbicsXG4gICAgJ2RvbGxhcicsXG4gICAgJ3BlcmNlbnQnLFxuICAgICdhbXBlcnNhbmQnLFxuICAgICdxdW90ZXJpZ2h0JyxcbiAgICAncGFyZW5sZWZ0JyxcbiAgICAncGFyZW5yaWdodCcsXG4gICAgJ2FzdGVyaXNrJyxcbiAgICAncGx1cycsXG4gICAgJ2NvbW1hJyxcbiAgICAnaHlwaGVuJyxcbiAgICAncGVyaW9kJyxcbiAgICAnc2xhc2gnLFxuICAgICd6ZXJvJyxcbiAgICAnb25lJyxcbiAgICAndHdvJyxcbiAgICAndGhyZWUnLFxuICAgICdmb3VyJyxcbiAgICAnZml2ZScsXG4gICAgJ3NpeCcsXG4gICAgJ3NldmVuJyxcbiAgICAnZWlnaHQnLFxuICAgICduaW5lJyxcbiAgICAnY29sb24nLFxuICAgICdzZW1pY29sb24nLFxuICAgICdsZXNzJyxcbiAgICAnZXF1YWwnLFxuICAgICdncmVhdGVyJyxcbiAgICAncXVlc3Rpb24nLFxuICAgICdhdCcsXG4gICAgJ0EnLFxuICAgICdCJyxcbiAgICAnQycsXG4gICAgJ0QnLFxuICAgICdFJyxcbiAgICAnRicsXG4gICAgJ0cnLFxuICAgICdIJyxcbiAgICAnSScsXG4gICAgJ0onLFxuICAgICdLJyxcbiAgICAnTCcsXG4gICAgJ00nLFxuICAgICdOJyxcbiAgICAnTycsXG4gICAgJ1AnLFxuICAgICdRJyxcbiAgICAnUicsXG4gICAgJ1MnLFxuICAgICdUJyxcbiAgICAnVScsXG4gICAgJ1YnLFxuICAgICdXJyxcbiAgICAnWCcsXG4gICAgJ1knLFxuICAgICdaJyxcbiAgICAnYnJhY2tldGxlZnQnLFxuICAgICdiYWNrc2xhc2gnLFxuICAgICdicmFja2V0cmlnaHQnLFxuICAgICdhc2NpaWNpcmN1bScsXG4gICAgJ3VuZGVyc2NvcmUnLFxuICAgICdxdW90ZWxlZnQnLFxuICAgICdhJyxcbiAgICAnYicsXG4gICAgJ2MnLFxuICAgICdkJyxcbiAgICAnZScsXG4gICAgJ2YnLFxuICAgICdnJyxcbiAgICAnaCcsXG4gICAgJ2knLFxuICAgICdqJyxcbiAgICAnaycsXG4gICAgJ2wnLFxuICAgICdtJyxcbiAgICAnbicsXG4gICAgJ28nLFxuICAgICdwJyxcbiAgICAncScsXG4gICAgJ3InLFxuICAgICdzJyxcbiAgICAndCcsXG4gICAgJ3UnLFxuICAgICd2JyxcbiAgICAndycsXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAneicsXG4gICAgJ2JyYWNlbGVmdCcsXG4gICAgJ2JhcicsXG4gICAgJ2JyYWNlcmlnaHQnLFxuICAgICdhc2NpaXRpbGRlJyxcbiAgICAnZXhjbGFtZG93bicsXG4gICAgJ2NlbnQnLFxuICAgICdzdGVybGluZycsXG4gICAgJ2ZyYWN0aW9uJyxcbiAgICAneWVuJyxcbiAgICAnZmxvcmluJyxcbiAgICAnc2VjdGlvbicsXG4gICAgJ2N1cnJlbmN5JyxcbiAgICAncXVvdGVzaW5nbGUnLFxuICAgICdxdW90ZWRibGxlZnQnLFxuICAgICdndWlsbGVtb3RsZWZ0JyxcbiAgICAnZ3VpbHNpbmdsbGVmdCcsXG4gICAgJ2d1aWxzaW5nbHJpZ2h0JyxcbiAgICAnZmknLFxuICAgICdmbCcsXG4gICAgJ2VuZGFzaCcsXG4gICAgJ2RhZ2dlcicsXG4gICAgJ2RhZ2dlcmRibCcsXG4gICAgJ3BlcmlvZGNlbnRlcmVkJyxcbiAgICAncGFyYWdyYXBoJyxcbiAgICAnYnVsbGV0JyxcbiAgICAncXVvdGVzaW5nbGJhc2UnLFxuICAgICdxdW90ZWRibGJhc2UnLFxuICAgICdxdW90ZWRibHJpZ2h0JyxcbiAgICAnZ3VpbGxlbW90cmlnaHQnLFxuICAgICdlbGxpcHNpcycsXG4gICAgJ3BlcnRob3VzYW5kJyxcbiAgICAncXVlc3Rpb25kb3duJyxcbiAgICAnZ3JhdmUnLFxuICAgICdhY3V0ZScsXG4gICAgJ2NpcmN1bWZsZXgnLFxuICAgICd0aWxkZScsXG4gICAgJ21hY3JvbicsXG4gICAgJ2JyZXZlJyxcbiAgICAnZG90YWNjZW50JyxcbiAgICAnZGllcmVzaXMnLFxuICAgICdyaW5nJyxcbiAgICAnY2VkaWxsYScsXG4gICAgJ2h1bmdhcnVtbGF1dCcsXG4gICAgJ29nb25laycsXG4gICAgJ2Nhcm9uJyxcbiAgICAnZW1kYXNoJyxcbiAgICAnQUUnLFxuICAgICdvcmRmZW1pbmluZScsXG4gICAgJ0xzbGFzaCcsXG4gICAgJ09zbGFzaCcsXG4gICAgJ09FJyxcbiAgICAnb3JkbWFzY3VsaW5lJyxcbiAgICAnYWUnLFxuICAgICdkb3RsZXNzaScsXG4gICAgJ2xzbGFzaCcsXG4gICAgJ29zbGFzaCcsXG4gICAgJ29lJyxcbiAgICAnZ2VybWFuZGJscycsXG4gICAgJ29uZXN1cGVyaW9yJyxcbiAgICAnbG9naWNhbG5vdCcsXG4gICAgJ211JyxcbiAgICAndHJhZGVtYXJrJyxcbiAgICAnRXRoJyxcbiAgICAnb25laGFsZicsXG4gICAgJ3BsdXNtaW51cycsXG4gICAgJ1Rob3JuJyxcbiAgICAnb25lcXVhcnRlcicsXG4gICAgJ2RpdmlkZScsXG4gICAgJ2Jyb2tlbmJhcicsXG4gICAgJ2RlZ3JlZScsXG4gICAgJ3Rob3JuJyxcbiAgICAndGhyZWVxdWFydGVycycsXG4gICAgJ3R3b3N1cGVyaW9yJyxcbiAgICAncmVnaXN0ZXJlZCcsXG4gICAgJ21pbnVzJyxcbiAgICAnZXRoJyxcbiAgICAnbXVsdGlwbHknLFxuICAgICd0aHJlZXN1cGVyaW9yJyxcbiAgICAnY29weXJpZ2h0JyxcbiAgICAnQWFjdXRlJyxcbiAgICAnQWNpcmN1bWZsZXgnLFxuICAgICdBZGllcmVzaXMnLFxuICAgICdBZ3JhdmUnLFxuICAgICdBcmluZycsXG4gICAgJ0F0aWxkZScsXG4gICAgJ0NjZWRpbGxhJyxcbiAgICAnRWFjdXRlJyxcbiAgICAnRWNpcmN1bWZsZXgnLFxuICAgICdFZGllcmVzaXMnLFxuICAgICdFZ3JhdmUnLFxuICAgICdJYWN1dGUnLFxuICAgICdJY2lyY3VtZmxleCcsXG4gICAgJ0lkaWVyZXNpcycsXG4gICAgJ0lncmF2ZScsXG4gICAgJ050aWxkZScsXG4gICAgJ09hY3V0ZScsXG4gICAgJ09jaXJjdW1mbGV4JyxcbiAgICAnT2RpZXJlc2lzJyxcbiAgICAnT2dyYXZlJyxcbiAgICAnT3RpbGRlJyxcbiAgICAnU2Nhcm9uJyxcbiAgICAnVWFjdXRlJyxcbiAgICAnVWNpcmN1bWZsZXgnLFxuICAgICdVZGllcmVzaXMnLFxuICAgICdVZ3JhdmUnLFxuICAgICdZYWN1dGUnLFxuICAgICdZZGllcmVzaXMnLFxuICAgICdaY2Fyb24nLFxuICAgICdhYWN1dGUnLFxuICAgICdhY2lyY3VtZmxleCcsXG4gICAgJ2FkaWVyZXNpcycsXG4gICAgJ2FncmF2ZScsXG4gICAgJ2FyaW5nJyxcbiAgICAnYXRpbGRlJyxcbiAgICAnY2NlZGlsbGEnLFxuICAgICdlYWN1dGUnLFxuICAgICdlY2lyY3VtZmxleCcsXG4gICAgJ2VkaWVyZXNpcycsXG4gICAgJ2VncmF2ZScsXG4gICAgJ2lhY3V0ZScsXG4gICAgJ2ljaXJjdW1mbGV4JyxcbiAgICAnaWRpZXJlc2lzJyxcbiAgICAnaWdyYXZlJyxcbiAgICAnbnRpbGRlJyxcbiAgICAnb2FjdXRlJyxcbiAgICAnb2NpcmN1bWZsZXgnLFxuICAgICdvZGllcmVzaXMnLFxuICAgICdvZ3JhdmUnLFxuICAgICdvdGlsZGUnLFxuICAgICdzY2Fyb24nLFxuICAgICd1YWN1dGUnLFxuICAgICd1Y2lyY3VtZmxleCcsXG4gICAgJ3VkaWVyZXNpcycsXG4gICAgJ3VncmF2ZScsXG4gICAgJ3lhY3V0ZScsXG4gICAgJ3lkaWVyZXNpcycsXG4gICAgJ3pjYXJvbicsXG4gICAgJ2V4Y2xhbXNtYWxsJyxcbiAgICAnSHVuZ2FydW1sYXV0c21hbGwnLFxuICAgICdkb2xsYXJvbGRzdHlsZScsXG4gICAgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLFxuICAgICdBY3V0ZXNtYWxsJyxcbiAgICAncGFyZW5sZWZ0c3VwZXJpb3InLFxuICAgICdwYXJlbnJpZ2h0c3VwZXJpb3InLFxuICAgICcyNjYgZmYnLFxuICAgICdvbmVkb3RlbmxlYWRlcicsXG4gICAgJ3plcm9vbGRzdHlsZScsXG4gICAgJ29uZW9sZHN0eWxlJyxcbiAgICAndHdvb2xkc3R5bGUnLFxuICAgICd0aHJlZW9sZHN0eWxlJyxcbiAgICAnZm91cm9sZHN0eWxlJyxcbiAgICAnZml2ZW9sZHN0eWxlJyxcbiAgICAnc2l4b2xkc3R5bGUnLFxuICAgICdzZXZlbm9sZHN0eWxlJyxcbiAgICAnZWlnaHRvbGRzdHlsZScsXG4gICAgJ25pbmVvbGRzdHlsZScsXG4gICAgJ2NvbW1hc3VwZXJpb3InLFxuICAgICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJyxcbiAgICAncGVyaW9kc3VwZXJpb3InLFxuICAgICdxdWVzdGlvbnNtYWxsJyxcbiAgICAnYXN1cGVyaW9yJyxcbiAgICAnYnN1cGVyaW9yJyxcbiAgICAnY2VudHN1cGVyaW9yJyxcbiAgICAnZHN1cGVyaW9yJyxcbiAgICAnZXN1cGVyaW9yJyxcbiAgICAnaXN1cGVyaW9yJyxcbiAgICAnbHN1cGVyaW9yJyxcbiAgICAnbXN1cGVyaW9yJyxcbiAgICAnbnN1cGVyaW9yJyxcbiAgICAnb3N1cGVyaW9yJyxcbiAgICAncnN1cGVyaW9yJyxcbiAgICAnc3N1cGVyaW9yJyxcbiAgICAndHN1cGVyaW9yJyxcbiAgICAnZmYnLFxuICAgICdmZmknLFxuICAgICdmZmwnLFxuICAgICdwYXJlbmxlZnRpbmZlcmlvcicsXG4gICAgJ3BhcmVucmlnaHRpbmZlcmlvcicsXG4gICAgJ0NpcmN1bWZsZXhzbWFsbCcsXG4gICAgJ2h5cGhlbnN1cGVyaW9yJyxcbiAgICAnR3JhdmVzbWFsbCcsXG4gICAgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsXG4gICAgJ0NzbWFsbCcsXG4gICAgJ0RzbWFsbCcsXG4gICAgJ0VzbWFsbCcsXG4gICAgJ0ZzbWFsbCcsXG4gICAgJ0dzbWFsbCcsXG4gICAgJ0hzbWFsbCcsXG4gICAgJ0lzbWFsbCcsXG4gICAgJ0pzbWFsbCcsXG4gICAgJ0tzbWFsbCcsXG4gICAgJ0xzbWFsbCcsXG4gICAgJ01zbWFsbCcsXG4gICAgJ05zbWFsbCcsXG4gICAgJ09zbWFsbCcsXG4gICAgJ1BzbWFsbCcsXG4gICAgJ1FzbWFsbCcsXG4gICAgJ1JzbWFsbCcsXG4gICAgJ1NzbWFsbCcsXG4gICAgJ1RzbWFsbCcsXG4gICAgJ1VzbWFsbCcsXG4gICAgJ1ZzbWFsbCcsXG4gICAgJ1dzbWFsbCcsXG4gICAgJ1hzbWFsbCcsXG4gICAgJ1lzbWFsbCcsXG4gICAgJ1pzbWFsbCcsXG4gICAgJ2NvbG9ubW9uZXRhcnknLFxuICAgICdvbmVmaXR0ZWQnLFxuICAgICdydXBpYWgnLFxuICAgICdUaWxkZXNtYWxsJyxcbiAgICAnZXhjbGFtZG93bnNtYWxsJyxcbiAgICAnY2VudG9sZHN0eWxlJyxcbiAgICAnTHNsYXNoc21hbGwnLFxuICAgICdTY2Fyb25zbWFsbCcsXG4gICAgJ1pjYXJvbnNtYWxsJyxcbiAgICAnRGllcmVzaXNzbWFsbCcsXG4gICAgJ0JyZXZlc21hbGwnLFxuICAgICdDYXJvbnNtYWxsJyxcbiAgICAnRG90YWNjZW50c21hbGwnLFxuICAgICdNYWNyb25zbWFsbCcsXG4gICAgJ2ZpZ3VyZWRhc2gnLFxuICAgICdoeXBoZW5pbmZlcmlvcicsXG4gICAgJ09nb25la3NtYWxsJyxcbiAgICAnUmluZ3NtYWxsJyxcbiAgICAnQ2VkaWxsYXNtYWxsJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLFxuICAgICdvbmVlaWdodGgnLFxuICAgICd0aHJlZWVpZ2h0aHMnLFxuICAgICdmaXZlZWlnaHRocycsXG4gICAgJ3NldmVuZWlnaHRocycsXG4gICAgJ29uZXRoaXJkJyxcbiAgICAndHdvdGhpcmRzJyxcbiAgICAnemVyb3N1cGVyaW9yJyxcbiAgICAnZm91cnN1cGVyaW9yJyxcbiAgICAnZml2ZXN1cGVyaW9yJyxcbiAgICAnc2l4c3VwZXJpb3InLFxuICAgICdzZXZlbnN1cGVyaW9yJyxcbiAgICAnZWlnaHRzdXBlcmlvcicsXG4gICAgJ25pbmVzdXBlcmlvcicsXG4gICAgJ3plcm9pbmZlcmlvcicsXG4gICAgJ29uZWluZmVyaW9yJyxcbiAgICAndHdvaW5mZXJpb3InLFxuICAgICd0aHJlZWluZmVyaW9yJyxcbiAgICAnZm91cmluZmVyaW9yJyxcbiAgICAnZml2ZWluZmVyaW9yJyxcbiAgICAnc2l4aW5mZXJpb3InLFxuICAgICdzZXZlbmluZmVyaW9yJyxcbiAgICAnZWlnaHRpbmZlcmlvcicsXG4gICAgJ25pbmVpbmZlcmlvcicsXG4gICAgJ2NlbnRpbmZlcmlvcicsXG4gICAgJ2RvbGxhcmluZmVyaW9yJyxcbiAgICAncGVyaW9kaW5mZXJpb3InLFxuICAgICdjb21tYWluZmVyaW9yJyxcbiAgICAnQWdyYXZlc21hbGwnLFxuICAgICdBYWN1dGVzbWFsbCcsXG4gICAgJ0FjaXJjdW1mbGV4c21hbGwnLFxuICAgICdBdGlsZGVzbWFsbCcsXG4gICAgJ0FkaWVyZXNpc3NtYWxsJyxcbiAgICAnQXJpbmdzbWFsbCcsXG4gICAgJ0FFc21hbGwnLFxuICAgICdDY2VkaWxsYXNtYWxsJyxcbiAgICAnRWdyYXZlc21hbGwnLFxuICAgICdFYWN1dGVzbWFsbCcsXG4gICAgJ0VjaXJjdW1mbGV4c21hbGwnLFxuICAgICdFZGllcmVzaXNzbWFsbCcsXG4gICAgJ0lncmF2ZXNtYWxsJyxcbiAgICAnSWFjdXRlc21hbGwnLFxuICAgICdJY2lyY3VtZmxleHNtYWxsJyxcbiAgICAnSWRpZXJlc2lzc21hbGwnLFxuICAgICdFdGhzbWFsbCcsXG4gICAgJ050aWxkZXNtYWxsJyxcbiAgICAnT2dyYXZlc21hbGwnLFxuICAgICdPYWN1dGVzbWFsbCcsXG4gICAgJ09jaXJjdW1mbGV4c21hbGwnLFxuICAgICdPdGlsZGVzbWFsbCcsXG4gICAgJ09kaWVyZXNpc3NtYWxsJyxcbiAgICAnT0VzbWFsbCcsXG4gICAgJ09zbGFzaHNtYWxsJyxcbiAgICAnVWdyYXZlc21hbGwnLFxuICAgICdVYWN1dGVzbWFsbCcsXG4gICAgJ1VjaXJjdW1mbGV4c21hbGwnLFxuICAgICdVZGllcmVzaXNzbWFsbCcsXG4gICAgJ1lhY3V0ZXNtYWxsJyxcbiAgICAnVGhvcm5zbWFsbCcsXG4gICAgJ1lkaWVyZXNpc3NtYWxsJyxcbiAgICAnMDAxLjAwMCcsXG4gICAgJzAwMS4wMDEnLFxuICAgICcwMDEuMDAyJyxcbiAgICAnMDAxLjAwMycsXG4gICAgJ0JsYWNrJyxcbiAgICAnQm9sZCcsXG4gICAgJ0Jvb2snLFxuICAgICdMaWdodCcsXG4gICAgJ01lZGl1bScsXG4gICAgJ1JlZ3VsYXInLFxuICAgICdSb21hbicsXG4gICAgJ1NlbWlib2xkJyBdO1xuXG52YXIgY2ZmU3RhbmRhcmRFbmNvZGluZyA9IFtcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnc3BhY2UnLFxuICAgICdleGNsYW0nLFxuICAgICdxdW90ZWRibCcsXG4gICAgJ251bWJlcnNpZ24nLFxuICAgICdkb2xsYXInLFxuICAgICdwZXJjZW50JyxcbiAgICAnYW1wZXJzYW5kJyxcbiAgICAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsXG4gICAgJ3BhcmVucmlnaHQnLFxuICAgICdhc3RlcmlzaycsXG4gICAgJ3BsdXMnLFxuICAgICdjb21tYScsXG4gICAgJ2h5cGhlbicsXG4gICAgJ3BlcmlvZCcsXG4gICAgJ3NsYXNoJyxcbiAgICAnemVybycsXG4gICAgJ29uZScsXG4gICAgJ3R3bycsXG4gICAgJ3RocmVlJyxcbiAgICAnZm91cicsXG4gICAgJ2ZpdmUnLFxuICAgICdzaXgnLFxuICAgICdzZXZlbicsXG4gICAgJ2VpZ2h0JyxcbiAgICAnbmluZScsXG4gICAgJ2NvbG9uJyxcbiAgICAnc2VtaWNvbG9uJyxcbiAgICAnbGVzcycsXG4gICAgJ2VxdWFsJyxcbiAgICAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJyxcbiAgICAnYXQnLFxuICAgICdBJyxcbiAgICAnQicsXG4gICAgJ0MnLFxuICAgICdEJyxcbiAgICAnRScsXG4gICAgJ0YnLFxuICAgICdHJyxcbiAgICAnSCcsXG4gICAgJ0knLFxuICAgICdKJyxcbiAgICAnSycsXG4gICAgJ0wnLFxuICAgICdNJyxcbiAgICAnTicsXG4gICAgJ08nLFxuICAgICdQJyxcbiAgICAnUScsXG4gICAgJ1InLFxuICAgICdTJyxcbiAgICAnVCcsXG4gICAgJ1UnLFxuICAgICdWJyxcbiAgICAnVycsXG4gICAgJ1gnLFxuICAgICdZJyxcbiAgICAnWicsXG4gICAgJ2JyYWNrZXRsZWZ0JyxcbiAgICAnYmFja3NsYXNoJyxcbiAgICAnYnJhY2tldHJpZ2h0JyxcbiAgICAnYXNjaWljaXJjdW0nLFxuICAgICd1bmRlcnNjb3JlJyxcbiAgICAncXVvdGVsZWZ0JyxcbiAgICAnYScsXG4gICAgJ2InLFxuICAgICdjJyxcbiAgICAnZCcsXG4gICAgJ2UnLFxuICAgICdmJyxcbiAgICAnZycsXG4gICAgJ2gnLFxuICAgICdpJyxcbiAgICAnaicsXG4gICAgJ2snLFxuICAgICdsJyxcbiAgICAnbScsXG4gICAgJ24nLFxuICAgICdvJyxcbiAgICAncCcsXG4gICAgJ3EnLFxuICAgICdyJyxcbiAgICAncycsXG4gICAgJ3QnLFxuICAgICd1JyxcbiAgICAndicsXG4gICAgJ3cnLFxuICAgICd4JyxcbiAgICAneScsXG4gICAgJ3onLFxuICAgICdicmFjZWxlZnQnLFxuICAgICdiYXInLFxuICAgICdicmFjZXJpZ2h0JyxcbiAgICAnYXNjaWl0aWxkZScsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ2V4Y2xhbWRvd24nLFxuICAgICdjZW50JyxcbiAgICAnc3RlcmxpbmcnLFxuICAgICdmcmFjdGlvbicsXG4gICAgJ3llbicsXG4gICAgJ2Zsb3JpbicsXG4gICAgJ3NlY3Rpb24nLFxuICAgICdjdXJyZW5jeScsXG4gICAgJ3F1b3Rlc2luZ2xlJyxcbiAgICAncXVvdGVkYmxsZWZ0JyxcbiAgICAnZ3VpbGxlbW90bGVmdCcsXG4gICAgJ2d1aWxzaW5nbGxlZnQnLFxuICAgICdndWlsc2luZ2xyaWdodCcsXG4gICAgJ2ZpJyxcbiAgICAnZmwnLFxuICAgICcnLFxuICAgICdlbmRhc2gnLFxuICAgICdkYWdnZXInLFxuICAgICdkYWdnZXJkYmwnLFxuICAgICdwZXJpb2RjZW50ZXJlZCcsXG4gICAgJycsXG4gICAgJ3BhcmFncmFwaCcsXG4gICAgJ2J1bGxldCcsXG4gICAgJ3F1b3Rlc2luZ2xiYXNlJyxcbiAgICAncXVvdGVkYmxiYXNlJyxcbiAgICAncXVvdGVkYmxyaWdodCcsXG4gICAgJ2d1aWxsZW1vdHJpZ2h0JyxcbiAgICAnZWxsaXBzaXMnLFxuICAgICdwZXJ0aG91c2FuZCcsXG4gICAgJycsXG4gICAgJ3F1ZXN0aW9uZG93bicsXG4gICAgJycsXG4gICAgJ2dyYXZlJyxcbiAgICAnYWN1dGUnLFxuICAgICdjaXJjdW1mbGV4JyxcbiAgICAndGlsZGUnLFxuICAgICdtYWNyb24nLFxuICAgICdicmV2ZScsXG4gICAgJ2RvdGFjY2VudCcsXG4gICAgJ2RpZXJlc2lzJyxcbiAgICAnJyxcbiAgICAncmluZycsXG4gICAgJ2NlZGlsbGEnLFxuICAgICcnLFxuICAgICdodW5nYXJ1bWxhdXQnLFxuICAgICdvZ29uZWsnLFxuICAgICdjYXJvbicsXG4gICAgJ2VtZGFzaCcsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ0FFJyxcbiAgICAnJyxcbiAgICAnb3JkZmVtaW5pbmUnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdMc2xhc2gnLFxuICAgICdPc2xhc2gnLFxuICAgICdPRScsXG4gICAgJ29yZG1hc2N1bGluZScsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ2FlJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnZG90bGVzc2knLFxuICAgICcnLFxuICAgICcnLFxuICAgICdsc2xhc2gnLFxuICAgICdvc2xhc2gnLFxuICAgICdvZScsXG4gICAgJ2dlcm1hbmRibHMnIF07XG5cbnZhciBjZmZFeHBlcnRFbmNvZGluZyA9IFtcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnc3BhY2UnLFxuICAgICdleGNsYW1zbWFsbCcsXG4gICAgJ0h1bmdhcnVtbGF1dHNtYWxsJyxcbiAgICAnJyxcbiAgICAnZG9sbGFyb2xkc3R5bGUnLFxuICAgICdkb2xsYXJzdXBlcmlvcicsXG4gICAgJ2FtcGVyc2FuZHNtYWxsJyxcbiAgICAnQWN1dGVzbWFsbCcsXG4gICAgJ3BhcmVubGVmdHN1cGVyaW9yJyxcbiAgICAncGFyZW5yaWdodHN1cGVyaW9yJyxcbiAgICAndHdvZG90ZW5sZWFkZXInLFxuICAgICdvbmVkb3RlbmxlYWRlcicsXG4gICAgJ2NvbW1hJyxcbiAgICAnaHlwaGVuJyxcbiAgICAncGVyaW9kJyxcbiAgICAnZnJhY3Rpb24nLFxuICAgICd6ZXJvb2xkc3R5bGUnLFxuICAgICdvbmVvbGRzdHlsZScsXG4gICAgJ3R3b29sZHN0eWxlJyxcbiAgICAndGhyZWVvbGRzdHlsZScsXG4gICAgJ2ZvdXJvbGRzdHlsZScsXG4gICAgJ2ZpdmVvbGRzdHlsZScsXG4gICAgJ3NpeG9sZHN0eWxlJyxcbiAgICAnc2V2ZW5vbGRzdHlsZScsXG4gICAgJ2VpZ2h0b2xkc3R5bGUnLFxuICAgICduaW5lb2xkc3R5bGUnLFxuICAgICdjb2xvbicsXG4gICAgJ3NlbWljb2xvbicsXG4gICAgJ2NvbW1hc3VwZXJpb3InLFxuICAgICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJyxcbiAgICAncGVyaW9kc3VwZXJpb3InLFxuICAgICdxdWVzdGlvbnNtYWxsJyxcbiAgICAnJyxcbiAgICAnYXN1cGVyaW9yJyxcbiAgICAnYnN1cGVyaW9yJyxcbiAgICAnY2VudHN1cGVyaW9yJyxcbiAgICAnZHN1cGVyaW9yJyxcbiAgICAnZXN1cGVyaW9yJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnaXN1cGVyaW9yJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnbHN1cGVyaW9yJyxcbiAgICAnbXN1cGVyaW9yJyxcbiAgICAnbnN1cGVyaW9yJyxcbiAgICAnb3N1cGVyaW9yJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAncnN1cGVyaW9yJyxcbiAgICAnc3N1cGVyaW9yJyxcbiAgICAndHN1cGVyaW9yJyxcbiAgICAnJyxcbiAgICAnZmYnLFxuICAgICdmaScsXG4gICAgJ2ZsJyxcbiAgICAnZmZpJyxcbiAgICAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLFxuICAgICcnLFxuICAgICdwYXJlbnJpZ2h0aW5mZXJpb3InLFxuICAgICdDaXJjdW1mbGV4c21hbGwnLFxuICAgICdoeXBoZW5zdXBlcmlvcicsXG4gICAgJ0dyYXZlc21hbGwnLFxuICAgICdBc21hbGwnLFxuICAgICdCc21hbGwnLFxuICAgICdDc21hbGwnLFxuICAgICdEc21hbGwnLFxuICAgICdFc21hbGwnLFxuICAgICdGc21hbGwnLFxuICAgICdHc21hbGwnLFxuICAgICdIc21hbGwnLFxuICAgICdJc21hbGwnLFxuICAgICdKc21hbGwnLFxuICAgICdLc21hbGwnLFxuICAgICdMc21hbGwnLFxuICAgICdNc21hbGwnLFxuICAgICdOc21hbGwnLFxuICAgICdPc21hbGwnLFxuICAgICdQc21hbGwnLFxuICAgICdRc21hbGwnLFxuICAgICdSc21hbGwnLFxuICAgICdTc21hbGwnLFxuICAgICdUc21hbGwnLFxuICAgICdVc21hbGwnLFxuICAgICdWc21hbGwnLFxuICAgICdXc21hbGwnLFxuICAgICdYc21hbGwnLFxuICAgICdZc21hbGwnLFxuICAgICdac21hbGwnLFxuICAgICdjb2xvbm1vbmV0YXJ5JyxcbiAgICAnb25lZml0dGVkJyxcbiAgICAncnVwaWFoJyxcbiAgICAnVGlsZGVzbWFsbCcsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ2V4Y2xhbWRvd25zbWFsbCcsXG4gICAgJ2NlbnRvbGRzdHlsZScsXG4gICAgJ0xzbGFzaHNtYWxsJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnU2Nhcm9uc21hbGwnLFxuICAgICdaY2Fyb25zbWFsbCcsXG4gICAgJ0RpZXJlc2lzc21hbGwnLFxuICAgICdCcmV2ZXNtYWxsJyxcbiAgICAnQ2Fyb25zbWFsbCcsXG4gICAgJycsXG4gICAgJ0RvdGFjY2VudHNtYWxsJyxcbiAgICAnJyxcbiAgICAnJyxcbiAgICAnTWFjcm9uc21hbGwnLFxuICAgICcnLFxuICAgICcnLFxuICAgICdmaWd1cmVkYXNoJyxcbiAgICAnaHlwaGVuaW5mZXJpb3InLFxuICAgICcnLFxuICAgICcnLFxuICAgICdPZ29uZWtzbWFsbCcsXG4gICAgJ1JpbmdzbWFsbCcsXG4gICAgJ0NlZGlsbGFzbWFsbCcsXG4gICAgJycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ29uZXF1YXJ0ZXInLFxuICAgICdvbmVoYWxmJyxcbiAgICAndGhyZWVxdWFydGVycycsXG4gICAgJ3F1ZXN0aW9uZG93bnNtYWxsJyxcbiAgICAnb25lZWlnaHRoJyxcbiAgICAndGhyZWVlaWdodGhzJyxcbiAgICAnZml2ZWVpZ2h0aHMnLFxuICAgICdzZXZlbmVpZ2h0aHMnLFxuICAgICdvbmV0aGlyZCcsXG4gICAgJ3R3b3RoaXJkcycsXG4gICAgJycsXG4gICAgJycsXG4gICAgJ3plcm9zdXBlcmlvcicsXG4gICAgJ29uZXN1cGVyaW9yJyxcbiAgICAndHdvc3VwZXJpb3InLFxuICAgICd0aHJlZXN1cGVyaW9yJyxcbiAgICAnZm91cnN1cGVyaW9yJyxcbiAgICAnZml2ZXN1cGVyaW9yJyxcbiAgICAnc2l4c3VwZXJpb3InLFxuICAgICdzZXZlbnN1cGVyaW9yJyxcbiAgICAnZWlnaHRzdXBlcmlvcicsXG4gICAgJ25pbmVzdXBlcmlvcicsXG4gICAgJ3plcm9pbmZlcmlvcicsXG4gICAgJ29uZWluZmVyaW9yJyxcbiAgICAndHdvaW5mZXJpb3InLFxuICAgICd0aHJlZWluZmVyaW9yJyxcbiAgICAnZm91cmluZmVyaW9yJyxcbiAgICAnZml2ZWluZmVyaW9yJyxcbiAgICAnc2l4aW5mZXJpb3InLFxuICAgICdzZXZlbmluZmVyaW9yJyxcbiAgICAnZWlnaHRpbmZlcmlvcicsXG4gICAgJ25pbmVpbmZlcmlvcicsXG4gICAgJ2NlbnRpbmZlcmlvcicsXG4gICAgJ2RvbGxhcmluZmVyaW9yJyxcbiAgICAncGVyaW9kaW5mZXJpb3InLFxuICAgICdjb21tYWluZmVyaW9yJyxcbiAgICAnQWdyYXZlc21hbGwnLFxuICAgICdBYWN1dGVzbWFsbCcsXG4gICAgJ0FjaXJjdW1mbGV4c21hbGwnLFxuICAgICdBdGlsZGVzbWFsbCcsXG4gICAgJ0FkaWVyZXNpc3NtYWxsJyxcbiAgICAnQXJpbmdzbWFsbCcsXG4gICAgJ0FFc21hbGwnLFxuICAgICdDY2VkaWxsYXNtYWxsJyxcbiAgICAnRWdyYXZlc21hbGwnLFxuICAgICdFYWN1dGVzbWFsbCcsXG4gICAgJ0VjaXJjdW1mbGV4c21hbGwnLFxuICAgICdFZGllcmVzaXNzbWFsbCcsXG4gICAgJ0lncmF2ZXNtYWxsJyxcbiAgICAnSWFjdXRlc21hbGwnLFxuICAgICdJY2lyY3VtZmxleHNtYWxsJyxcbiAgICAnSWRpZXJlc2lzc21hbGwnLFxuICAgICdFdGhzbWFsbCcsXG4gICAgJ050aWxkZXNtYWxsJyxcbiAgICAnT2dyYXZlc21hbGwnLFxuICAgICdPYWN1dGVzbWFsbCcsXG4gICAgJ09jaXJjdW1mbGV4c21hbGwnLFxuICAgICdPdGlsZGVzbWFsbCcsXG4gICAgJ09kaWVyZXNpc3NtYWxsJyxcbiAgICAnT0VzbWFsbCcsXG4gICAgJ09zbGFzaHNtYWxsJyxcbiAgICAnVWdyYXZlc21hbGwnLFxuICAgICdVYWN1dGVzbWFsbCcsXG4gICAgJ1VjaXJjdW1mbGV4c21hbGwnLFxuICAgICdVZGllcmVzaXNzbWFsbCcsXG4gICAgJ1lhY3V0ZXNtYWxsJyxcbiAgICAnVGhvcm5zbWFsbCcsXG4gICAgJ1lkaWVyZXNpc3NtYWxsJyBdO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGVuY29kaW5nIHVzZWQgZm9yIGZvbnRzIGNyZWF0ZWQgZnJvbSBzY3JhdGNoLlxuICogSXQgbG9vcHMgdGhyb3VnaCBhbGwgZ2x5cGhzIGFuZCBmaW5kcyB0aGUgYXBwcm9wcmlhdGUgdW5pY29kZSB2YWx1ZS5cbiAqIFNpbmNlIGl0J3MgbGluZWFyIHRpbWUsIG90aGVyIGVuY29kaW5ncyB3aWxsIGJlIGZhc3Rlci5cbiAqIEBleHBvcnRzIG9wZW50eXBlLkRlZmF1bHRFbmNvZGluZ1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqL1xuZnVuY3Rpb24gRGVmYXVsdEVuY29kaW5nKGZvbnQpIHtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xufVxuXG5EZWZhdWx0RW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbiAoYykge1xuICAgIHZhciBjb2RlID0gYy5jb2RlUG9pbnRBdCgwKTtcbiAgICB2YXIgZ2x5cGhzID0gdGhpcy5mb250LmdseXBocztcbiAgICBpZiAoZ2x5cGhzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaC51bmljb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaC51bmljb2Rlc1tqXSA9PT0gY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkNtYXBFbmNvZGluZ1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjbWFwIC0gYSBvYmplY3Qgd2l0aCB0aGUgY21hcCBlbmNvZGVkIGRhdGFcbiAqL1xuZnVuY3Rpb24gQ21hcEVuY29kaW5nKGNtYXApIHtcbiAgICB0aGlzLmNtYXAgPSBjbWFwO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30gYyAtIHRoZSBjaGFyYWN0ZXJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGdseXBoIGluZGV4LlxuICovXG5DbWFwRW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiB0aGlzLmNtYXAuZ2x5cGhJbmRleE1hcFtjLmNvZGVQb2ludEF0KDApXSB8fCAwO1xufTtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5DZmZFbmNvZGluZ1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyAtIFRoZSBlbmNvZGluZ1xuICogQHBhcmFtIHtBcnJheX0gY2hhcnNldCAtIFRoZSBjaGFyYWN0ZXIgc2V0LlxuICovXG5mdW5jdGlvbiBDZmZFbmNvZGluZyhlbmNvZGluZywgY2hhcnNldCkge1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB0aGlzLmNoYXJzZXQgPSBjaGFyc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30gcyAtIFRoZSBjaGFyYWN0ZXJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4LlxuICovXG5DZmZFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdmFyIGNvZGUgPSBzLmNvZGVQb2ludEF0KDApO1xuICAgIHZhciBjaGFyTmFtZSA9IHRoaXMuZW5jb2RpbmdbY29kZV07XG4gICAgcmV0dXJuIHRoaXMuY2hhcnNldC5pbmRleE9mKGNoYXJOYW1lKTtcbn07XG5cbmZ1bmN0aW9uIGFkZEdseXBoTmFtZXNBbGwoZm9udCkge1xuICAgIHZhciBnbHlwaDtcbiAgICB2YXIgZ2x5cGhJbmRleE1hcCA9IGZvbnQudGFibGVzLmNtYXAuZ2x5cGhJbmRleE1hcDtcbiAgICB2YXIgY2hhckNvZGVzID0gT2JqZWN0LmtleXMoZ2x5cGhJbmRleE1hcCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJDb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IGNoYXJDb2Rlc1tpXTtcbiAgICAgICAgdmFyIGdseXBoSW5kZXggPSBnbHlwaEluZGV4TWFwW2NdO1xuICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcbiAgICAgICAgZ2x5cGguYWRkVW5pY29kZShwYXJzZUludChjKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRHbHlwaE5hbWVzVG9Vbmljb2RlTWFwKGZvbnQpIHtcbiAgICBmb250Ll9JbmRleFRvVW5pY29kZU1hcCA9IHt9O1xuXG4gICAgdmFyIGdseXBoSW5kZXhNYXAgPSBmb250LnRhYmxlcy5jbWFwLmdseXBoSW5kZXhNYXA7XG4gICAgdmFyIGNoYXJDb2RlcyA9IE9iamVjdC5rZXlzKGdseXBoSW5kZXhNYXApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyQ29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBjaGFyQ29kZXNbaV07XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZ2x5cGhJbmRleE1hcFtjXTtcbiAgICAgICAgaWYgKGZvbnQuX0luZGV4VG9Vbmljb2RlTWFwW2dseXBoSW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvbnQuX0luZGV4VG9Vbmljb2RlTWFwW2dseXBoSW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIHVuaWNvZGVzOiBbcGFyc2VJbnQoYyldLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvbnQuX0luZGV4VG9Vbmljb2RlTWFwW2dseXBoSW5kZXhdLnVuaWNvZGVzLnB1c2gocGFyc2VJbnQoYykpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBhbGlhcyBvcGVudHlwZS5hZGRHbHlwaE5hbWVzXG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gYWRkR2x5cGhOYW1lcyhmb250LCBvcHQpIHtcbiAgICBpZiAob3B0Lmxvd01lbW9yeSkge1xuICAgICAgICBhZGRHbHlwaE5hbWVzVG9Vbmljb2RlTWFwKGZvbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZEdseXBoTmFtZXNBbGwoZm9udCk7XG4gICAgfVxufVxuXG4vLyBSdW4tdGltZSBjaGVja2luZyBvZiBwcmVjb25kaXRpb25zLlxuXG5mdW5jdGlvbiBmYWlsKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8vIFByZWNvbmRpdGlvbiBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGUgZ2l2ZW4gcHJlZGljYXRlIGlzIHRydWUuXG4vLyBJZiBub3QsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG5mdW5jdGlvbiBhcmd1bWVudChwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICBmYWlsKG1lc3NhZ2UpO1xuICAgIH1cbn1cbnZhciBjaGVjayA9IHsgZmFpbDogZmFpbCwgYXJndW1lbnQ6IGFyZ3VtZW50LCBhc3NlcnQ6IGFyZ3VtZW50IH07XG5cbi8vIFRoZSBHbHlwaCBvYmplY3Rcbi8vIGltcG9ydCBnbHlmIGZyb20gJy4vdGFibGVzL2dseWYnIENhbid0IGJlIGltcG9ydGVkIGhlcmUsIGJlY2F1c2UgaXQncyBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcblxuZnVuY3Rpb24gZ2V0UGF0aERlZmluaXRpb24oZ2x5cGgsIHBhdGgpIHtcbiAgICB2YXIgX3BhdGggPSBwYXRoIHx8IG5ldyBQYXRoKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfcGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIF9wYXRoID0gX3BhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9wYXRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIF9wYXRoID0gcDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAdHlwZWRlZiBHbHlwaE9wdGlvbnNcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBnbHlwaCBuYW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3VuaWNvZGVdXG4gKiBAcHJvcGVydHkge0FycmF5fSBbdW5pY29kZXNdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3hNaW5dXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3lNaW5dXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3hNYXhdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3lNYXhdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2FkdmFuY2VXaWR0aF1cbiAqL1xuXG4vLyBBIEdseXBoIGlzIGFuIGluZGl2aWR1YWwgbWFyayB0aGF0IG9mdGVuIGNvcnJlc3BvbmRzIHRvIGEgY2hhcmFjdGVyLlxuLy8gU29tZSBnbHlwaHMsIHN1Y2ggYXMgbGlnYXR1cmVzLCBhcmUgYSBjb21iaW5hdGlvbiBvZiBtYW55IGNoYXJhY3RlcnMuXG4vLyBHbHlwaHMgYXJlIHRoZSBiYXNpYyBidWlsZGluZyBibG9ja3Mgb2YgYSBmb250LlxuLy9cbi8vIFRoZSBgR2x5cGhgIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3IgZHJhd2luZyB0aGUgcGF0aCBhbmQgaXRzIHBvaW50cy5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuR2x5cGhcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtHbHlwaE9wdGlvbnN9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gR2x5cGgob3B0aW9ucykge1xuICAgIC8vIEJ5IHB1dHRpbmcgYWxsIHRoZSBjb2RlIG9uIGEgcHJvdG90eXBlIGZ1bmN0aW9uICh3aGljaCBpcyBvbmx5IGRlY2xhcmVkIG9uY2UpXG4gICAgLy8gd2UgcmVkdWNlIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGZvciBsYXJnZXIgZm9udHMgYnkgc29tZSAyJVxuICAgIHRoaXMuYmluZENvbnN0cnVjdG9yVmFsdWVzKG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge0dseXBoT3B0aW9uc31cbiAqL1xuR2x5cGgucHJvdG90eXBlLmJpbmRDb25zdHJ1Y3RvclZhbHVlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcblxuICAgIC8vIFRoZXNlIHRocmVlIHZhbHVlcyBjYW5ub3QgYmUgZGVmZXJyZWQgZm9yIG1lbW9yeSBvcHRpbWl6YXRpb246XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IG51bGw7XG4gICAgdGhpcy51bmljb2RlID0gb3B0aW9ucy51bmljb2RlIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLnVuaWNvZGVzID1cbiAgICAgICAgb3B0aW9ucy51bmljb2RlcyB8fCBvcHRpb25zLnVuaWNvZGUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBbb3B0aW9ucy51bmljb2RlXVxuICAgICAgICAgICAgOiBbXTtcblxuICAgIC8vIEJ1dCBieSBiaW5kaW5nIHRoZXNlIHZhbHVlcyBvbmx5IHdoZW4gbmVjZXNzYXJ5LCB3ZSByZWR1Y2UgY2FuXG4gICAgLy8gdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgYnkgYWxtb3N0IDMlIGZvciBsYXJnZXIgZm9udHMuXG4gICAgaWYgKCd4TWluJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMueE1pbiA9IG9wdGlvbnMueE1pbjtcbiAgICB9XG5cbiAgICBpZiAoJ3lNaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy55TWluID0gb3B0aW9ucy55TWluO1xuICAgIH1cblxuICAgIGlmICgneE1heCcgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnhNYXggPSBvcHRpb25zLnhNYXg7XG4gICAgfVxuXG4gICAgaWYgKCd5TWF4JyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMueU1heCA9IG9wdGlvbnMueU1heDtcbiAgICB9XG5cbiAgICBpZiAoJ2FkdmFuY2VXaWR0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLmFkdmFuY2VXaWR0aCA9IG9wdGlvbnMuYWR2YW5jZVdpZHRoO1xuICAgIH1cblxuICAgIC8vIFRoZSBwYXRoIGZvciBhIGdseXBoIGlzIHRoZSBtb3N0IG1lbW9yeSBpbnRlbnNpdmUsIGFuZCBpcyBib3VuZCBhcyBhIHZhbHVlXG4gICAgLy8gd2l0aCBhIGdldHRlci9zZXR0ZXIgdG8gZW5zdXJlIHdlIGFjdHVhbGx5IGRvIHBhdGggcGFyc2luZyBvbmx5IG9uY2UgdGhlXG4gICAgLy8gcGF0aCBpcyBhY3R1YWxseSBuZWVkZWQgYnkgYW55dGhpbmcuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYXRoJywgZ2V0UGF0aERlZmluaXRpb24odGhpcywgb3B0aW9ucy5wYXRoKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICovXG5HbHlwaC5wcm90b3R5cGUuYWRkVW5pY29kZSA9IGZ1bmN0aW9uICh1bmljb2RlKSB7XG4gICAgaWYgKHRoaXMudW5pY29kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMudW5pY29kZSA9IHVuaWNvZGU7XG4gICAgfVxuXG4gICAgdGhpcy51bmljb2Rlcy5wdXNoKHVuaWNvZGUpO1xufTtcblxuLy8gLyoqXG4vLyAgKiBDYWxjdWxhdGUgdGhlIG1pbmltdW0gYm91bmRpbmcgYm94IGZvciB0aGlzIGdseXBoLlxuLy8gICogQHJldHVybiB7b3BlbnR5cGUuQm91bmRpbmdCb3h9XG4vLyAgKi9cbi8vIEdseXBoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuLy8gICAgIHJldHVybiB0aGlzLnBhdGguZ2V0Qm91bmRpbmdCb3goKTtcbi8vIH07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2x5cGggdG8gYSBQYXRoIHdlIGNhbiBkcmF3IG9uIGEgZHJhd2luZyBjb250ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zIC0geFNjYWxlLCB5U2NhbGUgdG8gc3RyZXRjaCB0aGUgZ2x5cGguXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBpZiBoaW50aW5nIGlzIHRvIGJlIHVzZWQsIHRoZSBmb250XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuICovXG5HbHlwaC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICh4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZm9udCkge1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiA3MjtcbiAgICB2YXIgY29tbWFuZHM7XG4gICAgdmFyIGhQb2ludHM7XG4gICAgaWYgKCFvcHRpb25zKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciB4U2NhbGUgPSBvcHRpb25zLnhTY2FsZTtcbiAgICB2YXIgeVNjYWxlID0gb3B0aW9ucy55U2NhbGU7XG5cbiAgICBpZiAob3B0aW9ucy5oaW50aW5nICYmIGZvbnQgJiYgZm9udC5oaW50aW5nKSB7XG4gICAgICAgIC8vIGluIGNhc2Ugb2YgaGludGluZywgdGhlIGhpbnRpbmcgZW5naW5lIHRha2VzIGNhcmVcbiAgICAgICAgLy8gb2Ygc2NhbGluZyB0aGUgcG9pbnRzIChub3QgdGhlIHBhdGgpIGJlZm9yZSBoaW50aW5nLlxuICAgICAgICBoUG9pbnRzID0gdGhpcy5wYXRoICYmIGZvbnQuaGludGluZy5leGVjKHRoaXMsIGZvbnRTaXplKTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgaGludGluZyBlbmdpbmUgZmFpbGVkIGhQb2ludHMgaXMgdW5kZWZpbmVkXG4gICAgICAgIC8vIGFuZCB0aHVzIHJldmVydHMgdG8gcGxhaW4gcmVuZGluZ1xuICAgIH1cblxuICAgIGlmIChoUG9pbnRzKSB7XG4gICAgICAgIC8vIENhbGwgZm9udC5oaW50aW5nLmdldENvbW1hbmRzIGluc3RlYWQgb2YgYGdseWYuZ2V0UGF0aChoUG9pbnRzKS5jb21tYW5kc2AgdG8gYXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgICAgIGNvbW1hbmRzID0gZm9udC5oaW50aW5nLmdldENvbW1hbmRzKGhQb2ludHMpO1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgIC8vIFRPRE8gaW4gY2FzZSBvZiBoaW50aW5nIHh5U2NhbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFxuICAgICAgICB4U2NhbGUgPSB5U2NhbGUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbW1hbmRzID0gdGhpcy5wYXRoLmNvbW1hbmRzO1xuICAgICAgICB2YXIgc2NhbGUgPSAoMSAvICh0aGlzLnBhdGgudW5pdHNQZXJFbSB8fCAxMDAwKSkgKiBmb250U2l6ZTtcbiAgICAgICAgaWYgKHhTY2FsZSA9PT0gdW5kZWZpbmVkKSB7IHhTY2FsZSA9IHNjYWxlOyB9XG4gICAgICAgIGlmICh5U2NhbGUgPT09IHVuZGVmaW5lZCkgeyB5U2NhbGUgPSBzY2FsZTsgfVxuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFBhdGgoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIHAubW92ZVRvKHggKyBjbWQueCAqIHhTY2FsZSwgeSArIC1jbWQueSAqIHlTY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgcC5saW5lVG8oeCArIGNtZC54ICogeFNjYWxlLCB5ICsgLWNtZC55ICogeVNjYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCArIGNtZC54MSAqIHhTY2FsZSxcbiAgICAgICAgICAgICAgICB5ICsgLWNtZC55MSAqIHlTY2FsZSxcbiAgICAgICAgICAgICAgICB4ICsgY21kLnggKiB4U2NhbGUsXG4gICAgICAgICAgICAgICAgeSArIC1jbWQueSAqIHlTY2FsZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBwLmN1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCArIGNtZC54MSAqIHhTY2FsZSxcbiAgICAgICAgICAgICAgICB5ICsgLWNtZC55MSAqIHlTY2FsZSxcbiAgICAgICAgICAgICAgICB4ICsgY21kLngyICogeFNjYWxlLFxuICAgICAgICAgICAgICAgIHkgKyAtY21kLnkyICogeVNjYWxlLFxuICAgICAgICAgICAgICAgIHggKyBjbWQueCAqIHhTY2FsZSxcbiAgICAgICAgICAgICAgICB5ICsgLWNtZC55ICogeVNjYWxlXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogU3BsaXQgdGhlIGdseXBoIGludG8gY29udG91cnMuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBhbmQgdG9cbiAqIHByb3ZpZGUgcmF3IGFjY2VzcyB0byB0aGUgVHJ1ZVR5cGUgZ2x5cGggb3V0bGluZXMuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuR2x5cGgucHJvdG90eXBlLmdldENvbnRvdXJzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBvaW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgY29udG91cnMgPSBbXTtcbiAgICB2YXIgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwdCA9IHRoaXMucG9pbnRzW2ldO1xuICAgICAgICBjdXJyZW50Q29udG91ci5wdXNoKHB0KTtcbiAgICAgICAgaWYgKHB0Lmxhc3RQb2ludE9mQ29udG91cikge1xuICAgICAgICAgICAgY29udG91cnMucHVzaChjdXJyZW50Q29udG91cik7XG4gICAgICAgICAgICBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgIGN1cnJlbnRDb250b3VyLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgJ1RoZXJlIGFyZSBzdGlsbCBwb2ludHMgbGVmdCBpbiB0aGUgY3VycmVudCBjb250b3VyLidcbiAgICApO1xuICAgIHJldHVybiBjb250b3Vycztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB4TWluL3lNaW4veE1heC95TWF4L2xzYi9yc2IgZm9yIGEgR2x5cGguXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb21tYW5kcyA9IHRoaXMucGF0aC5jb21tYW5kcztcbiAgICB2YXIgeENvb3JkcyA9IFtdO1xuICAgIHZhciB5Q29vcmRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSAhPT0gJ1onKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngpO1xuICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ1EnIHx8IGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueDEpO1xuICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55MSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54Mik7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtZXRyaWNzID0ge1xuICAgICAgICB4TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB4Q29vcmRzKSxcbiAgICAgICAgeU1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeUNvb3JkcyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICB5TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgbGVmdFNpZGVCZWFyaW5nOiB0aGlzLmxlZnRTaWRlQmVhcmluZyxcbiAgICB9O1xuXG4gICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnhNaW4pKSB7XG4gICAgICAgIG1ldHJpY3MueE1pbiA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnhNYXgpKSB7XG4gICAgICAgIG1ldHJpY3MueE1heCA9IHRoaXMuYWR2YW5jZVdpZHRoO1xuICAgIH1cblxuICAgIGlmICghaXNGaW5pdGUobWV0cmljcy55TWluKSkge1xuICAgICAgICBtZXRyaWNzLnlNaW4gPSAwO1xuICAgIH1cblxuICAgIGlmICghaXNGaW5pdGUobWV0cmljcy55TWF4KSkge1xuICAgICAgICBtZXRyaWNzLnlNYXggPSAwO1xuICAgIH1cblxuICAgIG1ldHJpY3MucmlnaHRTaWRlQmVhcmluZyA9XG4gICAgICAgIHRoaXMuYWR2YW5jZVdpZHRoIC1cbiAgICAgICAgbWV0cmljcy5sZWZ0U2lkZUJlYXJpbmcgLVxuICAgICAgICAobWV0cmljcy54TWF4IC0gbWV0cmljcy54TWluKTtcbiAgICByZXR1cm4gbWV0cmljcztcbn07XG5cbi8vIFRoZSBHbHlwaFNldCBvYmplY3RcblxuLy8gRGVmaW5lIGEgcHJvcGVydHkgb24gdGhlIGdseXBoIHRoYXQgZGVwZW5kcyBvbiB0aGUgcGF0aCBiZWluZyBsb2FkZWQuXG5mdW5jdGlvbiBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgZXh0ZXJuYWxOYW1lLCBpbnRlcm5hbE5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2x5cGgsIGV4dGVybmFsTmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgdGhlIHBhdGggcHJvcGVydHkgdG8gbWFrZSBzdXJlIHRoZSBwYXRoIGlzIGxvYWRlZC5cbiAgICAgICAgICAgIGdseXBoLnBhdGg7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgcmV0dXJuIGdseXBoW2ludGVybmFsTmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBnbHlwaFtpbnRlcm5hbE5hbWVdID0gbmV3VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBIEdseXBoU2V0IHJlcHJlc2VudHMgYWxsIGdseXBocyBhdmFpbGFibGUgaW4gdGhlIGZvbnQsIGJ1dCBtb2RlbGxlZCB1c2luZ1xuICogYSBkZWZlcnJlZCBnbHlwaCBsb2FkZXIsIGZvciByZXRyaWV2aW5nIGdseXBocyBvbmx5IG9uY2UgdGhleSBhcmUgYWJzb2x1dGVseVxuICogbmVjZXNzYXJ5LCB0byBrZWVwIHRoZSBtZW1vcnkgZm9vdHByaW50IGRvd24uXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5HbHlwaFNldFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKiBAcGFyYW0ge0FycmF5fVxuICovXG5mdW5jdGlvbiBHbHlwaFNldChmb250LCBnbHlwaHMpIHtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuICAgIHRoaXMuZ2x5cGhzID0ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2x5cGhzKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICAgICAgZ2x5cGgucGF0aC51bml0c1BlckVtID0gZm9udC51bml0c1BlckVtO1xuICAgICAgICAgICAgdGhpcy5nbHlwaHNbaV0gPSBnbHlwaDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gKGdseXBocyAmJiBnbHlwaHMubGVuZ3RoKSB8fCAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5HbHlwaFNldC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgLy8gdGhpcy5nbHlwaHNbaW5kZXhdIGlzICd1bmRlZmluZWQnIHdoZW4gbG93IG1lbW9yeSBtb2RlIGlzIG9uLiBnbHlwaCBpcyBwdXNoZWQgb24gcmVxdWVzdCBvbmx5LlxuICAgIGlmICh0aGlzLmdseXBoc1tpbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmZvbnQuX3B1c2goaW5kZXgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ2x5cGhzW2luZGV4XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5nbHlwaHNbaW5kZXhdID0gdGhpcy5nbHlwaHNbaW5kZXhdKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLmdseXBoc1tpbmRleF07XG4gICAgICAgIHZhciB1bmljb2RlT2JqID0gdGhpcy5mb250Ll9JbmRleFRvVW5pY29kZU1hcFtpbmRleF07XG5cbiAgICAgICAgaWYgKHVuaWNvZGVPYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdW5pY29kZU9iai51bmljb2Rlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICB7IGdseXBoLmFkZFVuaWNvZGUodW5pY29kZU9iai51bmljb2Rlc1tqXSk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2x5cGhzW2luZGV4XS5hZHZhbmNlV2lkdGggPVxuICAgICAgICAgICAgdGhpcy5mb250Ll9obXR4VGFibGVEYXRhW2luZGV4XS5hZHZhbmNlV2lkdGg7XG4gICAgICAgIHRoaXMuZ2x5cGhzW2luZGV4XS5sZWZ0U2lkZUJlYXJpbmcgPVxuICAgICAgICAgICAgdGhpcy5mb250Ll9obXR4VGFibGVEYXRhW2luZGV4XS5sZWZ0U2lkZUJlYXJpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdseXBoc1tpbmRleF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IHRoaXMuZ2x5cGhzW2luZGV4XSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2x5cGhzW2luZGV4XTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtICB7T2JqZWN0fVxuICovXG5HbHlwaFNldC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChpbmRleCwgbG9hZGVyKSB7XG4gICAgdGhpcy5nbHlwaHNbaW5kZXhdID0gbG9hZGVyO1xuICAgIHRoaXMubGVuZ3RoKys7XG59O1xuXG4vKipcbiAqIEBhbGlhcyBvcGVudHlwZS5nbHlwaExvYWRlclxuICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbmZ1bmN0aW9uIGdseXBoTG9hZGVyKGZvbnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBHbHlwaCh7IGluZGV4OiBpbmRleCwgZm9udDogZm9udCB9KTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0dWIgZ2x5cGggdGhhdCBjYW4gYmUgZmlsbGVkIHdpdGggYWxsIG1ldGFkYXRhICpleGNlcHQqXG4gKiB0aGUgXCJwb2ludHNcIiBhbmQgXCJwYXRoXCIgcHJvcGVydGllcywgd2hpY2ggbXVzdCBiZSBsb2FkZWQgb25seSBvbmNlXG4gKiB0aGUgZ2x5cGgncyBwYXRoIGlzIGFjdHVhbGx5IHJlcXVlc3RlZCBmb3IgdGV4dCBzaGFwaW5nLlxuICogQGFsaWFzIG9wZW50eXBlLnR0ZkdseXBoTG9hZGVyXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBmb250XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gcGFyc2VHbHlwaFxuICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gYnVpbGRQYXRoXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuZnVuY3Rpb24gdHRmR2x5cGhMb2FkZXIoZm9udCwgaW5kZXgsIHBhcnNlR2x5cGgsIGRhdGEsIHBvc2l0aW9uLCBidWlsZFBhdGgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2x5cGggPSBuZXcgR2x5cGgoeyBpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnQgfSk7XG5cbiAgICAgICAgZ2x5cGgucGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBhcnNlR2x5cGgoZ2x5cGgsIGRhdGEsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gYnVpbGRQYXRoKGZvbnQuZ2x5cGhzLCBnbHlwaCk7XG4gICAgICAgICAgICBwYXRoLnVuaXRzUGVyRW0gPSBmb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcblxuICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3hNaW4nLCAnX3hNaW4nKTtcbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd4TWF4JywgJ194TWF4Jyk7XG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneU1pbicsICdfeU1pbicpO1xuICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3lNYXgnLCAnX3lNYXgnKTtcblxuICAgICAgICByZXR1cm4gZ2x5cGg7XG4gICAgfTtcbn1cbi8qKlxuICogQGFsaWFzIG9wZW50eXBlLmNmZkdseXBoTG9hZGVyXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBmb250XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gcGFyc2VDRkZDaGFyc3RyaW5nXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNoYXJzdHJpbmdcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5mdW5jdGlvbiBjZmZHbHlwaExvYWRlcihmb250LCBpbmRleCwgcGFyc2VDRkZDaGFyc3RyaW5nLCBjaGFyc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdseXBoID0gbmV3IEdseXBoKHsgaW5kZXg6IGluZGV4LCBmb250OiBmb250IH0pO1xuXG4gICAgICAgIGdseXBoLnBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHBhcnNlQ0ZGQ2hhcnN0cmluZyhmb250LCBnbHlwaCwgY2hhcnN0cmluZyk7XG4gICAgICAgICAgICBwYXRoLnVuaXRzUGVyRW0gPSBmb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZ2x5cGg7XG4gICAgfTtcbn1cblxudmFyIGdseXBoc2V0ID0geyBHbHlwaFNldDogR2x5cGhTZXQsIGdseXBoTG9hZGVyOiBnbHlwaExvYWRlciwgdHRmR2x5cGhMb2FkZXI6IHR0ZkdseXBoTG9hZGVyLCBjZmZHbHlwaExvYWRlcjogY2ZmR2x5cGhMb2FkZXIgfTtcblxuLy8gVGhlIExheW91dCBvYmplY3QgaXMgdGhlIHByb3RvdHlwZSBvZiBTdWJzdGl0dXRpb24gb2JqZWN0cywgYW5kIHByb3ZpZGVzXG5cbmZ1bmN0aW9uIHNlYXJjaFRhZyhhcnIsIHRhZykge1xuICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuICAgIHZhciBpbWluID0gMDtcbiAgICB2YXIgaW1heCA9IGFyci5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpbWluIDw9IGltYXgpIHtcbiAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuICAgICAgICB2YXIgdmFsID0gYXJyW2ltaWRdLnRhZztcbiAgICAgICAgaWYgKHZhbCA9PT0gdGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1pZDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPCB0YWcpIHtcbiAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGltYXggPSBpbWlkIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3QgZm91bmQ6IHJldHVybiAtMS1pbnNlcnRpb24gcG9pbnRcbiAgICByZXR1cm4gLWltaW4gLSAxO1xufVxuXG5mdW5jdGlvbiBiaW5TZWFyY2goYXJyLCB2YWx1ZSkge1xuICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuICAgIHZhciBpbWluID0gMDtcbiAgICB2YXIgaW1heCA9IGFyci5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpbWluIDw9IGltYXgpIHtcbiAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuICAgICAgICB2YXIgdmFsID0gYXJyW2ltaWRdO1xuICAgICAgICBpZiAodmFsID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGltaWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDwgdmFsdWUpIHtcbiAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGltYXggPSBpbWlkIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3QgZm91bmQ6IHJldHVybiAtMS1pbnNlcnRpb24gcG9pbnRcbiAgICByZXR1cm4gLWltaW4gLSAxO1xufVxuXG4vLyBiaW5hcnkgc2VhcmNoIGluIGEgbGlzdCBvZiByYW5nZXMgKGNvdmVyYWdlLCBjbGFzcyBkZWZpbml0aW9uKVxuZnVuY3Rpb24gc2VhcmNoUmFuZ2UocmFuZ2VzLCB2YWx1ZSkge1xuICAgIC8vIGpzaGludCBiaXR3aXNlOiBmYWxzZVxuICAgIHZhciByYW5nZTtcbiAgICB2YXIgaW1pbiA9IDA7XG4gICAgdmFyIGltYXggPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaW1pbiA8PSBpbWF4KSB7XG4gICAgICAgIHZhciBpbWlkID0gKGltaW4gKyBpbWF4KSA+Pj4gMTtcbiAgICAgICAgcmFuZ2UgPSByYW5nZXNbaW1pZF07XG4gICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPCB2YWx1ZSkge1xuICAgICAgICAgICAgaW1pbiA9IGltaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1heCA9IGltaWQgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbWluID4gMCkge1xuICAgICAgICByYW5nZSA9IHJhbmdlc1tpbWluIC0gMV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJhbmdlLmVuZCkgeyByZXR1cm4gMDsgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkxheW91dFxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIExheW91dChmb250LCB0YWJsZU5hbWUpIHtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuICAgIHRoaXMudGFibGVOYW1lID0gdGFibGVOYW1lO1xufVxuXG5MYXlvdXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEJpbmFyeSBzZWFyY2ggYW4gb2JqZWN0IGJ5IFwidGFnXCIgcHJvcGVydHlcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZnVuY3Rpb24gc2VhcmNoVGFnXG4gICAgICogQG1lbWJlcm9mIG9wZW50eXBlLkxheW91dFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZ1xuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBzZWFyY2hUYWc6IHNlYXJjaFRhZyxcblxuICAgIC8qKlxuICAgICAqIEJpbmFyeSBzZWFyY2ggaW4gYSBsaXN0IG9mIG51bWJlcnNcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZnVuY3Rpb24gYmluU2VhcmNoXG4gICAgICogQG1lbWJlcm9mIG9wZW50eXBlLkxheW91dFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGJpblNlYXJjaDogYmluU2VhcmNoLFxuXG4gICAgLyoqXG4gICAgICogR2V0IG9yIGNyZWF0ZSB0aGUgTGF5b3V0IHRhYmxlIChHU1VCLCBHUE9TIGV0YykuXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gY3JlYXRlIC0gV2hldGhlciB0byBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIEdTVUIgb3IgR1BPUyB0YWJsZS5cbiAgICAgKi9cbiAgICBnZXRUYWJsZTogZnVuY3Rpb24gKGNyZWF0ZSkge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV07XG4gICAgICAgIGlmICghbGF5b3V0ICYmIGNyZWF0ZSkge1xuICAgICAgICAgICAgbGF5b3V0ID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0gPVxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRGVmYXVsdFRhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxheW91dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmVzdCBiZXQgZm9yIGEgc2NyaXB0IG5hbWUuXG4gICAgICogUmV0dXJucyAnREZMVCcgaWYgaXQgZXhpc3RzLlxuICAgICAqIElmIG5vdCwgcmV0dXJucyAnbGF0bicgaWYgaXQgZXhpc3RzLlxuICAgICAqIElmIG5laXRoZXIgZXhpc3QsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRTY3JpcHROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldFRhYmxlKCk7XG4gICAgICAgIGlmICghbGF5b3V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc0xhdG4gPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXQuc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBsYXlvdXQuc2NyaXB0c1tpXS50YWc7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ0RGTFQnKSB7IHJldHVybiBuYW1lOyB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2xhdG4nKSB7IGhhc0xhdG4gPSB0cnVlOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xhdG4pIHsgcmV0dXJuICdsYXRuJzsgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBMYW5nU3lzUmVjb3JkcyBpbiB0aGUgZ2l2ZW4gc2NyaXB0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhpcyBzY3JpcHQgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRhZyBhbmQgc2NyaXB0IHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ2V0U2NyaXB0VGFibGU6IGZ1bmN0aW9uIChzY3JpcHQsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRUYWJsZShjcmVhdGUpO1xuICAgICAgICBpZiAobGF5b3V0KSB7XG4gICAgICAgICAgICBzY3JpcHQgPSBzY3JpcHQgfHwgJ0RGTFQnO1xuICAgICAgICAgICAgdmFyIHNjcmlwdHMgPSBsYXlvdXQuc2NyaXB0cztcbiAgICAgICAgICAgIHZhciBwb3MgPSBzZWFyY2hUYWcobGF5b3V0LnNjcmlwdHMsIHNjcmlwdCk7XG4gICAgICAgICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0c1twb3NdLnNjcmlwdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBzY3JpcHQsXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNlcnZlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlSW5kZXhlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NyaXB0cy5zcGxpY2UoLTEgLSBwb3MsIDAsIHNjcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjci5zY3JpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxhbmd1YWdlIHN5c3RlbSB0YWJsZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhpcyBsYW5nU3lzVGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0TGFuZ1N5c1RhYmxlOiBmdW5jdGlvbiAoc2NyaXB0LCBsYW5ndWFnZSwgY3JlYXRlKSB7XG4gICAgICAgIHZhciBzY3JpcHRUYWJsZSA9IHRoaXMuZ2V0U2NyaXB0VGFibGUoc2NyaXB0LCBjcmVhdGUpO1xuICAgICAgICBpZiAoc2NyaXB0VGFibGUpIHtcbiAgICAgICAgICAgIGlmICghbGFuZ3VhZ2UgfHwgbGFuZ3VhZ2UgPT09ICdkZmx0JyB8fCBsYW5ndWFnZSA9PT0gJ0RGTFQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFRhYmxlLmRlZmF1bHRMYW5nU3lzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBvcyA9IHNlYXJjaFRhZyhzY3JpcHRUYWJsZS5sYW5nU3lzUmVjb3JkcywgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzW3Bvc10ubGFuZ1N5cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmdTeXNSZWNvcmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogbGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGxhbmdTeXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2VydmVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxRmVhdHVyZUluZGV4OiAweGZmZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlSW5kZXhlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY3JpcHRUYWJsZS5sYW5nU3lzUmVjb3Jkcy5zcGxpY2UoLTEgLSBwb3MsIDAsIGxhbmdTeXNSZWNvcmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5nU3lzUmVjb3JkLmxhbmdTeXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3BlY2lmaWMgZmVhdHVyZSB0YWJsZS5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGxmdCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSBPbmUgb2YgdGhlIGNvZGVzIGxpc3RlZCBhdCBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2ZlYXR1cmVsaXN0Lmh0bVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGUgZmVhdHVyZSB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRGZWF0dXJlVGFibGU6IGZ1bmN0aW9uIChzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIGxhbmdTeXNUYWJsZSA9IHRoaXMuZ2V0TGFuZ1N5c1RhYmxlKHNjcmlwdCwgbGFuZ3VhZ2UsIGNyZWF0ZSk7XG4gICAgICAgIGlmIChsYW5nU3lzVGFibGUpIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlUmVjb3JkO1xuICAgICAgICAgICAgdmFyIGZlYXRJbmRleGVzID0gbGFuZ1N5c1RhYmxlLmZlYXR1cmVJbmRleGVzO1xuICAgICAgICAgICAgdmFyIGFsbEZlYXR1cmVzID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0uZmVhdHVyZXM7XG4gICAgICAgICAgICAvLyBUaGUgRmVhdHVyZUluZGV4IGFycmF5IG9mIGluZGljZXMgaXMgaW4gYXJiaXRyYXJ5IG9yZGVyLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiBhbGxGZWF0dXJlcyBpcyBzb3J0ZWQgYWxwaGFiZXRpY2FsbHkgYnkgZmVhdHVyZSB0YWcuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZVJlY29yZCA9IGFsbEZlYXR1cmVzW2ZlYXRJbmRleGVzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZVJlY29yZC50YWcgPT09IGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYWxsRmVhdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIEF1dG9tYXRpYyBvcmRlcmluZyBvZiBmZWF0dXJlcyB3b3VsZCByZXF1aXJlIHRvIHNoaWZ0IGZlYXR1cmUgaW5kZXhlcyBpbiB0aGUgc2NyaXB0IGxpc3QuXG4gICAgICAgICAgICAgICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9PT0gMCB8fCBmZWF0dXJlID49IGFsbEZlYXR1cmVzW2luZGV4IC0gMV0udGFnLFxuICAgICAgICAgICAgICAgICAgICAnRmVhdHVyZXMgbXVzdCBiZSBhZGRlZCBpbiBhbHBoYWJldGljYWwgb3JkZXIuJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZmVhdHVyZVJlY29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBmZWF0dXJlLFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlOiB7IHBhcmFtczogMCwgbG9va3VwTGlzdEluZGV4ZXM6IFtdIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcy5wdXNoKGZlYXR1cmVSZWNvcmQpO1xuICAgICAgICAgICAgICAgIGZlYXRJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlUmVjb3JkLmZlYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsb29rdXAgdGFibGVzIG9mIGEgZ2l2ZW4gdHlwZSBmb3IgYSBzY3JpcHQvbGFuZ3VhZ2UvZmVhdHVyZS5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGxmdCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIGNvZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9va3VwVHlwZSAtIDEgdG8gOVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGUgbG9va3VwIHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QsIHdpdGggbm8gc3VidGFibGVzLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgICAqL1xuICAgIGdldExvb2t1cFRhYmxlczogZnVuY3Rpb24gKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGxvb2t1cFR5cGUsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgZmVhdHVyZVRhYmxlID0gdGhpcy5nZXRGZWF0dXJlVGFibGUoXG4gICAgICAgICAgICBzY3JpcHQsXG4gICAgICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgICAgIGZlYXR1cmUsXG4gICAgICAgICAgICBjcmVhdGVcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHRhYmxlcyA9IFtdO1xuICAgICAgICBpZiAoZmVhdHVyZVRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgbG9va3VwVGFibGU7XG4gICAgICAgICAgICB2YXIgbG9va3VwTGlzdEluZGV4ZXMgPSBmZWF0dXJlVGFibGUubG9va3VwTGlzdEluZGV4ZXM7XG4gICAgICAgICAgICB2YXIgYWxsTG9va3VwcyA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdLmxvb2t1cHM7XG4gICAgICAgICAgICAvLyBsb29rdXBMaXN0SW5kZXhlcyBhcmUgaW4gbm8gcGFydGljdWxhciBvcmRlciwgc28gdXNlIG5haXZlIHNlYXJjaC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9va3VwTGlzdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZSA9IGFsbExvb2t1cHNbbG9va3VwTGlzdEluZGV4ZXNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChsb29rdXBUYWJsZS5sb29rdXBUeXBlID09PSBsb29rdXBUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlcy5wdXNoKGxvb2t1cFRhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFibGVzLmxlbmd0aCA9PT0gMCAmJiBjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwVHlwZTogbG9va3VwVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwRmxhZzogMCxcbiAgICAgICAgICAgICAgICAgICAgc3VidGFibGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgbWFya0ZpbHRlcmluZ1NldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYWxsTG9va3Vwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYWxsTG9va3Vwcy5wdXNoKGxvb2t1cFRhYmxlKTtcbiAgICAgICAgICAgICAgICBsb29rdXBMaXN0SW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xvb2t1cFRhYmxlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFibGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgZ2x5cGggaW4gYSBjbGFzcyBkZWZpbml0aW9uIHRhYmxlXG4gICAgICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2NoYXB0ZXIyI2NsYXNzLWRlZmluaXRpb24tdGFibGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2xhc3NEZWZUYWJsZSAtIGFuIE9wZW5UeXBlIExheW91dCBjbGFzcyBkZWZpbml0aW9uIHRhYmxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdseXBoSW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGdseXBoIHRvIGZpbmRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRHbHlwaENsYXNzOiBmdW5jdGlvbiAoY2xhc3NEZWZUYWJsZSwgZ2x5cGhJbmRleCkge1xuICAgICAgICBzd2l0Y2ggKGNsYXNzRGVmVGFibGUuZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBjbGFzc0RlZlRhYmxlLnN0YXJ0R2x5cGggPD0gZ2x5cGhJbmRleCAmJlxuICAgICAgICAgICAgICAgICAgICBnbHlwaEluZGV4IDxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzRGVmVGFibGUuc3RhcnRHbHlwaCArIGNsYXNzRGVmVGFibGUuY2xhc3Nlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzRGVmVGFibGUuY2xhc3Nlc1tcbiAgICAgICAgICAgICAgICAgICAgICAgIGdseXBoSW5kZXggLSBjbGFzc0RlZlRhYmxlLnN0YXJ0R2x5cGhcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VhcmNoUmFuZ2UoY2xhc3NEZWZUYWJsZS5yYW5nZXMsIGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZSA/IHJhbmdlLmNsYXNzSWQgOiAwO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBnbHlwaCBpbiBhIGNvdmVyYWdlIHRhYmxlXG4gICAgICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2NoYXB0ZXIyI2NvdmVyYWdlLXRhYmxlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvdmVyYWdlVGFibGUgLSBhbiBPcGVuVHlwZSBMYXlvdXQgY292ZXJhZ2UgdGFibGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgZ2x5cGggdG8gZmluZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0xIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldENvdmVyYWdlSW5kZXg6IGZ1bmN0aW9uIChjb3ZlcmFnZVRhYmxlLCBnbHlwaEluZGV4KSB7XG4gICAgICAgIHN3aXRjaCAoY292ZXJhZ2VUYWJsZS5mb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiaW5TZWFyY2goY292ZXJhZ2VUYWJsZS5nbHlwaHMsIGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gaW5kZXggOiAtMTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWFyY2hSYW5nZShjb3ZlcmFnZVRhYmxlLnJhbmdlcywgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlID8gcmFuZ2UuaW5kZXggKyBnbHlwaEluZGV4IC0gcmFuZ2Uuc3RhcnQgOiAtMTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGdseXBoIGluZGV4ZXMgb2YgYSBjb3ZlcmFnZSB0YWJsZS5cbiAgICAgKiBGb3JtYXQgMTogdGhlIGxpc3QgaXMgc3RvcmVkIHJhd1xuICAgICAqIEZvcm1hdCAyOiBjb21wYWN0IGxpc3QgYXMgcmFuZ2UgcmVjb3Jkcy5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvdmVyYWdlVGFibGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBleHBhbmRDb3ZlcmFnZTogZnVuY3Rpb24gKGNvdmVyYWdlVGFibGUpIHtcbiAgICAgICAgaWYgKGNvdmVyYWdlVGFibGUuZm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY292ZXJhZ2VUYWJsZS5nbHlwaHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gW107XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gY292ZXJhZ2VUYWJsZS5yYW5nZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaHMucHVzaChqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2x5cGhzO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5cbi8vIFRoZSBQb3NpdGlvbiBvYmplY3QgcHJvdmlkZXMgdXRpbGl0eSBtZXRob2RzIHRvIG1hbmlwdWxhdGVcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Qb3NpdGlvblxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBvcGVudHlwZS5MYXlvdXRcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQb3NpdGlvbihmb250KSB7XG4gICAgTGF5b3V0LmNhbGwodGhpcywgZm9udCwgJ2dwb3MnKTtcbn1cblxuUG9zaXRpb24ucHJvdG90eXBlID0gTGF5b3V0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBJbml0IHNvbWUgZGF0YSBmb3IgZmFzdGVyIGFuZCBlYXNpZXIgYWNjZXNzIGxhdGVyLlxuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY3JpcHQgPSB0aGlzLmdldERlZmF1bHRTY3JpcHROYW1lKCk7XG4gICAgdGhpcy5kZWZhdWx0S2VybmluZ1RhYmxlcyA9IHRoaXMuZ2V0S2VybmluZ1RhYmxlcyhzY3JpcHQpO1xufTtcblxuLyoqXG4gKiBGaW5kIGEgZ2x5cGggcGFpciBpbiBhIGxpc3Qgb2YgbG9va3VwIHRhYmxlcyBvZiB0eXBlIDIgYW5kIHJldHJpZXZlIHRoZSB4QWR2YW5jZSBrZXJuaW5nIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbGVmdEluZGV4IC0gbGVmdCBnbHlwaCBpbmRleFxuICogQHBhcmFtIHtpbnRlZ2VyfSByaWdodEluZGV4IC0gcmlnaHQgZ2x5cGggaW5kZXhcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0S2VybmluZ1ZhbHVlID0gZnVuY3Rpb24oa2VybmluZ0xvb2t1cHMsIGxlZnRJbmRleCwgcmlnaHRJbmRleCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2VybmluZ0xvb2t1cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IGtlcm5pbmdMb29rdXBzW2ldLnN1YnRhYmxlcztcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJ0YWJsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tqXTtcbiAgICAgICAgICAgIHZhciBjb3ZJbmRleCA9IHRoaXMuZ2V0Q292ZXJhZ2VJbmRleChzdWJ0YWJsZS5jb3ZlcmFnZSwgbGVmdEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjb3ZJbmRleCA8IDApIHsgY29udGludWU7IH1cbiAgICAgICAgICAgIHN3aXRjaCAoc3VidGFibGUucG9zRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggUGFpciBBZGp1c3RtZW50IFBvc2l0aW9uaW5nIEZvcm1hdCAxXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWlyU2V0ID0gc3VidGFibGUucGFpclNldHNbY292SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHBhaXJTZXQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWlyID0gcGFpclNldFtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWlyLnNlY29uZEdseXBoID09PSByaWdodEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIudmFsdWUxICYmIHBhaXIudmFsdWUxLnhBZHZhbmNlIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAgICAgLy8gbGVmdCBnbHlwaCBmb3VuZCwgbm90IHJpZ2h0IGdseXBoIC0gdHJ5IG5leHQgc3VidGFibGVcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBQYWlyIEFkanVzdG1lbnQgUG9zaXRpb25pbmcgRm9ybWF0IDJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzMSA9IHRoaXMuZ2V0R2x5cGhDbGFzcyhzdWJ0YWJsZS5jbGFzc0RlZjEsIGxlZnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzczIgPSB0aGlzLmdldEdseXBoQ2xhc3Moc3VidGFibGUuY2xhc3NEZWYyLCByaWdodEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIkMSA9IHN1YnRhYmxlLmNsYXNzUmVjb3Jkc1tjbGFzczFdW2NsYXNzMl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyJDEudmFsdWUxICYmIHBhaXIkMS52YWx1ZTEueEFkdmFuY2UgfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogTGlzdCBhbGwga2VybmluZyBsb29rdXAgdGFibGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ10gLSB1c2UgZm9udC5wb3NpdGlvbi5nZXREZWZhdWx0U2NyaXB0TmFtZSgpIGZvciBhIGJldHRlciBkZWZhdWx0IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEByZXR1cm4ge29iamVjdFtdfSBUaGUgbGlzdCBvZiBrZXJuaW5nIGxvb2t1cCB0YWJsZXMgKG1heSBiZSBlbXB0eSksIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBHUE9TIHRhYmxlIChhbmQgd2Ugc2hvdWxkIHVzZSB0aGUga2VybiB0YWJsZSlcbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLmdldEtlcm5pbmdUYWJsZXMgPSBmdW5jdGlvbihzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgaWYgKHRoaXMuZm9udC50YWJsZXMuZ3Bvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgJ2tlcm4nLCAyKTtcbiAgICB9XG59O1xuXG4vLyBUaGUgU3Vic3RpdHV0aW9uIG9iamVjdCBwcm92aWRlcyB1dGlsaXR5IG1ldGhvZHMgdG8gbWFuaXB1bGF0ZVxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLlN1YnN0aXR1dGlvblxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBvcGVudHlwZS5MYXlvdXRcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdWJzdGl0dXRpb24oZm9udCkge1xuICAgIExheW91dC5jYWxsKHRoaXMsIGZvbnQsICdnc3ViJyk7XG59XG5cbi8vIENoZWNrIGlmIDIgYXJyYXlzIG9mIHByaW1pdGl2ZXMgYXJlIGVxdWFsLlxuZnVuY3Rpb24gYXJyYXlzRXF1YWwoYXIxLCBhcjIpIHtcbiAgICB2YXIgbiA9IGFyMS5sZW5ndGg7XG4gICAgaWYgKG4gIT09IGFyMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoYXIxW2ldICE9PSBhcjJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gRmluZCB0aGUgZmlyc3Qgc3VidGFibGUgb2YgYSBsb29rdXAgdGFibGUgaW4gYSBwYXJ0aWN1bGFyIGZvcm1hdC5cbmZ1bmN0aW9uIGdldFN1YnN0Rm9ybWF0KGxvb2t1cFRhYmxlLCBmb3JtYXQsIGRlZmF1bHRTdWJ0YWJsZSkge1xuICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZS5zdWJ0YWJsZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICBpZiAoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IGZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnRhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U3VidGFibGUpIHtcbiAgICAgICAgc3VidGFibGVzLnB1c2goZGVmYXVsdFN1YnRhYmxlKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdWJ0YWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuU3Vic3RpdHV0aW9uLnByb3RvdHlwZSA9IExheW91dC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVmYXVsdCBHU1VCIHRhYmxlLlxuICogQHJldHVybiB7T2JqZWN0fSBnc3ViIC0gVGhlIEdTVUIgdGFibGUuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuY3JlYXRlRGVmYXVsdFRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEdlbmVyYXRlIGEgZGVmYXVsdCBlbXB0eSBHU1VCIHRhYmxlIHdpdGgganVzdCBhIERGTFQgc2NyaXB0IGFuZCBkZmx0IGxhbmcgc3lzLlxuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIHNjcmlwdHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdERkxUJyxcbiAgICAgICAgICAgICAgICBzY3JpcHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2VydmVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxRmVhdHVyZUluZGV4OiAweGZmZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlSW5kZXhlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBbXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSBdLFxuICAgICAgICBmZWF0dXJlczogW10sXG4gICAgICAgIGxvb2t1cHM6IFtdLFxuICAgIH07XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIHNpbmdsZSBzdWJzdGl0dXRpb25zIChsb29rdXAgdHlwZSAxKSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWNoYXJhY3RlciBmZWF0dXJlIG5hbWUgKCdhYWx0JywgJ3NhbHQnLCAnc3MwMScuLi4pXG4gKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0U2luZ2xlID0gZnVuY3Rpb24gKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdO1xuICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAxKTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgdmFyIGogPSAodm9pZCAwKTtcbiAgICAgICAgICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IHN1YnRhYmxlLmRlbHRhR2x5cGhJZDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsgc3ViOiBnbHlwaCwgYnk6IGdseXBoICsgZGVsdGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0ZSA9IHN1YnRhYmxlLnN1YnN0aXR1dGU7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goeyBzdWI6IGdseXBoc1tqXSwgYnk6IHN1YnN0aXR1dGVbal0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzdGl0dXRpb25zO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBtdWx0aXBsZSBzdWJzdGl0dXRpb25zIChsb29rdXAgdHlwZSAyKSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWNoYXJhY3RlciBmZWF0dXJlIG5hbWUgKCdjY21wJywgJ3N0Y2gnKVxuICogQHJldHVybiB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgLSBUaGUgbGlzdCBvZiBzdWJzdGl0dXRpb25zLlxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldE11bHRpcGxlID0gZnVuY3Rpb24gKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdO1xuICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAyKTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgdmFyIGogPSAodm9pZCAwKTtcblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnRzID0gc3VidGFibGUuc2VxdWVuY2VzW2pdO1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7IHN1YjogZ2x5cGgsIGJ5OiByZXBsYWNlbWVudHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGFsdGVybmF0ZXMgKGxvb2t1cCB0eXBlIDMpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2FhbHQnLCAnc2FsdCcuLi4pXG4gKiBAcmV0dXJuIHtBcnJheX0gYWx0ZXJuYXRlcyAtIFRoZSBsaXN0IG9mIGFsdGVybmF0ZXNcbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRBbHRlcm5hdGVzID0gZnVuY3Rpb24gKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgYWx0ZXJuYXRlcyA9IFtdO1xuICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAzKTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgdmFyIGFsdGVybmF0ZVNldHMgPSBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGVzLnB1c2goeyBzdWI6IGdseXBoc1tqXSwgYnk6IGFsdGVybmF0ZVNldHNbal0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsdGVybmF0ZXM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGxpZ2F0dXJlcyAobG9va3VwIHR5cGUgNCkgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG4gKiBUaGUgcmVzdWx0IGlzIGFuIGFycmF5IG9mIGxpZ2F0dXJlIG9iamVjdHMgbGlrZSB7IHN1YjogW2lkc10sIGJ5OiBpZCB9XG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHJldHVybiB7QXJyYXl9IGxpZ2F0dXJlcyAtIFRoZSBsaXN0IG9mIGxpZ2F0dXJlcy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRMaWdhdHVyZXMgPSBmdW5jdGlvbiAoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciBsaWdhdHVyZXMgPSBbXTtcbiAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgNCk7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbG9va3VwVGFibGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlc1tpZHhdLnN1YnRhYmxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSB0aGlzLmV4cGFuZENvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICAgICAgICAgIHZhciBsaWdhdHVyZVNldHMgPSBzdWJ0YWJsZS5saWdhdHVyZVNldHM7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEdseXBoID0gZ2x5cGhzW2pdO1xuICAgICAgICAgICAgICAgIHZhciBsaWdTZXQgPSBsaWdhdHVyZVNldHNbal07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaWdTZXQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpZyA9IGxpZ1NldFtrXTtcbiAgICAgICAgICAgICAgICAgICAgbGlnYXR1cmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBbc3RhcnRHbHlwaF0uY29uY2F0KGxpZy5jb21wb25lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5OiBsaWcubGlnR2x5cGgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlnYXR1cmVzO1xufTtcblxuLyoqXG4gKiBBZGQgb3IgbW9kaWZ5IGEgc2luZ2xlIHN1YnN0aXR1dGlvbiAobG9va3VwIHR5cGUgMSlcbiAqIEZvcm1hdCAyLCBtb3JlIGZsZXhpYmxlLCBpcyBhbHdheXMgdXNlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtPYmplY3R9IHN1YnN0aXR1dGlvbiAtIHsgc3ViOiBpZCwgYnk6IGlkIH0gKGZvcm1hdCAxIGlzIG5vdCBzdXBwb3J0ZWQpXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRTaW5nbGUgPSBmdW5jdGlvbiAoXG4gICAgZmVhdHVyZSxcbiAgICBzdWJzdGl0dXRpb24sXG4gICAgc2NyaXB0LFxuICAgIGxhbmd1YWdlXG4pIHtcbiAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhcbiAgICAgICAgc2NyaXB0LFxuICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgMSxcbiAgICAgICAgdHJ1ZVxuICAgIClbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIDIsIHtcbiAgICAgICAgLy8gbG9va3VwIHR5cGUgMSBzdWJ0YWJsZSwgZm9ybWF0IDIsIGNvdmVyYWdlIGZvcm1hdCAxXG4gICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuICAgICAgICBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSxcbiAgICAgICAgc3Vic3RpdHV0ZTogW10sXG4gICAgfSk7XG4gICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsXG4gICAgICAgICdTaW5nbGU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgK1xuICAgICAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0XG4gICAgKTtcbiAgICB2YXIgY292ZXJhZ2VHbHlwaCA9IHN1YnN0aXR1dGlvbi5zdWI7XG4gICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUuc3Vic3RpdHV0ZS5zcGxpY2UocG9zLCAwLCAwKTtcbiAgICB9XG4gICAgc3VidGFibGUuc3Vic3RpdHV0ZVtwb3NdID0gc3Vic3RpdHV0aW9uLmJ5O1xufTtcblxuLyoqXG4gKiBBZGQgb3IgbW9kaWZ5IGEgbXVsdGlwbGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAyKVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdjY21wJywgJ3N0Y2gnKVxuICogQHBhcmFtIHtPYmplY3R9IHN1YnN0aXR1dGlvbiAtIHsgc3ViOiBpZCwgYnk6IFtpZF0gfSBmb3IgZm9ybWF0IDIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRNdWx0aXBsZSA9IGZ1bmN0aW9uIChcbiAgICBmZWF0dXJlLFxuICAgIHN1YnN0aXR1dGlvbixcbiAgICBzY3JpcHQsXG4gICAgbGFuZ3VhZ2Vcbikge1xuICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgc3Vic3RpdHV0aW9uLmJ5IGluc3RhbmNlb2YgQXJyYXkgJiYgc3Vic3RpdHV0aW9uLmJ5Lmxlbmd0aCA+IDEsXG4gICAgICAgICdNdWx0aXBsZTogXCJieVwiIG11c3QgYmUgYW4gYXJyYXkgb2YgdHdvIG9yIG1vcmUgaWRzJ1xuICAgICk7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoXG4gICAgICAgIHNjcmlwdCxcbiAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgIGZlYXR1cmUsXG4gICAgICAgIDIsXG4gICAgICAgIHRydWVcbiAgICApWzBdO1xuICAgIHZhciBzdWJ0YWJsZSA9IGdldFN1YnN0Rm9ybWF0KGxvb2t1cFRhYmxlLCAxLCB7XG4gICAgICAgIC8vIGxvb2t1cCB0eXBlIDIgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgY292ZXJhZ2U6IHsgZm9ybWF0OiAxLCBnbHlwaHM6IFtdIH0sXG4gICAgICAgIHNlcXVlbmNlczogW10sXG4gICAgfSk7XG4gICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsXG4gICAgICAgICdNdWx0aXBsZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArXG4gICAgICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXRcbiAgICApO1xuICAgIHZhciBjb3ZlcmFnZUdseXBoID0gc3Vic3RpdHV0aW9uLnN1YjtcbiAgICB2YXIgcG9zID0gdGhpcy5iaW5TZWFyY2goc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLCBjb3ZlcmFnZUdseXBoKTtcbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgPSAtMSAtIHBvcztcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgICBzdWJ0YWJsZS5zZXF1ZW5jZXMuc3BsaWNlKHBvcywgMCwgMCk7XG4gICAgfVxuICAgIHN1YnRhYmxlLnNlcXVlbmNlc1twb3NdID0gc3Vic3RpdHV0aW9uLmJ5O1xufTtcblxuLyoqXG4gKiBBZGQgb3IgbW9kaWZ5IGFuIGFsdGVybmF0ZSBzdWJzdGl0dXRpb24gKGxvb2t1cCB0eXBlIDMpXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzdGl0dXRpb24gLSB7IHN1YjogaWQsIGJ5OiBbaWRzXSB9XG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRBbHRlcm5hdGUgPSBmdW5jdGlvbiAoXG4gICAgZmVhdHVyZSxcbiAgICBzdWJzdGl0dXRpb24sXG4gICAgc2NyaXB0LFxuICAgIGxhbmd1YWdlXG4pIHtcbiAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhcbiAgICAgICAgc2NyaXB0LFxuICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgMyxcbiAgICAgICAgdHJ1ZVxuICAgIClbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIDEsIHtcbiAgICAgICAgLy8gbG9va3VwIHR5cGUgMyBzdWJ0YWJsZSwgZm9ybWF0IDEsIGNvdmVyYWdlIGZvcm1hdCAxXG4gICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSxcbiAgICAgICAgYWx0ZXJuYXRlU2V0czogW10sXG4gICAgfSk7XG4gICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsXG4gICAgICAgICdBbHRlcm5hdGU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgK1xuICAgICAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0XG4gICAgKTtcbiAgICB2YXIgY292ZXJhZ2VHbHlwaCA9IHN1YnN0aXR1dGlvbi5zdWI7XG4gICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUuYWx0ZXJuYXRlU2V0cy5zcGxpY2UocG9zLCAwLCAwKTtcbiAgICB9XG4gICAgc3VidGFibGUuYWx0ZXJuYXRlU2V0c1twb3NdID0gc3Vic3RpdHV0aW9uLmJ5O1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaWdhdHVyZSAobG9va3VwIHR5cGUgNClcbiAqIExpZ2F0dXJlcyB3aXRoIG1vcmUgY29tcG9uZW50cyBtdXN0IGJlIHN0b3JlZCBhaGVhZCBvZiB0aG9zZSB3aXRoIGZld2VyIGNvbXBvbmVudHMgaW4gb3JkZXIgdG8gYmUgZm91bmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtPYmplY3R9IGxpZ2F0dXJlIC0geyBzdWI6IFtpZHNdLCBieTogaWQgfVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkTGlnYXR1cmUgPSBmdW5jdGlvbiAoXG4gICAgZmVhdHVyZSxcbiAgICBsaWdhdHVyZSxcbiAgICBzY3JpcHQsXG4gICAgbGFuZ3VhZ2Vcbikge1xuICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKFxuICAgICAgICBzY3JpcHQsXG4gICAgICAgIGxhbmd1YWdlLFxuICAgICAgICBmZWF0dXJlLFxuICAgICAgICA0LFxuICAgICAgICB0cnVlXG4gICAgKVswXTtcbiAgICB2YXIgc3VidGFibGUgPSBsb29rdXBUYWJsZS5zdWJ0YWJsZXNbMF07XG4gICAgaWYgKCFzdWJ0YWJsZSkge1xuICAgICAgICBzdWJ0YWJsZSA9IHtcbiAgICAgICAgICAgIC8vIGxvb2t1cCB0eXBlIDQgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSxcbiAgICAgICAgICAgIGxpZ2F0dXJlU2V0czogW10sXG4gICAgICAgIH07XG4gICAgICAgIGxvb2t1cFRhYmxlLnN1YnRhYmxlc1swXSA9IHN1YnRhYmxlO1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSxcbiAgICAgICAgJ0xpZ2F0dXJlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICtcbiAgICAgICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdFxuICAgICk7XG4gICAgdmFyIGNvdmVyYWdlR2x5cGggPSBsaWdhdHVyZS5zdWJbMF07XG4gICAgdmFyIGxpZ0NvbXBvbmVudHMgPSBsaWdhdHVyZS5zdWIuc2xpY2UoMSk7XG4gICAgdmFyIGxpZ2F0dXJlVGFibGUgPSB7XG4gICAgICAgIGxpZ0dseXBoOiBsaWdhdHVyZS5ieSxcbiAgICAgICAgY29tcG9uZW50czogbGlnQ29tcG9uZW50cyxcbiAgICB9O1xuICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAvLyBsaWdhdHVyZVNldCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICB2YXIgbGlnYXR1cmVTZXQgPSBzdWJ0YWJsZS5saWdhdHVyZVNldHNbcG9zXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaWdhdHVyZVNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gSWYgbGlnYXR1cmUgYWxyZWFkeSBleGlzdHMsIHJldHVybi5cbiAgICAgICAgICAgIGlmIChhcnJheXNFcXVhbChsaWdhdHVyZVNldFtpXS5jb21wb25lbnRzLCBsaWdDb21wb25lbnRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsaWdhdHVyZSBkb2VzIG5vdCBleGlzdDogYWRkIGl0LlxuICAgICAgICBsaWdhdHVyZVNldC5wdXNoKGxpZ2F0dXJlVGFibGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBsaWdhdHVyZVNldCBhbmQgYWRkIGNvdmVyYWdlIGZvciB0aGUgZmlyc3QgZ2x5cGguXG4gICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgIHN1YnRhYmxlLmxpZ2F0dXJlU2V0cy5zcGxpY2UocG9zLCAwLCBbbGlnYXR1cmVUYWJsZV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGlzdCBhbGwgZmVhdHVyZSBkYXRhIGZvciBhIGdpdmVuIHNjcmlwdCBhbmQgbGFuZ3VhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0RmVhdHVyZSA9IGZ1bmN0aW9uIChmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgaWYgKC9zc1xcZFxcZC8udGVzdChmZWF0dXJlKSkge1xuICAgICAgICAvLyBzczAxIC0gc3MyMFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTaW5nbGUoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgfVxuICAgIHN3aXRjaCAoZmVhdHVyZSkge1xuICAgICAgICBjYXNlICdhYWx0JzpcbiAgICAgICAgY2FzZSAnc2FsdCc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaW5nbGUoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkuY29uY2F0KFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QWx0ZXJuYXRlcyhmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAnZGxpZyc6XG4gICAgICAgIGNhc2UgJ2xpZ2EnOlxuICAgICAgICBjYXNlICdybGlnJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExpZ2F0dXJlcyhmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgY2FzZSAnY2NtcCc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNdWx0aXBsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKS5jb25jYXQoXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRMaWdhdHVyZXMoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgJ3N0Y2gnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TXVsdGlwbGUoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEFkZCBhIHN1YnN0aXR1dGlvbiB0byBhIGZlYXR1cmUgZm9yIGEgZ2l2ZW4gc2NyaXB0IGFuZCBsYW5ndWFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gc3ViIC0gdGhlIHN1YnN0aXR1dGlvbiB0byBhZGQgKGFuIG9iamVjdCBsaWtlIHsgc3ViOiBpZCBvciBbaWRzXSwgYnk6IGlkIG9yIFtpZHNdIH0pXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgaWYgKC9zc1xcZFxcZC8udGVzdChmZWF0dXJlKSkge1xuICAgICAgICAvLyBzczAxIC0gc3MyMFxuICAgICAgICByZXR1cm4gdGhpcy5hZGRTaW5nbGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgc3dpdGNoIChmZWF0dXJlKSB7XG4gICAgICAgIGNhc2UgJ2FhbHQnOlxuICAgICAgICBjYXNlICdzYWx0JzpcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ViLmJ5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFNpbmdsZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQWx0ZXJuYXRlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgIGNhc2UgJ2RsaWcnOlxuICAgICAgICBjYXNlICdsaWdhJzpcbiAgICAgICAgY2FzZSAncmxpZyc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRMaWdhdHVyZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICBjYXNlICdjY21wJzpcbiAgICAgICAgICAgIGlmIChzdWIuYnkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZE11bHRpcGxlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRMaWdhdHVyZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZnVuY3Rpb24gY2hlY2tBcmd1bWVudChleHByZXNzaW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxufVxuXG4vLyBQYXJzaW5nIHV0aWxpdHkgZnVuY3Rpb25zXG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIGJ5dGUgZnJvbSB0aGUgRGF0YVZpZXcuXG5mdW5jdGlvbiBnZXRCeXRlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbn1cblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0VVNob3J0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCwgZmFsc2UpO1xufVxuXG4vLyBSZXRyaWV2ZSBhIHNpZ25lZCAxNi1iaXQgc2hvcnQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5mdW5jdGlvbiBnZXRTaG9ydChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldEludDE2KG9mZnNldCwgZmFsc2UpO1xufVxuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCAzMi1iaXQgbG9uZyBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmZ1bmN0aW9uIGdldFVMb25nKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xufVxuXG4vLyBSZXRyaWV2ZSBhIDMyLWJpdCBzaWduZWQgZml4ZWQtcG9pbnQgbnVtYmVyICgxNi4xNikgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5mdW5jdGlvbiBnZXRGaXhlZChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIGRlY2ltYWwgPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcbiAgICB2YXIgZnJhY3Rpb24gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMiwgZmFsc2UpO1xuICAgIHJldHVybiBkZWNpbWFsICsgZnJhY3Rpb24gLyA2NTUzNTtcbn1cblxuLy8gUmV0cmlldmUgYSA0LWNoYXJhY3RlciB0YWcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUYWdzIGFyZSB1c2VkIHRvIGlkZW50aWZ5IHRhYmxlcy5cbmZ1bmN0aW9uIGdldFRhZyhkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIHRhZyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyA0OyBpICs9IDEpIHtcbiAgICAgICAgdGFnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0SW50OChpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZztcbn1cblxuLy8gUmV0cmlldmUgYW4gb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gT2Zmc2V0cyBhcmUgMSB0byA0IGJ5dGVzIGluIGxlbmd0aCwgZGVwZW5kaW5nIG9uIHRoZSBvZmZTaXplIGFyZ3VtZW50LlxuZnVuY3Rpb24gZ2V0T2Zmc2V0KGRhdGFWaWV3LCBvZmZzZXQsIG9mZlNpemUpIHtcbiAgICB2YXIgdiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvZmZTaXplOyBpICs9IDEpIHtcbiAgICAgICAgdiA8PD0gODtcbiAgICAgICAgdiArPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbn1cblxuLy8gUmV0cmlldmUgYSBudW1iZXIgb2YgYnl0ZXMgZnJvbSBzdGFydCBvZmZzZXQgdG8gdGhlIGVuZCBvZmZzZXQgZnJvbSB0aGUgRGF0YVZpZXcuXG5mdW5jdGlvbiBnZXRCeXRlcyhkYXRhVmlldywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHZhciBieXRlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBzdGFydE9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBieXRlcztcbn1cblxuLy8gQ29udmVydCB0aGUgbGlzdCBvZiBieXRlcyB0byBhIHN0cmluZy5cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgICB2YXIgcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcztcbn1cblxudmFyIHR5cGVPZmZzZXRzID0ge1xuICAgIGJ5dGU6IDEsXG4gICAgdVNob3J0OiAyLFxuICAgIHNob3J0OiAyLFxuICAgIHVMb25nOiA0LFxuICAgIGZpeGVkOiA0LFxuICAgIGxvbmdEYXRlVGltZTogOCxcbiAgICB0YWc6IDRcbn07XG5cbi8vIEEgc3RhdGVmdWwgcGFyc2VyIHRoYXQgY2hhbmdlcyB0aGUgb2Zmc2V0IHdoZW5ldmVyIGEgdmFsdWUgaXMgcmV0cmlldmVkLlxuLy8gVGhlIGRhdGEgaXMgYSBEYXRhVmlldy5cbmZ1bmN0aW9uIFBhcnNlcihkYXRhLCBvZmZzZXQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSAwO1xufVxuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNoYXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQ4ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGU7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2FyZDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci5wcm90b3R5cGUucGFyc2VTSUQgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNob3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRjJEb3QxNCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCkgLyAxNjM4NDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MzIgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmc7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGaXhlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZ2V0Rml4ZWQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJpbmcgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgc3RyaW5nID0gJyc7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBsZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VUYWcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZyg0KTtcbn07XG5cbi8vIExPTkdEQVRFVElNRSBpcyBhIDY0LWJpdCBpbnRlZ2VyLlxuLy8gSmF2YVNjcmlwdCBhbmQgdW5peCB0aW1lc3RhbXBzIHRyYWRpdGlvbmFsbHkgdXNlIDMyIGJpdHMsIHNvIHdlXG4vLyBvbmx5IHRha2UgdGhlIGxhc3QgMzIgYml0cy5cbi8vICsgU2luY2UgdW50aWwgMjAzOCB0aG9zZSBiaXRzIHdpbGwgYmUgZmlsbGVkIGJ5IHplcm9zIHdlIGNhbiBpZ25vcmUgdGhlbS5cblBhcnNlci5wcm90b3R5cGUucGFyc2VMb25nRGF0ZVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgNCk7XG4gICAgLy8gU3VidHJhY3Qgc2Vjb25kcyBiZXR3ZWVuIDAxLzAxLzE5MDQgYW5kIDAxLzAxLzE5NzBcbiAgICAvLyB0byBjb252ZXJ0IEFwcGxlIE1hYyB0aW1lc3RhbXAgdG8gU3RhbmRhcmQgVW5peCB0aW1lc3RhbXBcbiAgICB2IC09IDIwODI4NDQ4MDA7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA4O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZlcnNpb24gPSBmdW5jdGlvbihtaW5vckJhc2UpIHtcbiAgICB2YXIgbWFqb3IgPSBnZXRVU2hvcnQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuXG4gICAgLy8gSG93IHRvIGludGVycHJldCB0aGUgbWlub3IgdmVyc2lvbiBpcyB2ZXJ5IHZhZ3VlIGluIHRoZSBzcGVjLiAweDUwMDAgaXMgNSwgMHgxMDAwIGlzIDFcbiAgICAvLyBEZWZhdWx0IHJldHVybnMgdGhlIGNvcnJlY3QgbnVtYmVyIGlmIG1pbm9yID0gMHhOMDAwIHdoZXJlIE4gaXMgMC05XG4gICAgLy8gU2V0IG1pbm9yQmFzZSB0byAxIGZvciB0YWJsZXMgdGhhdCB1c2UgbWlub3IgPSBOIHdoZXJlIE4gaXMgMC05XG4gICAgdmFyIG1pbm9yID0gZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgMik7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIGlmIChtaW5vckJhc2UgPT09IHVuZGVmaW5lZCkgeyBtaW5vckJhc2UgPSAweDEwMDA7IH1cbiAgICByZXR1cm4gbWFqb3IgKyBtaW5vciAvIG1pbm9yQmFzZSAvIDEwO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24odHlwZSwgYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFtb3VudCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSB0eXBlT2Zmc2V0c1t0eXBlXSAqIGFtb3VudDtcbn07XG5cbi8vLy8vIFBhcnNpbmcgbGlzdHMgYW5kIHJlY29yZHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgMzIgYml0IHVuc2lnbmVkIGludGVnZXJzLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nTGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHsgY291bnQgPSB0aGlzLnBhcnNlVUxvbmcoKTsgfVxuICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpXSA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogNDtcbiAgICByZXR1cm4gb2Zmc2V0cztcbn07XG5cbi8vIFBhcnNlIGEgbGlzdCBvZiAxNiBiaXQgdW5zaWduZWQgaW50ZWdlcnMuIFRoZSBsZW5ndGggb2YgdGhlIGxpc3QgY2FuIGJlIHJlYWQgb24gdGhlIHN0cmVhbVxuLy8gb3IgcHJvdmlkZWQgYXMgYW4gYXJndW1lbnQuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTZMaXN0ID1cblBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnRMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgeyBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTsgfVxuICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpXSA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogMjtcbiAgICByZXR1cm4gb2Zmc2V0cztcbn07XG5cbi8vIFBhcnNlcyBhIGxpc3Qgb2YgMTYgYml0IHNpZ25lZCBpbnRlZ2Vycy5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTaG9ydExpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGRhdGFWaWV3LmdldEludDE2KG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQgKiAyO1xuICAgIHJldHVybiBsaXN0O1xufTtcblxuLy8gUGFyc2VzIGEgbGlzdCBvZiBieXRlcy5cblBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlTGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBsaXN0W2ldID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KyspO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQ7XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBpdGVtcy5cbiAqIFJlY29yZCBjb3VudCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAqIGl0ZW1DYWxsYmFjayBpcyBvbmUgb2YgdGhlIFBhcnNlciBtZXRob2RzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICBpZiAoIWl0ZW1DYWxsYmFjaykge1xuICAgICAgICBpdGVtQ2FsbGJhY2sgPSBjb3VudDtcbiAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VMaXN0MzIgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG4gICAgaWYgKCFpdGVtQ2FsbGJhY2spIHtcbiAgICAgICAgaXRlbUNhbGxiYWNrID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVMb25nKCk7XG4gICAgfVxuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBsaXN0IG9mIHJlY29yZHMuXG4gKiBSZWNvcmQgY291bnQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKiBFeGFtcGxlIG9mIHJlY29yZERlc2NyaXB0aW9uOiB7IHNlcXVlbmNlSW5kZXg6IFBhcnNlci51U2hvcnQsIGxvb2t1cExpc3RJbmRleDogUGFyc2VyLnVTaG9ydCB9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VSZWNvcmRMaXN0ID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgLy8gSWYgdGhlIGNvdW50IGFyZ3VtZW50IGlzIGFic2VudCwgcmVhZCBpdCBpbiB0aGUgc3RyZWFtLlxuICAgIGlmICghcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICAgICAgcmVjb3JkRGVzY3JpcHRpb24gPSBjb3VudDtcbiAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuICAgIHZhciByZWNvcmRzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXMocmVjb3JkRGVzY3JpcHRpb24pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgcmVjID0ge307XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGRzW2pdO1xuICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IHJlY29yZERlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICByZWNbZmllbGROYW1lXSA9IGZpZWxkVHlwZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZHNbaV0gPSByZWM7XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlY29yZExpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIC8vIElmIHRoZSBjb3VudCBhcmd1bWVudCBpcyBhYnNlbnQsIHJlYWQgaXQgaW4gdGhlIHN0cmVhbS5cbiAgICBpZiAoIXJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJlY29yZERlc2NyaXB0aW9uID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVMb25nKCk7XG4gICAgfVxuICAgIHZhciByZWNvcmRzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXMocmVjb3JkRGVzY3JpcHRpb24pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgcmVjID0ge307XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGRzW2pdO1xuICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IHJlY29yZERlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICByZWNbZmllbGROYW1lXSA9IGZpZWxkVHlwZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZHNbaV0gPSByZWM7XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzO1xufTtcblxuLy8gUGFyc2UgYSBkYXRhIHN0cnVjdHVyZSBpbnRvIGFuIG9iamVjdFxuLy8gRXhhbXBsZSBvZiBkZXNjcmlwdGlvbjogeyBzZXF1ZW5jZUluZGV4OiBQYXJzZXIudVNob3J0LCBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnQgfVxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cnVjdCA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24uY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXMoZGVzY3JpcHRpb24pO1xuICAgICAgICB2YXIgc3RydWN0ID0ge307XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGRzW2pdO1xuICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IGRlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBzdHJ1Y3RbZmllbGROYW1lXSA9IGZpZWxkVHlwZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJ1Y3Q7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSBhIEdQT1MgdmFsdWVSZWNvcmRcbiAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI3ZhbHVlLXJlY29yZFxuICogdmFsdWVGb3JtYXQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VWYWx1ZVJlY29yZCA9IGZ1bmN0aW9uKHZhbHVlRm9ybWF0KSB7XG4gICAgaWYgKHZhbHVlRm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCA9PT0gMCkge1xuICAgICAgICAvLyB2YWx1ZUZvcm1hdDIgaW4ga2VybmluZyBwYWlycyBpcyBtb3N0IG9mdGVuIDBcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHJldHVybiB1bmRlZmluZWQgaW5zdGVhZCBvZiBhbiBlbXB0eSBvYmplY3QsIHRvIHNhdmUgc3BhY2VcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWVSZWNvcmQgPSB7fTtcblxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwMSkgeyB2YWx1ZVJlY29yZC54UGxhY2VtZW50ID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDIpIHsgdmFsdWVSZWNvcmQueVBsYWNlbWVudCA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDA0KSB7IHZhbHVlUmVjb3JkLnhBZHZhbmNlID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDgpIHsgdmFsdWVSZWNvcmQueUFkdmFuY2UgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuXG4gICAgLy8gRGV2aWNlIHRhYmxlIChub24tdmFyaWFibGUgZm9udCkgLyBWYXJpYXRpb25JbmRleCB0YWJsZSAodmFyaWFibGUgZm9udCkgbm90IHN1cHBvcnRlZFxuICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2ZyLWZyL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9jaGFwdGVyMiNkZXZWYXJJZHhUYmxzXG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDEwKSB7IHZhbHVlUmVjb3JkLnhQbGFEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDIwKSB7IHZhbHVlUmVjb3JkLnlQbGFEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDQwKSB7IHZhbHVlUmVjb3JkLnhBZHZEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDgwKSB7IHZhbHVlUmVjb3JkLnlBZHZEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG5cbiAgICByZXR1cm4gdmFsdWVSZWNvcmQ7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBHUE9TIHZhbHVlUmVjb3Jkc1xuICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjdmFsdWUtcmVjb3JkXG4gKiB2YWx1ZUZvcm1hdCBhbmQgdmFsdWVDb3VudCBhcmUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VWYWx1ZVJlY29yZExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWVGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHZhbHVlQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheSh2YWx1ZUNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgICAgICB2YWx1ZXNbaV0gPSB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBvaW50ZXIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHZhciBzdHJ1Y3RPZmZzZXQgPSB0aGlzLnBhcnNlT2Zmc2V0MTYoKTtcbiAgICBpZiAoc3RydWN0T2Zmc2V0ID4gMCkge1xuICAgICAgICAvLyBOVUxMIG9mZnNldCA9PiByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyBzdHJ1Y3RPZmZzZXQpLnBhcnNlU3RydWN0KGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VQb2ludGVyMzIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHZhciBzdHJ1Y3RPZmZzZXQgPSB0aGlzLnBhcnNlT2Zmc2V0MzIoKTtcbiAgICBpZiAoc3RydWN0T2Zmc2V0ID4gMCkge1xuICAgICAgICAvLyBOVUxMIG9mZnNldCA9PiByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyBzdHJ1Y3RPZmZzZXQpLnBhcnNlU3RydWN0KGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBsaXN0IG9mIG9mZnNldHMgdG8gbGlzdHMgb2YgMTYtYml0IGludGVnZXJzLFxuICogb3IgYSBsaXN0IG9mIG9mZnNldHMgdG8gbGlzdHMgb2Ygb2Zmc2V0cyB0byBhbnkga2luZCBvZiBpdGVtcy5cbiAqIElmIGl0ZW1DYWxsYmFjayBpcyBub3QgcHJvdmlkZWQsIGEgbGlzdCBvZiBsaXN0IG9mIFVTaG9ydCBpcyBhc3N1bWVkLlxuICogSWYgcHJvdmlkZWQsIGl0ZW1DYWxsYmFjayBpcyBjYWxsZWQgb24gZWFjaCBpdGVtIGFuZCBtdXN0IHBhcnNlIHRoZSBpdGVtLlxuICogU2VlIGV4YW1wbGVzIGluIHRhYmxlcy9nc3ViLmpzXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VMaXN0T2ZMaXN0cyA9IGZ1bmN0aW9uKGl0ZW1DYWxsYmFjaykge1xuICAgIHZhciBvZmZzZXRzID0gdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpO1xuICAgIHZhciBjb3VudCA9IG9mZnNldHMubGVuZ3RoO1xuICAgIHZhciByZWxhdGl2ZU9mZnNldCA9IHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXRzW2ldO1xuICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5VTEwgb2Zmc2V0XG4gICAgICAgICAgICAvLyBBZGQgaSBhcyBvd25lZCBwcm9wZXJ0eSB0byBsaXN0LiBDb252ZW5pZW50IHdpdGggYXNzZXJ0LlxuICAgICAgICAgICAgbGlzdFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSBzdGFydDtcbiAgICAgICAgaWYgKGl0ZW1DYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHN1Yk9mZnNldHMgPSB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KCk7XG4gICAgICAgICAgICB2YXIgc3ViTGlzdCA9IG5ldyBBcnJheShzdWJPZmZzZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yk9mZnNldHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gc3RhcnQgKyBzdWJPZmZzZXRzW2pdO1xuICAgICAgICAgICAgICAgIHN1Ykxpc3Rbal0gPSBpdGVtQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RbaV0gPSBzdWJMaXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdFtpXSA9IHRoaXMucGFyc2VVU2hvcnRMaXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IHJlbGF0aXZlT2Zmc2V0O1xuICAgIHJldHVybiBsaXN0O1xufTtcblxuLy8vLy8gQ29tcGxleCB0YWJsZXMgcGFyc2luZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFBhcnNlIGEgY292ZXJhZ2UgdGFibGUgaW4gYSBHU1VCLCBHUE9TIG9yIEdERUYgdGFibGUuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXB0ZXIyLmh0bVxuLy8gcGFyc2VyLm9mZnNldCBtdXN0IHBvaW50IHRvIHRoZSBzdGFydCBvZiB0aGUgdGFibGUgY29udGFpbmluZyB0aGUgY292ZXJhZ2UuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ292ZXJhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAxLFxuICAgICAgICAgICAgZ2x5cGhzOiB0aGlzLnBhcnNlVVNob3J0TGlzdChjb3VudClcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB2YXIgcmFuZ2VzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByYW5nZXNbaV0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICBlbmQ6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5wYXJzZVVTaG9ydCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IDIsXG4gICAgICAgICAgICByYW5nZXM6IHJhbmdlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJzB4JyArIHN0YXJ0T2Zmc2V0LnRvU3RyaW5nKDE2KSArICc6IENvdmVyYWdlIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbi8vIFBhcnNlIGEgQ2xhc3MgRGVmaW5pdGlvbiBUYWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NEZWYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IDEsXG4gICAgICAgICAgICBzdGFydEdseXBoOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICBjbGFzc2VzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMixcbiAgICAgICAgICAgIHJhbmdlczogdGhpcy5wYXJzZVJlY29yZExpc3Qoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBQYXJzZXIudVNob3J0LFxuICAgICAgICAgICAgICAgIGVuZDogUGFyc2VyLnVTaG9ydCxcbiAgICAgICAgICAgICAgICBjbGFzc0lkOiBQYXJzZXIudVNob3J0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJzB4JyArIHN0YXJ0T2Zmc2V0LnRvU3RyaW5nKDE2KSArICc6IENsYXNzRGVmIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbi8vLy8vIFN0YXRpYyBtZXRob2RzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUaGVzZSBjb252ZW5pZW5jZSBtZXRob2RzIGNhbiBiZSB1c2VkIGFzIGNhbGxiYWNrcyBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIFwidGhpc1wiIGNvbnRleHQgc2V0IHRvIGEgUGFyc2VyIGluc3RhbmNlLlxuXG5QYXJzZXIubGlzdCA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdChjb3VudCwgaXRlbUNhbGxiYWNrKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLmxpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdDMyKGNvdW50LCBpdGVtQ2FsbGJhY2spO1xuICAgIH07XG59O1xuXG5QYXJzZXIucmVjb3JkTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWNvcmRMaXN0KGNvdW50LCByZWNvcmREZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci5yZWNvcmRMaXN0MzIgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVjb3JkTGlzdDMyKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci5wb2ludGVyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihkZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci5wb2ludGVyMzIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyMzIoZGVzY3JpcHRpb24pO1xuICAgIH07XG59O1xuXG5QYXJzZXIudGFnID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRhZztcblBhcnNlci5ieXRlID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGU7XG5QYXJzZXIudVNob3J0ID0gUGFyc2VyLm9mZnNldDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci51U2hvcnRMaXN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydExpc3Q7XG5QYXJzZXIudUxvbmcgPSBQYXJzZXIub2Zmc2V0MzIgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmc7XG5QYXJzZXIudUxvbmdMaXN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nTGlzdDtcblBhcnNlci5zdHJ1Y3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RydWN0O1xuUGFyc2VyLmNvdmVyYWdlID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvdmVyYWdlO1xuUGFyc2VyLmNsYXNzRGVmID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVmO1xuXG4vLy8vLyBTY3JpcHQsIEZlYXR1cmUsIExvb2t1cCBsaXN0cyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cblxudmFyIGxhbmdTeXNUYWJsZSA9IHtcbiAgICByZXNlcnZlZDogUGFyc2VyLnVTaG9ydCxcbiAgICByZXFGZWF0dXJlSW5kZXg6IFBhcnNlci51U2hvcnQsXG4gICAgZmVhdHVyZUluZGV4ZXM6IFBhcnNlci51U2hvcnRMaXN0XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU2NyaXB0TGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIucmVjb3JkTGlzdCh7XG4gICAgICAgIHRhZzogUGFyc2VyLnRhZyxcbiAgICAgICAgc2NyaXB0OiBQYXJzZXIucG9pbnRlcih7XG4gICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czogUGFyc2VyLnBvaW50ZXIobGFuZ1N5c1RhYmxlKSxcbiAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBQYXJzZXIucmVjb3JkTGlzdCh7XG4gICAgICAgICAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuICAgICAgICAgICAgICAgIGxhbmdTeXM6IFBhcnNlci5wb2ludGVyKGxhbmdTeXNUYWJsZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfSkpIHx8IFtdO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZlYXR1cmVMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5yZWNvcmRMaXN0KHtcbiAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuICAgICAgICBmZWF0dXJlOiBQYXJzZXIucG9pbnRlcih7XG4gICAgICAgICAgICBmZWF0dXJlUGFyYW1zOiBQYXJzZXIub2Zmc2V0MTYsXG4gICAgICAgICAgICBsb29rdXBMaXN0SW5kZXhlczogUGFyc2VyLnVTaG9ydExpc3RcbiAgICAgICAgfSlcbiAgICB9KSkgfHwgW107XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTG9va3VwTGlzdCA9IGZ1bmN0aW9uKGxvb2t1cFRhYmxlUGFyc2Vycykge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIubGlzdChQYXJzZXIucG9pbnRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxvb2t1cFR5cGUgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KDEgPD0gbG9va3VwVHlwZSAmJiBsb29rdXBUeXBlIDw9IDksICdHUE9TL0dTVUIgbG9va3VwIHR5cGUgJyArIGxvb2t1cFR5cGUgKyAnIHVua25vd24uJyk7XG4gICAgICAgIHZhciBsb29rdXBGbGFnID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgdXNlTWFya0ZpbHRlcmluZ1NldCA9IGxvb2t1cEZsYWcgJiAweDEwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9va3VwVHlwZTogbG9va3VwVHlwZSxcbiAgICAgICAgICAgIGxvb2t1cEZsYWc6IGxvb2t1cEZsYWcsXG4gICAgICAgICAgICBzdWJ0YWJsZXM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKGxvb2t1cFRhYmxlUGFyc2Vyc1tsb29rdXBUeXBlXSkpLFxuICAgICAgICAgICAgbWFya0ZpbHRlcmluZ1NldDogdXNlTWFya0ZpbHRlcmluZ1NldCA/IHRoaXMucGFyc2VVU2hvcnQoKSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH0pKSkgfHwgW107XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRmVhdHVyZVZhcmlhdGlvbnNMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyMzIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYWpvclZlcnNpb24gPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBtaW5vclZlcnNpb24gPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KG1ham9yVmVyc2lvbiA9PT0gMSAmJiBtaW5vclZlcnNpb24gPCAxLCAnR1BPUy9HU1VCIGZlYXR1cmUgdmFyaWF0aW9ucyB0YWJsZSB1bmtub3duLicpO1xuICAgICAgICB2YXIgZmVhdHVyZVZhcmlhdGlvbnMgPSB0aGlzLnBhcnNlUmVjb3JkTGlzdDMyKHtcbiAgICAgICAgICAgIGNvbmRpdGlvblNldE9mZnNldDogUGFyc2VyLm9mZnNldDMyLFxuICAgICAgICAgICAgZmVhdHVyZVRhYmxlU3Vic3RpdHV0aW9uT2Zmc2V0OiBQYXJzZXIub2Zmc2V0MzJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlVmFyaWF0aW9ucztcbiAgICB9KSB8fCBbXTtcbn07XG5cbnZhciBwYXJzZSA9IHtcbiAgICBnZXRCeXRlOiBnZXRCeXRlLFxuICAgIGdldENhcmQ4OiBnZXRCeXRlLFxuICAgIGdldFVTaG9ydDogZ2V0VVNob3J0LFxuICAgIGdldENhcmQxNjogZ2V0VVNob3J0LFxuICAgIGdldFNob3J0OiBnZXRTaG9ydCxcbiAgICBnZXRVTG9uZzogZ2V0VUxvbmcsXG4gICAgZ2V0Rml4ZWQ6IGdldEZpeGVkLFxuICAgIGdldFRhZzogZ2V0VGFnLFxuICAgIGdldE9mZnNldDogZ2V0T2Zmc2V0LFxuICAgIGdldEJ5dGVzOiBnZXRCeXRlcyxcbiAgICBieXRlc1RvU3RyaW5nOiBieXRlc1RvU3RyaW5nLFxuICAgIFBhcnNlcjogUGFyc2VyLFxufTtcblxuLy8gVGhlIGBnbHlmYCB0YWJsZSBkZXNjcmliZXMgdGhlIGdseXBocyBpbiBUcnVlVHlwZSBvdXRsaW5lIGZvcm1hdC5cblxuLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgZGF0YSBmb3IgYSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHByZXZpb3VzVmFsdWUsIHNob3J0VmVjdG9yQml0TWFzaywgc2FtZUJpdE1hc2spIHtcbiAgICB2YXIgdjtcbiAgICBpZiAoKGZsYWcgJiBzaG9ydFZlY3RvckJpdE1hc2spID4gMCkge1xuICAgICAgICAvLyBUaGUgY29vcmRpbmF0ZSBpcyAxIGJ5dGUgbG9uZy5cbiAgICAgICAgdiA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgIC8vIFRoZSBgc2FtZWAgYml0IGlzIHJlLXVzZWQgZm9yIHNob3J0IHZhbHVlcyB0byBzaWduaWZ5IHRoZSBzaWduIG9mIHRoZSB2YWx1ZS5cbiAgICAgICAgaWYgKChmbGFnICYgc2FtZUJpdE1hc2spID09PSAwKSB7XG4gICAgICAgICAgICB2ID0gLXY7XG4gICAgICAgIH1cblxuICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZSArIHY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gIFRoZSBjb29yZGluYXRlIGlzIDIgYnl0ZXMgbG9uZy5cbiAgICAgICAgLy8gSWYgdGhlIGBzYW1lYCBiaXQgaXMgc2V0LCB0aGUgY29vcmRpbmF0ZSBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgY29vcmRpbmF0ZS5cbiAgICAgICAgaWYgKChmbGFnICYgc2FtZUJpdE1hc2spID4gMCkge1xuICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgY29vcmRpbmF0ZSBhcyBhIHNpZ25lZCAxNi1iaXQgZGVsdGEgdmFsdWUuXG4gICAgICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZSArIHAucGFyc2VTaG9ydCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG59XG5cbi8vIFBhcnNlIGEgVHJ1ZVR5cGUgZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUdseXBoKGdseXBoLCBkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZ2x5cGgubnVtYmVyT2ZDb250b3VycyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl94TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGguX3lNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feE1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl95TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgdmFyIGZsYWdzO1xuICAgIHZhciBmbGFnO1xuXG4gICAgaWYgKGdseXBoLm51bWJlck9mQ29udG91cnMgPiAwKSB7XG4gICAgICAgIC8vIFRoaXMgZ2x5cGggaXMgbm90IGEgY29tcG9zaXRlLlxuICAgICAgICB2YXIgZW5kUG9pbnRJbmRpY2VzID0gZ2x5cGguZW5kUG9pbnRJbmRpY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGgubnVtYmVyT2ZDb250b3VyczsgaSArPSAxKSB7XG4gICAgICAgICAgICBlbmRQb2ludEluZGljZXMucHVzaChwLnBhcnNlVVNob3J0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGdseXBoLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucy5wdXNoKHAucGFyc2VCeXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG51bWJlck9mQ29vcmRpbmF0ZXMgPSBlbmRQb2ludEluZGljZXNbZW5kUG9pbnRJbmRpY2VzLmxlbmd0aCAtIDFdICsgMTtcbiAgICAgICAgZmxhZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQyICs9IDEpIHtcbiAgICAgICAgICAgIGZsYWcgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcbiAgICAgICAgICAgIC8vIElmIGJpdCAzIGlzIHNldCwgd2UgcmVwZWF0IHRoaXMgZmxhZyBuIHRpbWVzLCB3aGVyZSBuIGlzIHRoZSBuZXh0IGJ5dGUuXG4gICAgICAgICAgICBpZiAoKGZsYWcgJiA4KSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwZWF0Q291bnQgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwZWF0Q291bnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5wdXNoKGZsYWcpO1xuICAgICAgICAgICAgICAgICAgICBpJDIgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGVjay5hcmd1bWVudChmbGFncy5sZW5ndGggPT09IG51bWJlck9mQ29vcmRpbmF0ZXMsICdCYWQgZmxhZ3MuJyk7XG5cbiAgICAgICAgaWYgKGVuZFBvaW50SW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgICAgICAvLyBYL1kgY29vcmRpbmF0ZXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBwb2ludCwgZXhjZXB0IGZvciB0aGUgZmlyc3QgcG9pbnQgd2hpY2ggaXMgcmVsYXRpdmUgdG8gMCwwLlxuICAgICAgICAgICAgaWYgKG51bWJlck9mQ29vcmRpbmF0ZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQzICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2kkM107XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lm9uQ3VydmUgPSAhIShmbGFnICYgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lmxhc3RQb2ludE9mQ29udG91ciA9IGVuZFBvaW50SW5kaWNlcy5pbmRleE9mKGkkMykgPj0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBweCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQ0ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2kkNF07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2kkNF07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnggPSBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBweCwgMiwgMTYpO1xuICAgICAgICAgICAgICAgICAgICBweCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHB5ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDUgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaSQ1XTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaSQ1XTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueSA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB5LCA0LCAzMik7XG4gICAgICAgICAgICAgICAgICAgIHB5ID0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID09PSAwKSB7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdseXBoLmlzQ29tcG9zaXRlID0gdHJ1ZTtcbiAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgICAgIGdseXBoLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIG1vcmVDb21wb25lbnRzID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKG1vcmVDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBmbGFncyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleDogcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgIHhTY2FsZTogMSxcbiAgICAgICAgICAgICAgICBzY2FsZTAxOiAwLFxuICAgICAgICAgICAgICAgIHNjYWxlMTA6IDAsXG4gICAgICAgICAgICAgICAgeVNjYWxlOiAxLFxuICAgICAgICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgICAgICAgIGR5OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgYXJlIHdvcmRzXG4gICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIDIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR5ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBtYXRjaGVkIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9IFtwLnBhcnNlVVNob3J0KCksIHAucGFyc2VVU2hvcnQoKV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgYXJlIGJ5dGVzXG4gICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIDIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgbWF0Y2hlZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPSBbcC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNjYWxlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiA2NCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBYIC8gWSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiAxMjgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSAyeDIgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUwMSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMTAgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIG1vcmVDb21wb25lbnRzID0gISEoZmxhZ3MgJiAzMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzICYgMHgxMDApIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGg7IGkkNiArPSAxKSB7XG4gICAgICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zLnB1c2gocC5wYXJzZUJ5dGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBwb2ludHMgYW5kIHJldHVybiBhIG5ldyBhcnJheS5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50cyhwb2ludHMsIHRyYW5zZm9ybSkge1xuICAgIHZhciBuZXdQb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBuZXdQdCA9IHtcbiAgICAgICAgICAgIHg6IHRyYW5zZm9ybS54U2NhbGUgKiBwdC54ICsgdHJhbnNmb3JtLnNjYWxlMDEgKiBwdC55ICsgdHJhbnNmb3JtLmR4LFxuICAgICAgICAgICAgeTogdHJhbnNmb3JtLnNjYWxlMTAgKiBwdC54ICsgdHJhbnNmb3JtLnlTY2FsZSAqIHB0LnkgKyB0cmFuc2Zvcm0uZHksXG4gICAgICAgICAgICBvbkN1cnZlOiBwdC5vbkN1cnZlLFxuICAgICAgICAgICAgbGFzdFBvaW50T2ZDb250b3VyOiBwdC5sYXN0UG9pbnRPZkNvbnRvdXJcbiAgICAgICAgfTtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2gobmV3UHQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdQb2ludHM7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRvdXJzKHBvaW50cykge1xuICAgIHZhciBjb250b3VycyA9IFtdO1xuICAgIHZhciBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrLmFyZ3VtZW50KGN1cnJlbnRDb250b3VyLmxlbmd0aCA9PT0gMCwgJ1RoZXJlIGFyZSBzdGlsbCBwb2ludHMgbGVmdCBpbiB0aGUgY3VycmVudCBjb250b3VyLicpO1xuICAgIHJldHVybiBjb250b3Vycztcbn1cblxuLy8gQ29udmVydCB0aGUgVHJ1ZVR5cGUgZ2x5cGggb3V0bGluZSB0byBhIFBhdGguXG5mdW5jdGlvbiBnZXRQYXRoKHBvaW50cykge1xuICAgIHZhciBwID0gbmV3IFBhdGgoKTtcbiAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgY29udG91cnMgPSBnZXRDb250b3Vycyhwb2ludHMpO1xuXG4gICAgZm9yICh2YXIgY29udG91ckluZGV4ID0gMDsgY29udG91ckluZGV4IDwgY29udG91cnMubGVuZ3RoOyArK2NvbnRvdXJJbmRleCkge1xuICAgICAgICB2YXIgY29udG91ciA9IGNvbnRvdXJzW2NvbnRvdXJJbmRleF07XG5cbiAgICAgICAgdmFyIHByZXYgPSBudWxsO1xuICAgICAgICB2YXIgY3VyciA9IGNvbnRvdXJbY29udG91ci5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5leHQgPSBjb250b3VyWzBdO1xuXG4gICAgICAgIGlmIChjdXJyLm9uQ3VydmUpIHtcbiAgICAgICAgICAgIHAubW92ZVRvKGN1cnIueCwgY3Vyci55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXh0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICBwLm1vdmVUbyhuZXh0LngsIG5leHQueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIGJvdGggZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBvZmYtY3VydmUsIHN0YXJ0IGF0IHRoZWlyIG1pZGRsZS5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB7eDogKGN1cnIueCArIG5leHQueCkgKiAwLjUsIHk6IChjdXJyLnkgKyBuZXh0LnkpICogMC41fTtcbiAgICAgICAgICAgICAgICBwLm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udG91ci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcHJldiA9IGN1cnI7XG4gICAgICAgICAgICBjdXJyID0gbmV4dDtcbiAgICAgICAgICAgIG5leHQgPSBjb250b3VyWyhpICsgMSkgJSBjb250b3VyLmxlbmd0aF07XG5cbiAgICAgICAgICAgIGlmIChjdXJyLm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgICAgICAgICBwLmxpbmVUbyhjdXJyLngsIGN1cnIueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2MiA9IHByZXY7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQyID0gbmV4dDtcblxuICAgICAgICAgICAgICAgIGlmICghcHJldi5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYyID0geyB4OiAoY3Vyci54ICsgcHJldi54KSAqIDAuNSwgeTogKGN1cnIueSArIHByZXYueSkgKiAwLjUgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5leHQub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0MiA9IHsgeDogKGN1cnIueCArIG5leHQueCkgKiAwLjUsIHk6IChjdXJyLnkgKyBuZXh0LnkpICogMC41IH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnIueCwgY3Vyci55LCBuZXh0Mi54LCBuZXh0Mi55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBidWlsZFBhdGgoZ2x5cGhzLCBnbHlwaCkge1xuICAgIGlmIChnbHlwaC5pc0NvbXBvc2l0ZSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLmNvbXBvbmVudHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBnbHlwaC5jb21wb25lbnRzW2pdO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudEdseXBoID0gZ2x5cGhzLmdldChjb21wb25lbnQuZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAvLyBGb3JjZSB0aGUgdHRmR2x5cGhMb2FkZXIgdG8gcGFyc2UgdGhlIGdseXBoLlxuICAgICAgICAgICAgY29tcG9uZW50R2x5cGguZ2V0UGF0aCgpO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudEdseXBoLnBvaW50cykge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBwb3NpdGlvbmVkIGJ5IG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHBvc2l0aW9uZWQgYnkgbWF0Y2hlZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjb21wb25lbnQubWF0Y2hlZFBvaW50c1swXSA+IGdseXBoLnBvaW50cy5sZW5ndGggLSAxKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzFdID4gY29tcG9uZW50R2x5cGgucG9pbnRzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignTWF0Y2hlZCBwb2ludHMgb3V0IG9mIHJhbmdlIGluICcgKyBnbHlwaC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RQdCA9IGdseXBoLnBvaW50c1tjb21wb25lbnQubWF0Y2hlZFBvaW50c1swXV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRQdCA9IGNvbXBvbmVudEdseXBoLnBvaW50c1tjb21wb25lbnQubWF0Y2hlZFBvaW50c1sxXV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4U2NhbGU6IGNvbXBvbmVudC54U2NhbGUsIHNjYWxlMDE6IGNvbXBvbmVudC5zY2FsZTAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUxMDogY29tcG9uZW50LnNjYWxlMTAsIHlTY2FsZTogY29tcG9uZW50LnlTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4OiAwLCBkeTogMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZWNvbmRQdCA9IHRyYW5zZm9ybVBvaW50cyhbc2Vjb25kUHRdLCB0cmFuc2Zvcm0pWzBdO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZHggPSBmaXJzdFB0LnggLSBzZWNvbmRQdC54O1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZHkgPSBmaXJzdFB0LnkgLSBzZWNvbmRQdC55O1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IGdseXBoLnBvaW50cy5jb25jYXQodHJhbnNmb3JtZWRQb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFBhdGgoZ2x5cGgucG9pbnRzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VHbHlmVGFibGVBbGwoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQpIHtcbiAgICB2YXIgZ2x5cGhzID0gbmV3IGdseXBoc2V0LkdseXBoU2V0KGZvbnQpO1xuXG4gICAgLy8gVGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbG9jYSB0YWJsZSBpcyBpbnZhbGlkLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYS5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGxvY2FbaV07XG4gICAgICAgIHZhciBuZXh0T2Zmc2V0ID0gbG9jYVtpICsgMV07XG4gICAgICAgIGlmIChvZmZzZXQgIT09IG5leHRPZmZzZXQpIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LnR0ZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlR2x5cGgsIGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBidWlsZFBhdGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LmdseXBoTG9hZGVyKGZvbnQsIGkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnbHlwaHM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlR2x5ZlRhYmxlT25Mb3dNZW1vcnkoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQpIHtcbiAgICB2YXIgZ2x5cGhzID0gbmV3IGdseXBoc2V0LkdseXBoU2V0KGZvbnQpO1xuXG4gICAgZm9udC5fcHVzaCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGxvY2FbaV07XG4gICAgICAgIHZhciBuZXh0T2Zmc2V0ID0gbG9jYVtpICsgMV07XG4gICAgICAgIGlmIChvZmZzZXQgIT09IG5leHRPZmZzZXQpIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LnR0ZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlR2x5cGgsIGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBidWlsZFBhdGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LmdseXBoTG9hZGVyKGZvbnQsIGkpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZ2x5cGhzO1xufVxuXG4vLyBQYXJzZSBhbGwgdGhlIGdseXBocyBhY2NvcmRpbmcgdG8gdGhlIG9mZnNldHMgZnJvbSB0aGUgYGxvY2FgIHRhYmxlLlxuZnVuY3Rpb24gcGFyc2VHbHlmVGFibGUoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQsIG9wdCkge1xuICAgIGlmIChvcHQubG93TWVtb3J5KVxuICAgICAgICB7IHJldHVybiBwYXJzZUdseWZUYWJsZU9uTG93TWVtb3J5KGRhdGEsIHN0YXJ0LCBsb2NhLCBmb250KTsgfVxuICAgIGVsc2VcbiAgICAgICAgeyByZXR1cm4gcGFyc2VHbHlmVGFibGVBbGwoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQpOyB9XG59XG5cbnZhciBnbHlmID0geyBnZXRQYXRoOiBnZXRQYXRoLCBwYXJzZTogcGFyc2VHbHlmVGFibGV9O1xuXG4vKiBBIFRydWVUeXBlIGZvbnQgaGludGluZyBpbnRlcnByZXRlci5cbipcbiogKGMpIDIwMTcgQXhlbCBLaXR0ZW5iZXJnZXJcbipcbiogVGhpcyBpbnRlcnByZXRlciBoYXMgYmVlbiBpbXBsZW1lbnRlZCBhY2NvcmRpbmcgdG8gdGhpcyBkb2N1bWVudGF0aW9uOlxuKiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA1L0NoYXA1Lmh0bWxcbipcbiogQWNjb3JkaW5nIHRvIHRoZSBkb2N1bWVudGF0aW9uIEYyNERPVDYgdmFsdWVzIGFyZSB1c2VkIGZvciBwaXhlbHMuXG4qIFRoYXQgbWVhbnMgY2FsY3VsYXRpb24gaXMgMS82NCBwaXhlbCBhY2N1cmF0ZSBhbmQgdXNlcyBpbnRlZ2VyIG9wZXJhdGlvbnMuXG4qIEhvd2V2ZXIsIEphdmFzY3JpcHQgaGFzIGZsb2F0aW5nIHBvaW50IG9wZXJhdGlvbnMgYnkgZGVmYXVsdCBhbmQgb25seVxuKiB0aG9zZSBhcmUgYXZhaWxhYmxlLiBPbmUgY291bGQgbWFrZSBhIGNhc2UgdG8gc2ltdWxhdGUgdGhlIDEvNjQgYWNjdXJhY3lcbiogZXhhY3RseSBieSB0cnVuY2F0aW5nIGFmdGVyIGV2ZXJ5IGRpdmlzaW9uIG9wZXJhdGlvblxuKiAoZm9yIGV4YW1wbGUgd2l0aCA8PCAwKSB0byBnZXQgcGl4ZWwgZXhhY3RseSByZXN1bHRzIGFzIG90aGVyIFRydWVUeXBlXG4qIGltcGxlbWVudGF0aW9ucy4gSXQgbWF5IG1ha2Ugc2Vuc2Ugc2luY2Ugc29tZSBmb250cyBhcmUgcGl4ZWwgb3B0aW1pemVkXG4qIGJ5IGhhbmQgdXNpbmcgREVMVEFQIGluc3RydWN0aW9ucy4gVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gZG9lc24ndFxuKiBhbmQgcmF0aGVyIHVzZXMgZnVsbCBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24uXG4qXG4qIHhTY2FsZSwgeVNjYWxlIGFuZCByb3RhdGlvbiBpcyBjdXJyZW50bHkgaWdub3JlZC5cbipcbiogQSBmZXcgbm9uLXRyaXZpYWwgaW5zdHJ1Y3Rpb25zIGFyZSBtaXNzaW5nIGFzIEkgZGlkbid0IGVuY291bnRlciB5ZXRcbiogYSBmb250IHRoYXQgdXNlZCB0aGVtIHRvIHRlc3QgYSBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbi5cbipcbiogU29tZSBmb250cyBzZWVtIHRvIHVzZSB1bmRvY3VtZW50ZWQgZmVhdHVyZXMgcmVnYXJkaW5nIHRoZSB0d2lsaWdodCB6b25lLlxuKiBPbmx5IHNvbWUgb2YgdGhlbSBhcmUgaW1wbGVtZW50ZWQgYXMgdGhleSB3ZXJlIGVuY291bnRlcmVkLlxuKlxuKiBUaGUgZXhwb3J0cy5ERUJVRyBzdGF0ZW1lbnRzIGFyZSByZW1vdmVkIG9uIHRoZSBtaW5pZmllZCBkaXN0cmlidXRpb24gZmlsZS5cbiovXG5cbnZhciBpbnN0cnVjdGlvblRhYmxlO1xudmFyIGV4ZWM7XG52YXIgZXhlY0dseXBoO1xudmFyIGV4ZWNDb21wb25lbnQ7XG5cbi8qXG4qIENyZWF0ZXMgYSBoaW50aW5nIG9iamVjdC5cbipcbiogVGhlcmUgb3VnaHQgdG8gYmUgZXhhY3RseSBvbmVcbiogZm9yIGVhY2ggdHJ1ZXR5cGUgZm9udCB0aGF0IGlzIHVzZWQgZm9yIGhpbnRpbmcuXG4qL1xuZnVuY3Rpb24gSGludGluZyhmb250KSB7XG4gICAgLy8gdGhlIGZvbnQgdGhpcyBoaW50aW5nIG9iamVjdCBpcyBmb3JcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuXG4gICAgdGhpcy5nZXRDb21tYW5kcyA9IGZ1bmN0aW9uIChoUG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBnbHlmLmdldFBhdGgoaFBvaW50cykuY29tbWFuZHM7XG4gICAgfTtcblxuICAgIC8vIGNhY2hlZCBzdGF0ZXNcbiAgICB0aGlzLl9mcGdtU3RhdGUgID1cbiAgICB0aGlzLl9wcmVwU3RhdGUgID1cbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgLy8gZXJyb3JTdGF0ZVxuICAgIC8vIDAgLi4uIGFsbCBva2F5XG4gICAgLy8gMSAuLi4gaGFkIGFuIGVycm9yIGluIGEgZ2x5ZixcbiAgICAvLyAgICAgICBjb250aW51ZSB3b3JraW5nIGJ1dCBzdG9wIHNwYW1taW5nXG4gICAgLy8gICAgICAgdGhlIGNvbnNvbGVcbiAgICAvLyAyIC4uLiBlcnJvciBhdCBwcmVwLCBzdG9wIGhpbnRpbmcgYXQgdGhpcyBwcGVtXG4gICAgLy8gMyAuLi4gZXJyb3IgYXQgZnBlZywgc3RvcCBoaW50aW5nIGZvciB0aGlzIGZvbnQgYXQgYWxsXG4gICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDA7XG59XG5cbi8qXG4qIE5vdCByb3VuZGluZy5cbiovXG5mdW5jdGlvbiByb3VuZE9mZih2KSB7XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmRUb0dyaWQodikge1xuICAgIC8vUm91bmRpbmcgaW4gVFQgaXMgc3VwcG9zZWQgdG8gXCJzeW1tZXRyaWNhbCBhcm91bmQgemVyb1wiXG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGgucm91bmQoTWF0aC5hYnModikpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBkb3VibGUgZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFRvRG91YmxlR3JpZCh2KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGgucm91bmQoTWF0aC5hYnModiAqIDIpKSAvIDI7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGhhbGYgZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFRvSGFsZkdyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiAoTWF0aC5yb3VuZChNYXRoLmFicyh2KSArIDAuNSkgLSAwLjUpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byB1cCB0byBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kVXBUb0dyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLmNlaWwoTWF0aC5hYnModikpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBkb3duIHRvIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmREb3duVG9HcmlkKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5mbG9vcihNYXRoLmFicyh2KSk7XG59XG5cbi8qXG4qIFN1cGVyIHJvdW5kaW5nLlxuKi9cbnZhciByb3VuZFN1cGVyID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgcGVyaW9kID0gdGhpcy5zclBlcmlvZDtcbiAgICB2YXIgcGhhc2UgPSB0aGlzLnNyUGhhc2U7XG4gICAgdmFyIHRocmVzaG9sZCA9IHRoaXMuc3JUaHJlc2hvbGQ7XG4gICAgdmFyIHNpZ24gPSAxO1xuXG4gICAgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAtdjtcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgIH1cblxuICAgIHYgKz0gdGhyZXNob2xkIC0gcGhhc2U7XG5cbiAgICB2ID0gTWF0aC50cnVuYyh2IC8gcGVyaW9kKSAqIHBlcmlvZDtcblxuICAgIHYgKz0gcGhhc2U7XG5cbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3hncmlkZml0LnNvdXJjZWZvcmdlLm5ldC9yb3VuZC5odG1sXG4gICAgaWYgKHYgPCAwKSB7IHJldHVybiBwaGFzZSAqIHNpZ247IH1cblxuICAgIHJldHVybiB2ICogc2lnbjtcbn07XG5cbi8qXG4qIFVuaXQgdmVjdG9yIG9mIHgtYXhpcy5cbiovXG52YXIgeFVuaXRWZWN0b3IgPSB7XG4gICAgeDogMSxcblxuICAgIHk6IDAsXG5cbiAgICBheGlzOiAneCcsXG5cbiAgICAvLyBHZXRzIHRoZSBwcm9qZWN0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgIC8vIG8xL28yIC4uLiBpZiB0cnVlLCByZXNwZWN0aXZlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHVzZWQuXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uIChwMSwgcDIsIG8xLCBvMikge1xuICAgICAgICByZXR1cm4gKG8xID8gcDEueG8gOiBwMS54KSAtIChvMiA/IHAyLnhvIDogcDIueCk7XG4gICAgfSxcblxuICAgIC8vIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuICAgIC8vIHBvc2l0aW9uIHRvIHRoZSBtb3ZlZCBwb3NpdGlvbnMgb2YgcnAxIGFuZCBycDIgdGhhbiB0aGVcbiAgICAvLyBvcmlnaW5hbCBwb3NpdGlvbnMgaGFkLlxuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIElOVEVSUE9MQVRFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAocCwgcnAxLCBycDIsIHB2KSB7XG4gICAgICAgIHZhciBkbzE7XG4gICAgICAgIHZhciBkbzI7XG4gICAgICAgIHZhciBkb2ExO1xuICAgICAgICB2YXIgZG9hMjtcbiAgICAgICAgdmFyIGRtMTtcbiAgICAgICAgdmFyIGRtMjtcbiAgICAgICAgdmFyIGR0O1xuXG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIGRvMSA9IHAueG8gLSBycDEueG87XG4gICAgICAgICAgICBkbzIgPSBwLnhvIC0gcnAyLnhvO1xuICAgICAgICAgICAgZG0xID0gcnAxLnggLSBycDEueG87XG4gICAgICAgICAgICBkbTIgPSBycDIueCAtIHJwMi54bztcbiAgICAgICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwLnggPSBwLnhvICsgKGRtMSArIGRtMikgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC54ID0gcC54byArIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvMSA9IHB2LmRpc3RhbmNlKHAsIHJwMSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRvMiA9IHB2LmRpc3RhbmNlKHAsIHJwMiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRtMiA9IHB2LmRpc3RhbmNlKHJwMiwgcnAyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgIHhVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKyBkbTIpIC8gMiwgcHYsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgeFVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIGxpbmUgbm9ybWFsIHRvIHRoaXNcbiAgICBub3JtYWxTbG9wZTogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuXG4gICAgLy8gU2V0cyB0aGUgcG9pbnQgJ3AnIHJlbGF0aXZlIHRvIHBvaW50ICdycCdcbiAgICAvLyBieSB0aGUgZGlzdGFuY2UgJ2QnLlxuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIC8vXG4gICAgLy8gcCAgIC4uLiBwb2ludCB0byBzZXRcbiAgICAvLyBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuICAgIC8vIGQgICAuLi4gZGlzdGFuY2Ugb24gcHJvamVjdGlvbiB2ZWN0b3JcbiAgICAvLyBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuICAgIC8vIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuICAgIHNldFJlbGF0aXZlOiBmdW5jdGlvbiAocCwgcnAsIGQsIHB2LCBvcmcpIHtcbiAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgcC54ID0gKG9yZyA/IHJwLnhvIDogcnAueCkgKyBkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcbiAgICAgICAgdmFyIHJweSA9IG9yZyA/IHJwLnlvIDogcnAueTtcbiAgICAgICAgdmFyIHJwZHggPSBycHggKyBkICogcHYueDtcbiAgICAgICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuICAgICAgICBwLnggPSBycGR4ICsgKHAueSAtIHJwZHkpIC8gcHYubm9ybWFsU2xvcGU7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIHZlY3RvciBsaW5lLlxuICAgIHNsb3BlOiAwLFxuXG4gICAgLy8gVG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICB0b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC54VG91Y2hlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIFRlc3RzIGlmIGEgcG9pbnQgcCBpcyB0b3VjaGVkLlxuICAgIHRvdWNoZWQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLnhUb3VjaGVkO1xuICAgIH0sXG5cbiAgICAvLyBVbnRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdW50b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC54VG91Y2hlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbi8qXG4qIFVuaXQgdmVjdG9yIG9mIHktYXhpcy5cbiovXG52YXIgeVVuaXRWZWN0b3IgPSB7XG4gICAgeDogMCxcblxuICAgIHk6IDEsXG5cbiAgICBheGlzOiAneScsXG5cbiAgICAvLyBHZXRzIHRoZSBwcm9qZWN0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgIC8vIG8xL28yIC4uLiBpZiB0cnVlLCByZXNwZWN0aXZlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHVzZWQuXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uIChwMSwgcDIsIG8xLCBvMikge1xuICAgICAgICByZXR1cm4gKG8xID8gcDEueW8gOiBwMS55KSAtIChvMiA/IHAyLnlvIDogcDIueSk7XG4gICAgfSxcblxuICAgIC8vIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuICAgIC8vIHBvc2l0aW9uIHRvIHRoZSBtb3ZlZCBwb3NpdGlvbnMgb2YgcnAxIGFuZCBycDIgdGhhbiB0aGVcbiAgICAvLyBvcmlnaW5hbCBwb3NpdGlvbnMgaGFkLlxuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIElOVEVSUE9MQVRFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAocCwgcnAxLCBycDIsIHB2KSB7XG4gICAgICAgIHZhciBkbzE7XG4gICAgICAgIHZhciBkbzI7XG4gICAgICAgIHZhciBkb2ExO1xuICAgICAgICB2YXIgZG9hMjtcbiAgICAgICAgdmFyIGRtMTtcbiAgICAgICAgdmFyIGRtMjtcbiAgICAgICAgdmFyIGR0O1xuXG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIGRvMSA9IHAueW8gLSBycDEueW87XG4gICAgICAgICAgICBkbzIgPSBwLnlvIC0gcnAyLnlvO1xuICAgICAgICAgICAgZG0xID0gcnAxLnkgLSBycDEueW87XG4gICAgICAgICAgICBkbTIgPSBycDIueSAtIHJwMi55bztcbiAgICAgICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwLnkgPSBwLnlvICsgKGRtMSArIGRtMikgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC55ID0gcC55byArIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvMSA9IHB2LmRpc3RhbmNlKHAsIHJwMSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRvMiA9IHB2LmRpc3RhbmNlKHAsIHJwMiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRtMiA9IHB2LmRpc3RhbmNlKHJwMiwgcnAyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgIHlVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKyBkbTIpIC8gMiwgcHYsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgeVVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIGxpbmUgbm9ybWFsIHRvIHRoaXMuXG4gICAgbm9ybWFsU2xvcGU6IDAsXG5cbiAgICAvLyBTZXRzIHRoZSBwb2ludCAncCcgcmVsYXRpdmUgdG8gcG9pbnQgJ3JwJ1xuICAgIC8vIGJ5IHRoZSBkaXN0YW5jZSAnZCdcbiAgICAvL1xuICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBTRVRSRUxBVElWRSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiAgICAvL1xuICAgIC8vIHAgICAuLi4gcG9pbnQgdG8gc2V0XG4gICAgLy8gcnAgIC4uLiByZWZlcmVuY2UgcG9pbnRcbiAgICAvLyBkICAgLi4uIGRpc3RhbmNlIG9uIHByb2plY3Rpb24gdmVjdG9yXG4gICAgLy8gcHYgIC4uLiBwcm9qZWN0aW9uIHZlY3RvciAodW5kZWZpbmVkID0gdGhpcylcbiAgICAvLyBvcmcgLi4uIGlmIHRydWUsIHVzZXMgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIG9mIHJwIGFzIHJlZmVyZW5jZS5cbiAgICBzZXRSZWxhdGl2ZTogZnVuY3Rpb24gKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHAueSA9IChvcmcgPyBycC55byA6IHJwLnkpICsgZDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBycHggPSBvcmcgPyBycC54byA6IHJwLng7XG4gICAgICAgIHZhciBycHkgPSBvcmcgPyBycC55byA6IHJwLnk7XG4gICAgICAgIHZhciBycGR4ID0gcnB4ICsgZCAqIHB2Lng7XG4gICAgICAgIHZhciBycGR5ID0gcnB5ICsgZCAqIHB2Lnk7XG5cbiAgICAgICAgcC55ID0gcnBkeSArIHB2Lm5vcm1hbFNsb3BlICogKHAueCAtIHJwZHgpO1xuICAgIH0sXG5cbiAgICAvLyBTbG9wZSBvZiB2ZWN0b3IgbGluZS5cbiAgICBzbG9wZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuXG4gICAgLy8gVG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICB0b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC55VG91Y2hlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIFRlc3RzIGlmIGEgcG9pbnQgcCBpcyB0b3VjaGVkLlxuICAgIHRvdWNoZWQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLnlUb3VjaGVkO1xuICAgIH0sXG5cbiAgICAvLyBVbnRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdW50b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC55VG91Y2hlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbk9iamVjdC5mcmVlemUoeFVuaXRWZWN0b3IpO1xuT2JqZWN0LmZyZWV6ZSh5VW5pdFZlY3Rvcik7XG5cbi8qXG4qIENyZWF0ZXMgYSB1bml0IHZlY3RvciB0aGF0IGlzIG5vdCB4LSBvciB5LWF4aXMuXG4qL1xuZnVuY3Rpb24gVW5pdFZlY3Rvcih4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNsb3BlID0geSAvIHg7XG4gICAgdGhpcy5ub3JtYWxTbG9wZSA9IC14IC8geTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xufVxuXG4vKlxuKiBHZXRzIHRoZSBwcm9qZWN0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuKiBvMS9vMiAuLi4gaWYgdHJ1ZSwgcmVzcGVjdGl2ZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyB1c2VkLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24ocDEsIHAyLCBvMSwgbzIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnggKiB4VW5pdFZlY3Rvci5kaXN0YW5jZShwMSwgcDIsIG8xLCBvMikgK1xuICAgICAgICB0aGlzLnkgKiB5VW5pdFZlY3Rvci5kaXN0YW5jZShwMSwgcDIsIG8xLCBvMilcbiAgICApO1xufTtcblxuLypcbiogTW92ZXMgcG9pbnQgcCBzbyB0aGUgbW92ZWQgcG9zaXRpb24gaGFzIHRoZSBzYW1lIHJlbGF0aXZlXG4qIHBvc2l0aW9uIHRvIHRoZSBtb3ZlZCBwb3NpdGlvbnMgb2YgcnAxIGFuZCBycDIgdGhhbiB0aGVcbiogb3JpZ2luYWwgcG9zaXRpb25zIGhhZC5cbipcbiogU2VlIEFQUEVORElYIG9uIElOVEVSUE9MQVRFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24ocCwgcnAxLCBycDIsIHB2KSB7XG4gICAgdmFyIGRtMTtcbiAgICB2YXIgZG0yO1xuICAgIHZhciBkbzE7XG4gICAgdmFyIGRvMjtcbiAgICB2YXIgZG9hMTtcbiAgICB2YXIgZG9hMjtcbiAgICB2YXIgZHQ7XG5cbiAgICBkbzEgPSBwdi5kaXN0YW5jZShwLCBycDEsIHRydWUsIHRydWUpO1xuICAgIGRvMiA9IHB2LmRpc3RhbmNlKHAsIHJwMiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcbiAgICBkbTIgPSBwdi5kaXN0YW5jZShycDIsIHJwMiwgZmFsc2UsIHRydWUpO1xuICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICsgZG0yKSAvIDIsIHB2LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG59O1xuXG4vKlxuKiBTZXRzIHRoZSBwb2ludCAncCcgcmVsYXRpdmUgdG8gcG9pbnQgJ3JwJ1xuKiBieSB0aGUgZGlzdGFuY2UgJ2QnXG4qXG4qIFNlZSBBUFBFTkRJWCBvbiBTRVRSRUxBVElWRSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbipcbiogcCAgIC4uLiAgcG9pbnQgdG8gc2V0XG4qIHJwICAuLi4gcmVmZXJlbmNlIHBvaW50XG4qIGQgICAuLi4gZGlzdGFuY2Ugb24gcHJvamVjdGlvbiB2ZWN0b3JcbiogcHYgIC4uLiBwcm9qZWN0aW9uIHZlY3RvciAodW5kZWZpbmVkID0gdGhpcylcbiogb3JnIC4uLiBpZiB0cnVlLCB1c2VzIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBycCBhcyByZWZlcmVuY2UuXG4qL1xuVW5pdFZlY3Rvci5wcm90b3R5cGUuc2V0UmVsYXRpdmUgPSBmdW5jdGlvbihwLCBycCwgZCwgcHYsIG9yZykge1xuICAgIHB2ID0gcHYgfHwgdGhpcztcblxuICAgIHZhciBycHggPSBvcmcgPyBycC54byA6IHJwLng7XG4gICAgdmFyIHJweSA9IG9yZyA/IHJwLnlvIDogcnAueTtcbiAgICB2YXIgcnBkeCA9IHJweCArIGQgKiBwdi54O1xuICAgIHZhciBycGR5ID0gcnB5ICsgZCAqIHB2Lnk7XG5cbiAgICB2YXIgcHZucyA9IHB2Lm5vcm1hbFNsb3BlO1xuICAgIHZhciBmdnMgPSB0aGlzLnNsb3BlO1xuXG4gICAgdmFyIHB4ID0gcC54O1xuICAgIHZhciBweSA9IHAueTtcblxuICAgIHAueCA9IChmdnMgKiBweCAtIHB2bnMgKiBycGR4ICsgcnBkeSAtIHB5KSAvIChmdnMgLSBwdm5zKTtcbiAgICBwLnkgPSBmdnMgKiAocC54IC0gcHgpICsgcHk7XG59O1xuXG4vKlxuKiBUb3VjaGVzIHRoZSBwb2ludCBwLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24ocCkge1xuICAgIHAueFRvdWNoZWQgPSB0cnVlO1xuICAgIHAueVRvdWNoZWQgPSB0cnVlO1xufTtcblxuLypcbiogUmV0dXJucyBhIHVuaXQgdmVjdG9yIHdpdGggeC95IGNvb3JkaW5hdGVzLlxuKi9cbmZ1bmN0aW9uIGdldFVuaXRWZWN0b3IoeCwgeSkge1xuICAgIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gICAgeCAvPSBkO1xuICAgIHkgLz0gZDtcblxuICAgIGlmICh4ID09PSAxICYmIHkgPT09IDApIHsgcmV0dXJuIHhVbml0VmVjdG9yOyB9XG4gICAgZWxzZSBpZiAoeCA9PT0gMCAmJiB5ID09PSAxKSB7IHJldHVybiB5VW5pdFZlY3RvcjsgfVxuICAgIGVsc2UgeyByZXR1cm4gbmV3IFVuaXRWZWN0b3IoeCwgeSk7IH1cbn1cblxuLypcbiogQ3JlYXRlcyBhIHBvaW50IGluIHRoZSBoaW50aW5nIGVuZ2luZS5cbiovXG5mdW5jdGlvbiBIUG9pbnQoXG4gICAgeCxcbiAgICB5LFxuICAgIGxhc3RQb2ludE9mQ29udG91cixcbiAgICBvbkN1cnZlXG4pIHtcbiAgICB0aGlzLnggPSB0aGlzLnhvID0gTWF0aC5yb3VuZCh4ICogNjQpIC8gNjQ7IC8vIGhpbnRlZCB4IHZhbHVlIGFuZCBvcmlnaW5hbCB4LXZhbHVlXG4gICAgdGhpcy55ID0gdGhpcy55byA9IE1hdGgucm91bmQoeSAqIDY0KSAvIDY0OyAvLyBoaW50ZWQgeSB2YWx1ZSBhbmQgb3JpZ2luYWwgeS12YWx1ZVxuXG4gICAgdGhpcy5sYXN0UG9pbnRPZkNvbnRvdXIgPSBsYXN0UG9pbnRPZkNvbnRvdXI7XG4gICAgdGhpcy5vbkN1cnZlID0gb25DdXJ2ZTtcbiAgICB0aGlzLnByZXZQb2ludE9uQ29udG91ciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm5leHRQb2ludE9uQ29udG91ciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnhUb3VjaGVkID0gZmFsc2U7XG4gICAgdGhpcy55VG91Y2hlZCA9IGZhbHNlO1xuXG4gICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xufVxuXG4vKlxuKiBSZXR1cm5zIHRoZSBuZXh0IHRvdWNoZWQgcG9pbnQgb24gdGhlIGNvbnRvdXIuXG4qXG4qIHYgIC4uLiB1bml0IHZlY3RvciB0byB0ZXN0IHRvdWNoIGF4aXMuXG4qL1xuSFBvaW50LnByb3RvdHlwZS5uZXh0VG91Y2hlZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgcCA9IHRoaXMubmV4dFBvaW50T25Db250b3VyO1xuXG4gICAgd2hpbGUgKCF2LnRvdWNoZWQocCkgJiYgcCAhPT0gdGhpcykgeyBwID0gcC5uZXh0UG9pbnRPbkNvbnRvdXI7IH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLypcbiogUmV0dXJucyB0aGUgcHJldmlvdXMgdG91Y2hlZCBwb2ludCBvbiB0aGUgY29udG91clxuKlxuKiB2ICAuLi4gdW5pdCB2ZWN0b3IgdG8gdGVzdCB0b3VjaCBheGlzLlxuKi9cbkhQb2ludC5wcm90b3R5cGUucHJldlRvdWNoZWQgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHAgPSB0aGlzLnByZXZQb2ludE9uQ29udG91cjtcblxuICAgIHdoaWxlICghdi50b3VjaGVkKHApICYmIHAgIT09IHRoaXMpIHsgcCA9IHAucHJldlBvaW50T25Db250b3VyOyB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qXG4qIFRoZSB6ZXJvIHBvaW50LlxuKi9cbnZhciBIUFplcm8gPSBPYmplY3QuZnJlZXplKG5ldyBIUG9pbnQoMCwgMCkpO1xuXG4vKlxuKiBUaGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGUgaW50ZXJwcmV0ZXIuXG4qXG4qIE5vdGU6IEZyZWV6aW5nIHRoZSBkZWZhdWx0U3RhdGUgYW5kIHRoZW4gZGVyaXZpbmcgZnJvbSBpdFxuKiBtYWtlcyB0aGUgVjggSmF2YXNjcmlwdCBlbmdpbmUgZ29pbmcgYXdrd2FyZCxcbiogc28gdGhpcyBpcyBhdm9pZGVkLCBhbGJlaXQgdGhlIGRlZmF1bHRTdGF0ZSBzaG91bGRuJ3RcbiogZXZlciBjaGFuZ2UuXG4qL1xudmFyIGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBjdkN1dEluOiAxNyAvIDE2LCAgICAvLyBjb250cm9sIHZhbHVlIGN1dCBpblxuICAgIGRlbHRhQmFzZTogOSxcbiAgICBkZWx0YVNoaWZ0OiAwLjEyNSxcbiAgICBsb29wOiAxLCAgICAgICAgICAgICAvLyBsb29wcyBzb21lIGluc3RydWN0aW9uc1xuICAgIG1pbkRpczogMSwgICAgICAgICAgIC8vIG1pbmltdW0gZGlzdGFuY2VcbiAgICBhdXRvRmxpcDogdHJ1ZVxufTtcblxuLypcbiogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGludGVycHJldGVyLlxuKlxuKiBlbnYgIC4uLiAnZnBnbScgb3IgJ3ByZXAnIG9yICdnbHlmJ1xuKiBwcm9nIC4uLiB0aGUgcHJvZ3JhbVxuKi9cbmZ1bmN0aW9uIFN0YXRlKGVudiwgcHJvZykge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLnByb2cgPSBwcm9nO1xuXG4gICAgc3dpdGNoIChlbnYpIHtcbiAgICAgICAgY2FzZSAnZ2x5ZicgOlxuICAgICAgICAgICAgdGhpcy56cDAgPSB0aGlzLnpwMSA9IHRoaXMuenAyID0gMTtcbiAgICAgICAgICAgIHRoaXMucnAwID0gdGhpcy5ycDEgPSB0aGlzLnJwMiA9IDA7XG4gICAgICAgICAgICAvKiBmYWxsIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncHJlcCcgOlxuICAgICAgICAgICAgdGhpcy5mdiA9IHRoaXMucHYgPSB0aGlzLmRwdiA9IHhVbml0VmVjdG9yO1xuICAgICAgICAgICAgdGhpcy5yb3VuZCA9IHJvdW5kVG9HcmlkO1xuICAgIH1cbn1cblxuLypcbiogRXhlY3V0ZXMgYSBnbHlwaCBwcm9ncmFtLlxuKlxuKiBUaGlzIGRvZXMgdGhlIGhpbnRpbmcgZm9yIGVhY2ggZ2x5cGguXG4qXG4qIFJldHVybnMgYW4gYXJyYXkgb2YgbW92ZWQgcG9pbnRzLlxuKlxuKiBnbHlwaDogdGhlIGdseXBoIHRvIGhpbnRcbiogcHBlbTogdGhlIHNpemUgdGhlIGdseXBoIGlzIHJlbmRlcmVkIGZvclxuKi9cbkhpbnRpbmcucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihnbHlwaCwgcHBlbSkge1xuICAgIGlmICh0eXBlb2YgcHBlbSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBzaXplIGlzIG5vdCBhIG51bWJlciEnKTtcbiAgICB9XG5cbiAgICAvLyBSZWNlaXZlZCBhIGZhdGFsIGVycm9yLCBkb24ndCBkbyBhbnkgaGludGluZyBhbnltb3JlLlxuICAgIGlmICh0aGlzLl9lcnJvclN0YXRlID4gMikgeyByZXR1cm47IH1cblxuICAgIHZhciBmb250ID0gdGhpcy5mb250O1xuICAgIHZhciBwcmVwU3RhdGUgPSB0aGlzLl9wcmVwU3RhdGU7XG5cbiAgICBpZiAoIXByZXBTdGF0ZSB8fCBwcmVwU3RhdGUucHBlbSAhPT0gcHBlbSkge1xuICAgICAgICB2YXIgZnBnbVN0YXRlID0gdGhpcy5fZnBnbVN0YXRlO1xuXG4gICAgICAgIGlmICghZnBnbVN0YXRlKSB7XG4gICAgICAgICAgICAvLyBFeGVjdXRlcyB0aGUgZnBnbSBzdGF0ZS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCBieSBmb250cyB0byBkZWZpbmUgZnVuY3Rpb25zLlxuICAgICAgICAgICAgU3RhdGUucHJvdG90eXBlID0gZGVmYXVsdFN0YXRlO1xuXG4gICAgICAgICAgICBmcGdtU3RhdGUgPVxuICAgICAgICAgICAgdGhpcy5fZnBnbVN0YXRlID1cbiAgICAgICAgICAgICAgICBuZXcgU3RhdGUoJ2ZwZ20nLCBmb250LnRhYmxlcy5mcGdtKTtcblxuICAgICAgICAgICAgZnBnbVN0YXRlLmZ1bmNzID0gWyBdO1xuICAgICAgICAgICAgZnBnbVN0YXRlLmZvbnQgPSBmb250O1xuXG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIEZQR00tLS0nKTtcbiAgICAgICAgICAgICAgICBmcGdtU3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGV4ZWMoZnBnbVN0YXRlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGludGluZyBlcnJvciBpbiBGUEdNOicgKyBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvclN0YXRlID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGVjdXRlcyB0aGUgcHJlcCBwcm9ncmFtIGZvciB0aGlzIHBwZW0gc2V0dGluZy5cbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIGJ5IGZvbnRzIHRvIHNldCBjdnQgdmFsdWVzXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiB0byBiZSByZW5kZXJlZCBmb250IHNpemUuXG5cbiAgICAgICAgU3RhdGUucHJvdG90eXBlID0gZnBnbVN0YXRlO1xuICAgICAgICBwcmVwU3RhdGUgPVxuICAgICAgICB0aGlzLl9wcmVwU3RhdGUgPVxuICAgICAgICAgICAgbmV3IFN0YXRlKCdwcmVwJywgZm9udC50YWJsZXMucHJlcCk7XG5cbiAgICAgICAgcHJlcFN0YXRlLnBwZW0gPSBwcGVtO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBjdnQgdGFibGVcbiAgICAgICAgLy8gYW5kIHNjYWxlcyBpdCB0byB0aGUgY3VycmVudCBwcGVtIHNldHRpbmcuXG4gICAgICAgIHZhciBvQ3Z0ID0gZm9udC50YWJsZXMuY3Z0O1xuICAgICAgICBpZiAob0N2dCkge1xuICAgICAgICAgICAgdmFyIGN2dCA9IHByZXBTdGF0ZS5jdnQgPSBuZXcgQXJyYXkob0N2dC5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gcHBlbSAvIGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgb0N2dC5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgIGN2dFtjXSA9IG9DdnRbY10gKiBzY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXBTdGF0ZS5jdnQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBQUkVQLS0tJyk7XG4gICAgICAgICAgICBwcmVwU3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV4ZWMocHJlcFN0YXRlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPCAyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpbnRpbmcgZXJyb3IgaW4gUFJFUDonICsgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9lcnJvclN0YXRlID0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9lcnJvclN0YXRlID4gMSkgeyByZXR1cm47IH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBleGVjR2x5cGgoZ2x5cGgsIHByZXBTdGF0ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA8IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaW50aW5nIGVycm9yOicgKyBlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOb3RlOiBmdXJ0aGVyIGhpbnRpbmcgZXJyb3JzIGFyZSBzaWxlbmNlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAxO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qXG4qIEV4ZWN1dGVzIHRoZSBoaW50aW5nIHByb2dyYW0gZm9yIGEgZ2x5cGguXG4qL1xuZXhlY0dseXBoID0gZnVuY3Rpb24oZ2x5cGgsIHByZXBTdGF0ZSkge1xuICAgIC8vIG9yaWdpbmFsIHBvaW50IHBvc2l0aW9uc1xuICAgIHZhciB4U2NhbGUgPSBwcmVwU3RhdGUucHBlbSAvIHByZXBTdGF0ZS5mb250LnVuaXRzUGVyRW07XG4gICAgdmFyIHlTY2FsZSA9IHhTY2FsZTtcbiAgICB2YXIgY29tcG9uZW50cyA9IGdseXBoLmNvbXBvbmVudHM7XG4gICAgdmFyIGNvbnRvdXJzO1xuICAgIHZhciBnWm9uZTtcbiAgICB2YXIgc3RhdGU7XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUgPSBwcmVwU3RhdGU7XG4gICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKCdnbHlmJywgZ2x5cGguaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIEdMWVBILS0tJyk7XG4gICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZXhlY0NvbXBvbmVudChnbHlwaCwgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKTtcbiAgICAgICAgZ1pvbmUgPSBzdGF0ZS5nWm9uZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZm9udCA9IHByZXBTdGF0ZS5mb250O1xuICAgICAgICBnWm9uZSA9IFtdO1xuICAgICAgICBjb250b3VycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBjZyA9IGZvbnQuZ2x5cGhzLmdldChjLmdseXBoSW5kZXgpO1xuXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZSgnZ2x5ZicsIGNnLmluc3RydWN0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgQ09NUCAnICsgaSArICctLS0nKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWNDb21wb25lbnQoY2csIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSk7XG4gICAgICAgICAgICAvLyBhcHBlbmRzIHRoZSBjb21wdXRlZCBwb2ludHMgdG8gdGhlIHJlc3VsdCBhcnJheVxuICAgICAgICAgICAgLy8gcG9zdCBwcm9jZXNzZXMgdGhlIGNvbXBvbmVudCBwb2ludHNcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGgucm91bmQoYy5keCAqIHhTY2FsZSk7XG4gICAgICAgICAgICB2YXIgZHkgPSBNYXRoLnJvdW5kKGMuZHkgKiB5U2NhbGUpO1xuICAgICAgICAgICAgdmFyIGd6ID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICB2YXIgY2MgPSBzdGF0ZS5jb250b3VycztcbiAgICAgICAgICAgIGZvciAodmFyIHBpID0gMDsgcGkgPCBnei5sZW5ndGg7IHBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGd6W3BpXTtcbiAgICAgICAgICAgICAgICBwLnhUb3VjaGVkID0gcC55VG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHAueG8gPSBwLnggPSBwLnggKyBkeDtcbiAgICAgICAgICAgICAgICBwLnlvID0gcC55ID0gcC55ICsgZHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBnTGVuID0gZ1pvbmUubGVuZ3RoO1xuICAgICAgICAgICAgZ1pvbmUucHVzaC5hcHBseShnWm9uZSwgZ3opO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY2Nbal0gKyBnTGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbHlwaC5pbnN0cnVjdGlvbnMgJiYgIXN0YXRlLmluaGliaXRHcmlkRml0KSB7XG4gICAgICAgICAgICAvLyB0aGUgY29tcG9zaXRlIGhhcyBpbnN0cnVjdGlvbnMgb24gaXRzIG93blxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoJ2dseWYnLCBnbHlwaC5pbnN0cnVjdGlvbnMpO1xuXG4gICAgICAgICAgICBzdGF0ZS5nWm9uZSA9IHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IGdab25lO1xuXG4gICAgICAgICAgICBzdGF0ZS5jb250b3VycyA9IGNvbnRvdXJzO1xuXG4gICAgICAgICAgICAvLyBub3RlOiBIUFplcm8gY2Fubm90IGJlIHVzZWQgaGVyZSwgc2luY2VcbiAgICAgICAgICAgIC8vICAgICAgIHRoZSBwb2ludCBtaWdodCBiZSBtb2RpZmllZFxuICAgICAgICAgICAgZ1pvbmUucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgSFBvaW50KDAsIDApLFxuICAgICAgICAgICAgICAgIG5ldyBIUG9pbnQoTWF0aC5yb3VuZChnbHlwaC5hZHZhbmNlV2lkdGggKiB4U2NhbGUpLCAwKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBDT01QT1NJVEUtLS0nKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWMoc3RhdGUpO1xuXG4gICAgICAgICAgICBnWm9uZS5sZW5ndGggLT0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnWm9uZTtcbn07XG5cbi8qXG4qIEV4ZWN1dGVzIHRoZSBoaW50aW5nIHByb2dyYW0gZm9yIGEgY29tcG9uZW50IG9mIGEgbXVsdGktY29tcG9uZW50IGdseXBoXG4qIG9yIG9mIHRoZSBnbHlwaCBpdHNlbGYgZm9yIGEgbm9uLWNvbXBvbmVudCBnbHlwaC5cbiovXG5leGVjQ29tcG9uZW50ID0gZnVuY3Rpb24oZ2x5cGgsIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSlcbntcbiAgICB2YXIgcG9pbnRzID0gZ2x5cGgucG9pbnRzIHx8IFtdO1xuICAgIHZhciBwTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgZ1pvbmUgPSBzdGF0ZS5nWm9uZSA9IHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IFtdO1xuICAgIHZhciBjb250b3VycyA9IHN0YXRlLmNvbnRvdXJzID0gW107XG5cbiAgICAvLyBTY2FsZXMgdGhlIG9yaWdpbmFsIHBvaW50cyBhbmRcbiAgICAvLyBtYWtlcyBjb3BpZXMgZm9yIHRoZSBoaW50ZWQgcG9pbnRzLlxuICAgIHZhciBjcDsgLy8gY3VycmVudCBwb2ludFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG4gICAgICAgIGNwID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGdab25lW2ldID0gbmV3IEhQb2ludChcbiAgICAgICAgICAgIGNwLnggKiB4U2NhbGUsXG4gICAgICAgICAgICBjcC55ICogeVNjYWxlLFxuICAgICAgICAgICAgY3AubGFzdFBvaW50T2ZDb250b3VyLFxuICAgICAgICAgICAgY3Aub25DdXJ2ZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIENoYWluIGxpbmtzIHRoZSBjb250b3Vycy5cbiAgICB2YXIgc3A7IC8vIHN0YXJ0IHBvaW50XG4gICAgdmFyIG5wOyAvLyBuZXh0IHBvaW50XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwTGVuOyBpJDErKykge1xuICAgICAgICBjcCA9IGdab25lW2kkMV07XG5cbiAgICAgICAgaWYgKCFzcCkge1xuICAgICAgICAgICAgc3AgPSBjcDtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goaSQxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNwLm5leHRQb2ludE9uQ29udG91ciA9IHNwO1xuICAgICAgICAgICAgc3AucHJldlBvaW50T25Db250b3VyID0gY3A7XG4gICAgICAgICAgICBzcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5wID0gZ1pvbmVbaSQxICsgMV07XG4gICAgICAgICAgICBjcC5uZXh0UG9pbnRPbkNvbnRvdXIgPSBucDtcbiAgICAgICAgICAgIG5wLnByZXZQb2ludE9uQ29udG91ciA9IGNwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmluaGliaXRHcmlkRml0KSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1BST0NFU1NJTkcgR0xZUEgnLCBzdGF0ZS5zdGFjayk7XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBMZW47IGkkMisrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpJDIsIGdab25lW2kkMl0ueCwgZ1pvbmVbaSQyXS55KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdab25lLnB1c2goXG4gICAgICAgIG5ldyBIUG9pbnQoMCwgMCksXG4gICAgICAgIG5ldyBIUG9pbnQoTWF0aC5yb3VuZChnbHlwaC5hZHZhbmNlV2lkdGggKiB4U2NhbGUpLCAwKVxuICAgICk7XG5cbiAgICBleGVjKHN0YXRlKTtcblxuICAgIC8vIFJlbW92ZXMgdGhlIGV4dHJhIHBvaW50cy5cbiAgICBnWm9uZS5sZW5ndGggLT0gMjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGSU5JU0hFRCBHTFlQSCcsIHN0YXRlLnN0YWNrKTtcbiAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgcExlbjsgaSQzKyspIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGkkMywgZ1pvbmVbaSQzXS54LCBnWm9uZVtpJDNdLnkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLypcbiogRXhlY3V0ZXMgdGhlIHByb2dyYW0gbG9hZGVkIGluIHN0YXRlLlxuKi9cbmV4ZWMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcblxuICAgIGlmICghcHJvZykgeyByZXR1cm47IH1cblxuICAgIHZhciBwTGVuID0gcHJvZy5sZW5ndGg7XG4gICAgdmFyIGlucztcblxuICAgIGZvciAoc3RhdGUuaXAgPSAwOyBzdGF0ZS5pcCA8IHBMZW47IHN0YXRlLmlwKyspIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgc3RhdGUuc3RlcCsrOyB9XG4gICAgICAgIGlucyA9IGluc3RydWN0aW9uVGFibGVbcHJvZ1tzdGF0ZS5pcF1dO1xuXG4gICAgICAgIGlmICghaW5zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3Vua25vd24gaW5zdHJ1Y3Rpb246IDB4JyArXG4gICAgICAgICAgICAgICAgTnVtYmVyKHByb2dbc3RhdGUuaXBdKS50b1N0cmluZygxNilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnMoc3RhdGUpO1xuXG4gICAgICAgIC8vIHZlcnkgZXh0ZW5zaXZlIGRlYnVnZ2luZyBmb3IgZWFjaCBzdGVwXG4gICAgICAgIC8qXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICB2YXIgZGE7XG4gICAgICAgICAgICBpZiAoc3RhdGUuZ1pvbmUpIHtcbiAgICAgICAgICAgICAgICBkYSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuZ1pvbmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkYS5wdXNoKGkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ1pvbmVbaV0ueCAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmdab25lW2ldLnkgKiA2NCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUuZ1pvbmVbaV0ueFRvdWNoZWQgPyAneCcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLmdab25lW2ldLnlUb3VjaGVkID8gJ3knIDogJycpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHWicsIGRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXRlLnRab25lKSB7XG4gICAgICAgICAgICAgICAgZGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnRab25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhLnB1c2goaSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50Wm9uZVtpXS54ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudFpvbmVbaV0ueSAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS50Wm9uZVtpXS54VG91Y2hlZCA/ICd4JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUudFpvbmVbaV0ueVRvdWNoZWQgPyAneScgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RaJywgZGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhY2subGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAnLi4uJywgc3RhdGUuc3RhY2suc2xpY2Uoc3RhdGUuc3RhY2subGVuZ3RoIC0gMTApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuc3RhY2subGVuZ3RoLCBzdGF0ZS5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICB9XG59O1xuXG4vKlxuKiBJbml0aWFsaXplcyB0aGUgdHdpbGlnaHQgem9uZS5cbipcbiogVGhpcyBpcyBvbmx5IGRvbmUgaWYgYSBTWlB4IGluc3RydWN0aW9uXG4qIHJlZmVycyB0byB0aGUgdHdpbGlnaHQgem9uZS5cbiovXG5mdW5jdGlvbiBpbml0VFpvbmUoc3RhdGUpXG57XG4gICAgdmFyIHRab25lID0gc3RhdGUudFpvbmUgPSBuZXcgQXJyYXkoc3RhdGUuZ1pvbmUubGVuZ3RoKTtcblxuICAgIC8vIG5vIGlkZWEgaWYgdGhpcyBpcyBhY3R1YWxseSBjb3JyZWN0Li4uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Wm9uZS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHRab25lW2ldID0gbmV3IEhQb2ludCgwLCAwKTtcbiAgICB9XG59XG5cbi8qXG4qIFNraXBzIHRoZSBpbnN0cnVjdGlvbiBwb2ludGVyIGFoZWFkIG92ZXIgYW4gSUYvRUxTRSBibG9jay5cbiogaGFuZGxlRWxzZSAuLiBpZiB0cnVlIGJyZWFrcyBvbiBtYXRjaGluZyBFTFNFXG4qL1xuZnVuY3Rpb24gc2tpcChzdGF0ZSwgaGFuZGxlRWxzZSlcbntcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG4gICAgdmFyIG5lc3RpbmcgPSAxO1xuICAgIHZhciBpbnM7XG5cbiAgICBkbyB7XG4gICAgICAgIGlucyA9IHByb2dbKytpcF07XG4gICAgICAgIGlmIChpbnMgPT09IDB4NTgpIC8vIElGXG4gICAgICAgICAgICB7IG5lc3RpbmcrKzsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NTkpIC8vIEVJRlxuICAgICAgICAgICAgeyBuZXN0aW5nLS07IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID09PSAweDQwKSAvLyBOUFVTSEJcbiAgICAgICAgICAgIHsgaXAgKz0gcHJvZ1tpcCArIDFdICsgMTsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NDEpIC8vIE5QVVNIV1xuICAgICAgICAgICAgeyBpcCArPSAyICogcHJvZ1tpcCArIDFdICsgMTsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPj0gMHhCMCAmJiBpbnMgPD0gMHhCNykgLy8gUFVTSEJcbiAgICAgICAgICAgIHsgaXAgKz0gaW5zIC0gMHhCMCArIDE7IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID49IDB4QjggJiYgaW5zIDw9IDB4QkYpIC8vIFBVU0hXXG4gICAgICAgICAgICB7IGlwICs9IChpbnMgLSAweEI4ICsgMSkgKiAyOyB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZUVsc2UgJiYgbmVzdGluZyA9PT0gMSAmJiBpbnMgPT09IDB4MUIpIC8vIEVMU0VcbiAgICAgICAgICAgIHsgYnJlYWs7IH1cbiAgICB9IHdoaWxlIChuZXN0aW5nID4gMCk7XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXG4qICAgICAgICAgIEFuZCB0aGVuIGEgbG90IG9mIGluc3RydWN0aW9ucy4uLiAgICAgICAgICAgICAgICAqXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIFNWVENBW2FdIFNldCBmcmVlZG9tIGFuZCBwcm9qZWN0aW9uIFZlY3RvcnMgVG8gQ29vcmRpbmF0ZSBBeGlzXG4vLyAweDAwLTB4MDFcbmZ1bmN0aW9uIFNWVENBKHYsIHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NWVENBWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cbiAgICBzdGF0ZS5mdiA9IHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gdjtcbn1cblxuLy8gU1BWVENBW2FdIFNldCBQcm9qZWN0aW9uIFZlY3RvciB0byBDb29yZGluYXRlIEF4aXNcbi8vIDB4MDItMHgwM1xuZnVuY3Rpb24gU1BWVENBKHYsIHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVlRDQVsnICsgdi5heGlzICsgJ10nKTsgfVxuXG4gICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSB2O1xufVxuXG4vLyBTRlZUQ0FbYV0gU2V0IEZyZWVkb20gVmVjdG9yIHRvIENvb3JkaW5hdGUgQXhpc1xuLy8gMHgwNC0weDA1XG5mdW5jdGlvbiBTRlZUQ0Eodiwgc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0ZWVENBWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cbiAgICBzdGF0ZS5mdiA9IHY7XG59XG5cbi8vIFNQVlRMW2FdIFNldCBQcm9qZWN0aW9uIFZlY3RvciBUbyBMaW5lXG4vLyAweDA2LTB4MDdcbmZ1bmN0aW9uIFNQVlRMKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHAyaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDIgPSBzdGF0ZS56MltwMmldO1xuICAgIHZhciBwMSA9IHN0YXRlLnoxW3AxaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygnU1BWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcblxuICAgIGlmICghYSkge1xuICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgfVxuXG4gICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG59XG5cbi8vIFNGVlRMW2FdIFNldCBGcmVlZG9tIFZlY3RvciBUbyBMaW5lXG4vLyAweDA4LTB4MDlcbmZ1bmN0aW9uIFNGVlRMKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHAyaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDIgPSBzdGF0ZS56MltwMmldO1xuICAgIHZhciBwMSA9IHN0YXRlLnoxW3AxaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygnU0ZWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcblxuICAgIGlmICghYSkge1xuICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgfVxuXG4gICAgc3RhdGUuZnYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG59XG5cbi8vIFNQVkZTW10gU2V0IFByb2plY3Rpb24gVmVjdG9yIEZyb20gU3RhY2tcbi8vIDB4MEFcbmZ1bmN0aW9uIFNQVkZTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgeCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVkZTW10nLCB5LCB4KTsgfVxuXG4gICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKHgsIHkpO1xufVxuXG4vLyBTRlZGU1tdIFNldCBGcmVlZG9tIFZlY3RvciBGcm9tIFN0YWNrXG4vLyAweDBCXG5mdW5jdGlvbiBTRlZGUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciB5ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHggPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUFZGU1tdJywgeSwgeCk7IH1cblxuICAgIHN0YXRlLmZ2ID0gZ2V0VW5pdFZlY3Rvcih4LCB5KTtcbn1cblxuLy8gR1BWW10gR2V0IFByb2plY3Rpb24gVmVjdG9yXG4vLyAweDBDXG5mdW5jdGlvbiBHUFYoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHUFZbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKHB2LnggKiAweDQwMDApO1xuICAgIHN0YWNrLnB1c2gocHYueSAqIDB4NDAwMCk7XG59XG5cbi8vIEdGVltdIEdldCBGcmVlZG9tIFZlY3RvclxuLy8gMHgwQ1xuZnVuY3Rpb24gR0ZWKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR0ZWW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChmdi54ICogMHg0MDAwKTtcbiAgICBzdGFjay5wdXNoKGZ2LnkgKiAweDQwMDApO1xufVxuXG4vLyBTRlZUUFZbXSBTZXQgRnJlZWRvbSBWZWN0b3IgVG8gUHJvamVjdGlvbiBWZWN0b3Jcbi8vIDB4MEVcbmZ1bmN0aW9uIFNGVlRQVihzdGF0ZSkge1xuICAgIHN0YXRlLmZ2ID0gc3RhdGUucHY7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0ZWVFBWW10nKTsgfVxufVxuXG4vLyBJU0VDVFtdIG1vdmVzIHBvaW50IHAgdG8gdGhlIEludGVyU0VDVGlvbiBvZiB0d28gbGluZXNcbi8vIDB4MEZcbmZ1bmN0aW9uIElTRUNUKHN0YXRlKVxue1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwYTBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBhMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGIwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwYjFpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHowID0gc3RhdGUuejA7XG4gICAgdmFyIHoxID0gc3RhdGUuejE7XG4gICAgdmFyIHBhMCA9IHowW3BhMGldO1xuICAgIHZhciBwYTEgPSB6MFtwYTFpXTtcbiAgICB2YXIgcGIwID0gejFbcGIwaV07XG4gICAgdmFyIHBiMSA9IHoxW3BiMWldO1xuICAgIHZhciBwID0gc3RhdGUuejJbcGldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coJ0lTRUNUW10sICcsIHBhMGksIHBhMWksIHBiMGksIHBiMWksIHBpKTsgfVxuXG4gICAgLy8gbWF0aCBmcm9tXG4gICAgLy8gZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmUlRTIlODAlOTNsaW5lX2ludGVyc2VjdGlvbiNHaXZlbl90d29fcG9pbnRzX29uX2VhY2hfbGluZVxuXG4gICAgdmFyIHgxID0gcGEwLng7XG4gICAgdmFyIHkxID0gcGEwLnk7XG4gICAgdmFyIHgyID0gcGExLng7XG4gICAgdmFyIHkyID0gcGExLnk7XG4gICAgdmFyIHgzID0gcGIwLng7XG4gICAgdmFyIHkzID0gcGIwLnk7XG4gICAgdmFyIHg0ID0gcGIxLng7XG4gICAgdmFyIHk0ID0gcGIxLnk7XG5cbiAgICB2YXIgZGl2ID0gKHgxIC0geDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzIC0geDQpO1xuICAgIHZhciBmMSA9IHgxICogeTIgLSB5MSAqIHgyO1xuICAgIHZhciBmMiA9IHgzICogeTQgLSB5MyAqIHg0O1xuXG4gICAgcC54ID0gKGYxICogKHgzIC0geDQpIC0gZjIgKiAoeDEgLSB4MikpIC8gZGl2O1xuICAgIHAueSA9IChmMSAqICh5MyAtIHk0KSAtIGYyICogKHkxIC0geTIpKSAvIGRpdjtcbn1cblxuLy8gU1JQMFtdIFNldCBSZWZlcmVuY2UgUG9pbnQgMFxuLy8gMHgxMFxuZnVuY3Rpb24gU1JQMChzdGF0ZSkge1xuICAgIHN0YXRlLnJwMCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDBbXScsIHN0YXRlLnJwMCk7IH1cbn1cblxuLy8gU1JQMVtdIFNldCBSZWZlcmVuY2UgUG9pbnQgMVxuLy8gMHgxMVxuZnVuY3Rpb24gU1JQMShzdGF0ZSkge1xuICAgIHN0YXRlLnJwMSA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDFbXScsIHN0YXRlLnJwMSk7IH1cbn1cblxuLy8gU1JQMVtdIFNldCBSZWZlcmVuY2UgUG9pbnQgMlxuLy8gMHgxMlxuZnVuY3Rpb24gU1JQMihzdGF0ZSkge1xuICAgIHN0YXRlLnJwMiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDJbXScsIHN0YXRlLnJwMik7IH1cbn1cblxuLy8gU1pQMFtdIFNldCBab25lIFBvaW50ZXIgMFxuLy8gMHgxM1xuZnVuY3Rpb24gU1pQMChzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMFtdJywgbik7IH1cblxuICAgIHN0YXRlLnpwMCA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG4gICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU1pQMVtdIFNldCBab25lIFBvaW50ZXIgMVxuLy8gMHgxNFxuZnVuY3Rpb24gU1pQMShzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMVtdJywgbik7IH1cblxuICAgIHN0YXRlLnpwMSA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG4gICAgICAgICAgICBzdGF0ZS56MSA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MSA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU1pQMltdIFNldCBab25lIFBvaW50ZXIgMlxuLy8gMHgxNVxuZnVuY3Rpb24gU1pQMihzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMltdJywgbik7IH1cblxuICAgIHN0YXRlLnpwMiA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG4gICAgICAgICAgICBzdGF0ZS56MiA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MiA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU1pQU1tdIFNldCBab25lIFBvaW50ZXJTXG4vLyAweDE2XG5mdW5jdGlvbiBTWlBTKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlBTW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuenAwID0gc3RhdGUuenAxID0gc3RhdGUuenAyID0gbjtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcbiAgICB9XG59XG5cbi8vIFNMT09QW10gU2V0IExPT1AgdmFyaWFibGVcbi8vIDB4MTdcbmZ1bmN0aW9uIFNMT09QKHN0YXRlKSB7XG4gICAgc3RhdGUubG9vcCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NMT09QW10nLCBzdGF0ZS5sb29wKTsgfVxufVxuXG4vLyBSVEdbXSBSb3VuZCBUbyBHcmlkXG4vLyAweDE4XG5mdW5jdGlvbiBSVEcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlRHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFRvR3JpZDtcbn1cblxuLy8gUlRIR1tdIFJvdW5kIFRvIEhhbGYgR3JpZFxuLy8gMHgxOVxuZnVuY3Rpb24gUlRIRyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVEhHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFRvSGFsZkdyaWQ7XG59XG5cbi8vIFNNRFtdIFNldCBNaW5pbXVtIERpc3RhbmNlXG4vLyAweDFBXG5mdW5jdGlvbiBTTUQoc3RhdGUpIHtcbiAgICB2YXIgZCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NNRFtdJywgZCk7IH1cblxuICAgIHN0YXRlLm1pbkRpcyA9IGQgLyAweDQwO1xufVxuXG4vLyBFTFNFW10gRUxTRSBjbGF1c2Vcbi8vIDB4MUJcbmZ1bmN0aW9uIEVMU0Uoc3RhdGUpIHtcbiAgICAvLyBUaGlzIGluc3RydWN0aW9uIGhhcyBiZWVuIHJlYWNoZWQgYnkgZXhlY3V0aW5nIGEgdGhlbiBicmFuY2hcbiAgICAvLyBzbyBpdCBqdXN0IHNraXBzIGFoZWFkIHVudGlsIG1hdGNoaW5nIEVJRi5cbiAgICAvL1xuICAgIC8vIEluIGNhc2UgdGhlIElGIHdhcyBuZWdhdGl2ZSB0aGUgSUZbXSBpbnN0cnVjdGlvbiBhbHJlYWR5XG4gICAgLy8gc2tpcHBlZCBmb3J3YXJkIG92ZXIgdGhlIEVMU0VbXVxuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VMU0VbXScpOyB9XG5cbiAgICBza2lwKHN0YXRlLCBmYWxzZSk7XG59XG5cbi8vIEpNUFJbXSBKdU1QIFJlbGF0aXZlXG4vLyAweDFDXG5mdW5jdGlvbiBKTVBSKHN0YXRlKSB7XG4gICAgdmFyIG8gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdKTVBSW10nLCBvKTsgfVxuXG4gICAgLy8gQSBqdW1wIGJ5IDEgd291bGQgZG8gbm90aGluZy5cbiAgICBzdGF0ZS5pcCArPSBvIC0gMTtcbn1cblxuLy8gU0NWVENJW10gU2V0IENvbnRyb2wgVmFsdWUgVGFibGUgQ3V0LUluXG4vLyAweDFEXG5mdW5jdGlvbiBTQ1ZUQ0koc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDVlRDSVtdJywgbik7IH1cblxuICAgIHN0YXRlLmN2Q3V0SW4gPSBuIC8gMHg0MDtcbn1cblxuLy8gRFVQW10gRFVQbGljYXRlIHRvcCBzdGFjayBlbGVtZW50XG4vLyAweDIwXG5mdW5jdGlvbiBEVVAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdEVVBbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKTtcbn1cblxuLy8gUE9QW10gUE9QIHRvcCBzdGFjayBlbGVtZW50XG4vLyAweDIxXG5mdW5jdGlvbiBQT1Aoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUE9QW10nKTsgfVxuXG4gICAgc3RhdGUuc3RhY2sucG9wKCk7XG59XG5cbi8vIENMRUFSW10gQ0xFQVIgdGhlIHN0YWNrXG4vLyAweDIyXG5mdW5jdGlvbiBDTEVBUihzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDTEVBUltdJyk7IH1cblxuICAgIHN0YXRlLnN0YWNrLmxlbmd0aCA9IDA7XG59XG5cbi8vIFNXQVBbXSBTV0FQIHRoZSB0b3AgdHdvIGVsZW1lbnRzIG9uIHRoZSBzdGFja1xuLy8gMHgyM1xuZnVuY3Rpb24gU1dBUChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgdmFyIGEgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgYiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NXQVBbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKGEpO1xuICAgIHN0YWNrLnB1c2goYik7XG59XG5cbi8vIERFUFRIW10gREVQVEggb2YgdGhlIHN0YWNrXG4vLyAweDI0XG5mdW5jdGlvbiBERVBUSChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFUFRIW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGFjay5sZW5ndGgpO1xufVxuXG4vLyBMT09QQ0FMTFtdIExPT1BDQUxMIGZ1bmN0aW9uXG4vLyAweDJBXG5mdW5jdGlvbiBMT09QQ0FMTChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBmbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTE9PUENBTExbXScsIGZuLCBjKTsgfVxuXG4gICAgLy8gc2F2ZXMgY2FsbGVycyBwcm9ncmFtXG4gICAgdmFyIGNpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBjcHJvZyA9IHN0YXRlLnByb2c7XG5cbiAgICBzdGF0ZS5wcm9nID0gc3RhdGUuZnVuY3NbZm5dO1xuXG4gICAgLy8gZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyBpKyspIHtcbiAgICAgICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coXG4gICAgICAgICAgICArK3N0YXRlLnN0ZXAsXG4gICAgICAgICAgICBpICsgMSA8IGMgPyAnbmV4dCBsb29wY2FsbCcgOiAnZG9uZSBsb29wY2FsbCcsXG4gICAgICAgICAgICBpXG4gICAgICAgICk7IH1cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlcyB0aGUgY2FsbGVycyBwcm9ncmFtXG4gICAgc3RhdGUuaXAgPSBjaXA7XG4gICAgc3RhdGUucHJvZyA9IGNwcm9nO1xufVxuXG4vLyBDQUxMW10gQ0FMTCBmdW5jdGlvblxuLy8gMHgyQlxuZnVuY3Rpb24gQ0FMTChzdGF0ZSkge1xuICAgIHZhciBmbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NBTExbXScsIGZuKTsgfVxuXG4gICAgLy8gc2F2ZXMgY2FsbGVycyBwcm9ncmFtXG4gICAgdmFyIGNpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBjcHJvZyA9IHN0YXRlLnByb2c7XG5cbiAgICBzdGF0ZS5wcm9nID0gc3RhdGUuZnVuY3NbZm5dO1xuXG4gICAgLy8gZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uXG4gICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAvLyByZXN0b3JlcyB0aGUgY2FsbGVycyBwcm9ncmFtXG4gICAgc3RhdGUuaXAgPSBjaXA7XG4gICAgc3RhdGUucHJvZyA9IGNwcm9nO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coKytzdGF0ZS5zdGVwLCAncmV0dXJuaW5nIGZyb20nLCBmbik7IH1cbn1cblxuLy8gQ0lOREVYW10gQ29weSB0aGUgSU5ERVhlZCBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4vLyAweDI1XG5mdW5jdGlvbiBDSU5ERVgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgayA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NJTkRFWFtdJywgayk7IH1cblxuICAgIC8vIEluIGNhc2Ugb2YgayA9PSAxLCBpdCBjb3BpZXMgdGhlIGxhc3QgZWxlbWVudCBhZnRlciBwb3BwaW5nXG4gICAgLy8gdGh1cyBzdGFjay5sZW5ndGggLSBrLlxuICAgIHN0YWNrLnB1c2goc3RhY2tbc3RhY2subGVuZ3RoIC0ga10pO1xufVxuXG4vLyBNSU5ERVhbXSBNb3ZlIHRoZSBJTkRFWGVkIGVsZW1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbi8vIDB4MjZcbmZ1bmN0aW9uIE1JTkRFWChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBrID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTUlOREVYW10nLCBrKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gaywgMSlbMF0pO1xufVxuXG4vLyBGREVGW10gRnVuY3Rpb24gREVGaW5pdGlvblxuLy8gMHgyQ1xuZnVuY3Rpb24gRkRFRihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lbnYgIT09ICdmcGdtJykgeyB0aHJvdyBuZXcgRXJyb3IoJ0ZERUYgbm90IGFsbG93ZWQgaGVyZScpOyB9XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuXG4gICAgdmFyIGZuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGlwQmVnaW4gPSBpcDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdGREVGW10nLCBmbik7IH1cblxuICAgIHdoaWxlIChwcm9nWysraXBdICE9PSAweDJEKXsgfVxuXG4gICAgc3RhdGUuaXAgPSBpcDtcbiAgICBzdGF0ZS5mdW5jc1tmbl0gPSBwcm9nLnNsaWNlKGlwQmVnaW4gKyAxLCBpcCk7XG59XG5cbi8vIE1EQVBbYV0gTW92ZSBEaXJlY3QgQWJzb2x1dGUgUG9pbnRcbi8vIDB4MkUtMHgyRlxuZnVuY3Rpb24gTURBUChyb3VuZCwgc3RhdGUpIHtcbiAgICB2YXIgcGkgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICB2YXIgcCA9IHN0YXRlLnowW3BpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNREFQWycgKyByb3VuZCArICddJywgcGkpOyB9XG5cbiAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHAsIEhQWmVybyk7XG5cbiAgICBpZiAocm91bmQpIHsgZCA9IHN0YXRlLnJvdW5kKGQpOyB9XG5cbiAgICBmdi5zZXRSZWxhdGl2ZShwLCBIUFplcm8sIGQsIHB2KTtcbiAgICBmdi50b3VjaChwKTtcblxuICAgIHN0YXRlLnJwMCA9IHN0YXRlLnJwMSA9IHBpO1xufVxuXG4vLyBJVVBbYV0gSW50ZXJwb2xhdGUgVW50b3VjaGVkIFBvaW50cyB0aHJvdWdoIHRoZSBvdXRsaW5lXG4vLyAweDMwXG5mdW5jdGlvbiBJVVAodiwgc3RhdGUpIHtcbiAgICB2YXIgejIgPSBzdGF0ZS56MjtcbiAgICB2YXIgcExlbiA9IHoyLmxlbmd0aCAtIDI7XG4gICAgdmFyIGNwO1xuICAgIHZhciBwcDtcbiAgICB2YXIgbnA7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSVVQWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBMZW47IGkrKykge1xuICAgICAgICBjcCA9IHoyW2ldOyAvLyBjdXJyZW50IHBvaW50XG5cbiAgICAgICAgLy8gaWYgdGhpcyBwb2ludCBoYXMgYmVlbiB0b3VjaGVkIGdvIG9uXG4gICAgICAgIGlmICh2LnRvdWNoZWQoY3ApKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgcHAgPSBjcC5wcmV2VG91Y2hlZCh2KTtcblxuICAgICAgICAvLyBubyBwb2ludCBvbiB0aGUgY29udG91ciBoYXMgYmVlbiB0b3VjaGVkP1xuICAgICAgICBpZiAocHAgPT09IGNwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgbnAgPSBjcC5uZXh0VG91Y2hlZCh2KTtcblxuICAgICAgICBpZiAocHAgPT09IG5wKSB7XG4gICAgICAgICAgICAvLyBvbmx5IG9uZSBwb2ludCBvbiB0aGUgY29udG91ciBoYXMgYmVlbiB0b3VjaGVkXG4gICAgICAgICAgICAvLyBzbyBzaW1wbHkgbW92ZXMgdGhlIHBvaW50IGxpa2UgdGhhdFxuXG4gICAgICAgICAgICB2LnNldFJlbGF0aXZlKGNwLCBjcCwgdi5kaXN0YW5jZShwcCwgcHAsIGZhbHNlLCB0cnVlKSwgdiwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2LmludGVycG9sYXRlKGNwLCBwcCwgbnAsIHYpO1xuICAgIH1cbn1cblxuLy8gU0hQW10gU0hpZnQgUG9pbnQgdXNpbmcgcmVmZXJlbmNlIHBvaW50XG4vLyAweDMyLTB4MzNcbmZ1bmN0aW9uIFNIUChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuICAgIHZhciBycCA9IChhID8gc3RhdGUuejAgOiBzdGF0ZS56MSlbcnBpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcbiAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgdmFyIHoyID0gc3RhdGUuejI7XG5cbiAgICB3aGlsZSAobG9vcC0tKVxuICAgIHtcbiAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBwID0gejJbcGldO1xuXG4gICAgICAgIHZhciBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTtcbiAgICAgICAgZnYudG91Y2gocCk7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID9cbiAgICAgICAgICAgICAgICAgICAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOlxuICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICAgJ1NIUFsnICsgKGEgPyAncnAxJyA6ICdycDInKSArICddJywgcGlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5sb29wID0gMTtcbn1cblxuLy8gU0hDW10gU0hpZnQgQ29udG91ciB1c2luZyByZWZlcmVuY2UgcG9pbnRcbi8vIDB4MzYtMHgzN1xuZnVuY3Rpb24gU0hDKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwaSA9IGEgPyBzdGF0ZS5ycDEgOiBzdGF0ZS5ycDI7XG4gICAgdmFyIHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciBjaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBzcCA9IHN0YXRlLnoyW3N0YXRlLmNvbnRvdXJzW2NpXV07XG4gICAgdmFyIHAgPSBzcDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTSENbJyArIGEgKyAnXScsIGNpKTsgfVxuXG4gICAgdmFyIGQgPSBwdi5kaXN0YW5jZShycCwgcnAsIGZhbHNlLCB0cnVlKTtcblxuICAgIGRvIHtcbiAgICAgICAgaWYgKHAgIT09IHJwKSB7IGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTsgfVxuICAgICAgICBwID0gcC5uZXh0UG9pbnRPbkNvbnRvdXI7XG4gICAgfSB3aGlsZSAocCAhPT0gc3ApO1xufVxuXG4vLyBTSFpbXSBTSGlmdCBab25lIHVzaW5nIHJlZmVyZW5jZSBwb2ludFxuLy8gMHgzNi0weDM3XG5mdW5jdGlvbiBTSFooYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnBpID0gYSA/IHN0YXRlLnJwMSA6IHN0YXRlLnJwMjtcbiAgICB2YXIgcnAgPSAoYSA/IHN0YXRlLnowIDogc3RhdGUuejEpW3JwaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cbiAgICB2YXIgZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NIWlsnICsgYSArICddJywgZSk7IH1cblxuICAgIHZhciB6O1xuICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIDAgOiB6ID0gc3RhdGUudFpvbmU7IGJyZWFrO1xuICAgICAgICBjYXNlIDEgOiB6ID0gc3RhdGUuZ1pvbmU7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDogdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUnKTtcbiAgICB9XG5cbiAgICB2YXIgcDtcbiAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHJwLCBycCwgZmFsc2UsIHRydWUpO1xuICAgIHZhciBwTGVuID0gei5sZW5ndGggLSAyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKVxuICAgIHtcbiAgICAgICAgcCA9IHpbaV07XG4gICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTtcbiAgICAgICAgLy9pZiAocCAhPT0gcnApIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTtcbiAgICB9XG59XG5cbi8vIFNIUElYW10gU0hpZnQgcG9pbnQgYnkgYSBQSVhlbCBhbW91bnRcbi8vIDB4MzhcbmZ1bmN0aW9uIFNIUElYKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBkID0gc3RhY2sucG9wKCkgLyAweDQwO1xuICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuXG4gICAgd2hpbGUgKGxvb3AtLSkge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHAgPSB6MltwaV07XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAnU0hQSVhbXScsIHBpLCBkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCk7XG4gICAgICAgIGZ2LnRvdWNoKHApO1xuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBJUFtdIEludGVycG9sYXRlIFBvaW50XG4vLyAweDM5XG5mdW5jdGlvbiBJUChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBycDFpID0gc3RhdGUucnAxO1xuICAgIHZhciBycDJpID0gc3RhdGUucnAyO1xuICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcbiAgICB2YXIgcnAxID0gc3RhdGUuejBbcnAxaV07XG4gICAgdmFyIHJwMiA9IHN0YXRlLnoxW3JwMmldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLmRwdjtcbiAgICB2YXIgejIgPSBzdGF0ZS56MjtcblxuICAgIHdoaWxlIChsb29wLS0pIHtcbiAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBwID0gejJbcGldO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/ICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJ0lQW10nLCBwaSwgcnAxaSwgJzwtPicsIHJwMmlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdi5pbnRlcnBvbGF0ZShwLCBycDEsIHJwMiwgcHYpO1xuXG4gICAgICAgIGZ2LnRvdWNoKHApO1xuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBNU0lSUFthXSBNb3ZlIFN0YWNrIEluZGlyZWN0IFJlbGF0aXZlIFBvaW50XG4vLyAweDNBLTB4M0JcbmZ1bmN0aW9uIE1TSVJQKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGQgPSBzdGFjay5wb3AoKSAvIDY0O1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwID0gc3RhdGUuejFbcGldO1xuICAgIHZhciBycDAgPSBzdGF0ZS56MFtzdGF0ZS5ycDBdO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG4gICAgZnYuc2V0UmVsYXRpdmUocCwgcnAwLCBkLCBwdik7XG4gICAgZnYudG91Y2gocCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTVNJUlBbJyArIGEgKyAnXScsIGQsIHBpKTsgfVxuXG4gICAgc3RhdGUucnAxID0gc3RhdGUucnAwO1xuICAgIHN0YXRlLnJwMiA9IHBpO1xuICAgIGlmIChhKSB7IHN0YXRlLnJwMCA9IHBpOyB9XG59XG5cbi8vIEFMSUdOUlBbXSBBbGlnbiB0byByZWZlcmVuY2UgcG9pbnQuXG4vLyAweDNDXG5mdW5jdGlvbiBBTElHTlJQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwMGkgPSBzdGF0ZS5ycDA7XG4gICAgdmFyIHJwMCA9IHN0YXRlLnowW3JwMGldO1xuICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcbiAgICB2YXIgejEgPSBzdGF0ZS56MTtcblxuICAgIHdoaWxlIChsb29wLS0pIHtcbiAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBwID0gejFbcGldO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/ICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJ0FMSUdOUlBbXScsIHBpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcnAwLCAwLCBwdik7XG4gICAgICAgIGZ2LnRvdWNoKHApO1xuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBSVEdbXSBSb3VuZCBUbyBEb3VibGUgR3JpZFxuLy8gMHgzRFxuZnVuY3Rpb24gUlRERyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVERHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFRvRG91YmxlR3JpZDtcbn1cblxuLy8gTUlBUFthXSBNb3ZlIEluZGlyZWN0IEFic29sdXRlIFBvaW50XG4vLyAweDNFLTB4M0ZcbmZ1bmN0aW9uIE1JQVAocm91bmQsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcCA9IHN0YXRlLnowW3BpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcbiAgICB2YXIgY3YgPSBzdGF0ZS5jdnRbbl07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAnTUlBUFsnICsgcm91bmQgKyAnXScsXG4gICAgICAgICAgICBuLCAnKCcsIGN2LCAnKScsIHBpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGQgPSBwdi5kaXN0YW5jZShwLCBIUFplcm8pO1xuXG4gICAgaWYgKHJvdW5kKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkIC0gY3YpIDwgc3RhdGUuY3ZDdXRJbikgeyBkID0gY3Y7IH1cblxuICAgICAgICBkID0gc3RhdGUucm91bmQoZCk7XG4gICAgfVxuXG4gICAgZnYuc2V0UmVsYXRpdmUocCwgSFBaZXJvLCBkLCBwdik7XG5cbiAgICBpZiAoc3RhdGUuenAwID09PSAwKSB7XG4gICAgICAgIHAueG8gPSBwLng7XG4gICAgICAgIHAueW8gPSBwLnk7XG4gICAgfVxuXG4gICAgZnYudG91Y2gocCk7XG5cbiAgICBzdGF0ZS5ycDAgPSBzdGF0ZS5ycDEgPSBwaTtcbn1cblxuLy8gTlBVU0JbXSBQVVNIIE4gQnl0ZXNcbi8vIDB4NDBcbmZ1bmN0aW9uIE5QVVNIQihzdGF0ZSkge1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIHZhciBuID0gcHJvZ1srK2lwXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdOUFVTSEJbXScsIG4pOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgeyBzdGFjay5wdXNoKHByb2dbKytpcF0pOyB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vLyBOUFVTSFdbXSBQVVNIIE4gV29yZHNcbi8vIDB4NDFcbmZ1bmN0aW9uIE5QVVNIVyhzdGF0ZSkge1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHByb2dbKytpcF07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTlBVU0hXW10nLCBuKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSAocHJvZ1srK2lwXSA8PCA4KSB8IHByb2dbKytpcF07XG4gICAgICAgIGlmICh3ICYgMHg4MDAwKSB7IHcgPSAtKCh3IF4gMHhmZmZmKSArIDEpOyB9XG4gICAgICAgIHN0YWNrLnB1c2godyk7XG4gICAgfVxuXG4gICAgc3RhdGUuaXAgPSBpcDtcbn1cblxuLy8gV1NbXSBXcml0ZSBTdG9yZVxuLy8gMHg0MlxuZnVuY3Rpb24gV1Moc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgc3RvcmUgPSBzdGF0ZS5zdG9yZTtcblxuICAgIGlmICghc3RvcmUpIHsgc3RvcmUgPSBzdGF0ZS5zdG9yZSA9IFtdOyB9XG5cbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV1MnLCB2LCBsKTsgfVxuXG4gICAgc3RvcmVbbF0gPSB2O1xufVxuXG4vLyBSU1tdIFJlYWQgU3RvcmVcbi8vIDB4NDNcbmZ1bmN0aW9uIFJTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHN0b3JlID0gc3RhdGUuc3RvcmU7XG5cbiAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JTJywgbCk7IH1cblxuICAgIHZhciB2ID0gKHN0b3JlICYmIHN0b3JlW2xdKSB8fCAwO1xuXG4gICAgc3RhY2sucHVzaCh2KTtcbn1cblxuLy8gV0NWVFBbXSBXcml0ZSBDb250cm9sIFZhbHVlIFRhYmxlIGluIFBpeGVsIHVuaXRzXG4vLyAweDQ0XG5mdW5jdGlvbiBXQ1ZUUChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1dDVlRQJywgdiwgbCk7IH1cblxuICAgIHN0YXRlLmN2dFtsXSA9IHYgLyAweDQwO1xufVxuXG4vLyBSQ1ZUW10gUmVhZCBDb250cm9sIFZhbHVlIFRhYmxlIGVudHJ5XG4vLyAweDQ1XG5mdW5jdGlvbiBSQ1ZUKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGN2dGUgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSQ1ZUJywgY3Z0ZSk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhdGUuY3Z0W2N2dGVdICogMHg0MCk7XG59XG5cbi8vIEdDW10gR2V0IENvb3JkaW5hdGUgcHJvamVjdGVkIG9udG8gdGhlIHByb2plY3Rpb24gdmVjdG9yXG4vLyAweDQ2LTB4NDdcbmZ1bmN0aW9uIEdDKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAgPSBzdGF0ZS56MltwaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR0NbJyArIGEgKyAnXScsIHBpKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGF0ZS5kcHYuZGlzdGFuY2UocCwgSFBaZXJvLCBhLCBmYWxzZSkgKiAweDQwKTtcbn1cblxuLy8gTURbYV0gTWVhc3VyZSBEaXN0YW5jZVxuLy8gMHg0OS0weDRBXG5mdW5jdGlvbiBNRChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwaTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGkxID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAyID0gc3RhdGUuejFbcGkyXTtcbiAgICB2YXIgcDEgPSBzdGF0ZS56MFtwaTFdO1xuICAgIHZhciBkID0gc3RhdGUuZHB2LmRpc3RhbmNlKHAxLCBwMiwgYSwgYSk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTURbJyArIGEgKyAnXScsIHBpMiwgcGkxLCAnLT4nLCBkKTsgfVxuXG4gICAgc3RhdGUuc3RhY2sucHVzaChNYXRoLnJvdW5kKGQgKiA2NCkpO1xufVxuXG4vLyBNUFBFTVtdIE1lYXN1cmUgUGl4ZWxzIFBlciBFTVxuLy8gMHg0QlxuZnVuY3Rpb24gTVBQRU0oc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTVBQRU1bXScpOyB9XG4gICAgc3RhdGUuc3RhY2sucHVzaChzdGF0ZS5wcGVtKTtcbn1cblxuLy8gRkxJUE9OW10gc2V0IHRoZSBhdXRvIEZMSVAgQm9vbGVhbiB0byBPTlxuLy8gMHg0RFxuZnVuY3Rpb24gRkxJUE9OKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZMSVBPTltdJyk7IH1cbiAgICBzdGF0ZS5hdXRvRmxpcCA9IHRydWU7XG59XG5cbi8vIExUW10gTGVzcyBUaGFuXG4vLyAweDUwXG5mdW5jdGlvbiBMVChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xUW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUxIDwgZTIgPyAxIDogMCk7XG59XG5cbi8vIExURVFbXSBMZXNzIFRoYW4gb3IgRVF1YWxcbi8vIDB4NTNcbmZ1bmN0aW9uIExURVEoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdMVEVRW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUxIDw9IGUyID8gMSA6IDApO1xufVxuXG4vLyBHVEVRW10gR3JlYXRlciBUaGFuXG4vLyAweDUyXG5mdW5jdGlvbiBHVChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dUW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUxID4gZTIgPyAxIDogMCk7XG59XG5cbi8vIEdURVFbXSBHcmVhdGVyIFRoYW4gb3IgRVF1YWxcbi8vIDB4NTNcbmZ1bmN0aW9uIEdURVEoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHVEVRW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUxID49IGUyID8gMSA6IDApO1xufVxuXG4vLyBFUVtdIEVRdWFsXG4vLyAweDU0XG5mdW5jdGlvbiBFUShzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VRW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUyID09PSBlMSA/IDEgOiAwKTtcbn1cblxuLy8gTkVRW10gTm90IEVRdWFsXG4vLyAweDU1XG5mdW5jdGlvbiBORVEoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdORVFbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTIgIT09IGUxID8gMSA6IDApO1xufVxuXG4vLyBPRERbXSBPRERcbi8vIDB4NTZcbmZ1bmN0aW9uIE9ERChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnT0REW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLnRydW5jKG4pICUgMiA/IDEgOiAwKTtcbn1cblxuLy8gRVZFTltdIEVWRU5cbi8vIDB4NTdcbmZ1bmN0aW9uIEVWRU4oc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VWRU5bXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGgudHJ1bmMobikgJSAyID8gMCA6IDEpO1xufVxuXG4vLyBJRltdIElGIHRlc3Rcbi8vIDB4NThcbmZ1bmN0aW9uIElGKHN0YXRlKSB7XG4gICAgdmFyIHRlc3QgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJRltdJywgdGVzdCk7IH1cblxuICAgIC8vIGlmIHRlc3QgaXMgdHJ1ZSBpdCBqdXN0IGNvbnRpbnVlc1xuICAgIC8vIGlmIG5vdCB0aGUgaXAgaXMgc2tpcHBlZCB1bnRpbCBtYXRjaGluZyBFTFNFIG9yIEVJRlxuICAgIGlmICghdGVzdCkge1xuICAgICAgICBza2lwKHN0YXRlLCB0cnVlKTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAgJ0VJRltdJyk7IH1cbiAgICB9XG59XG5cbi8vIEVJRltdIEVuZCBJRlxuLy8gMHg1OVxuZnVuY3Rpb24gRUlGKHN0YXRlKSB7XG4gICAgLy8gdGhpcyBjYW4gYmUgcmVhY2hlZCBub3JtYWxseSB3aGVuXG4gICAgLy8gZXhlY3V0aW5nIGFuIGVsc2UgYnJhbmNoLlxuICAgIC8vIC0+IGp1c3QgaWdub3JlIGl0XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRUlGW10nKTsgfVxufVxuXG4vLyBBTkRbXSBsb2dpY2FsIEFORFxuLy8gMHg1QVxuZnVuY3Rpb24gQU5EKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQU5EW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUyICYmIGUxID8gMSA6IDApO1xufVxuXG4vLyBPUltdIGxvZ2ljYWwgT1Jcbi8vIDB4NUJcbmZ1bmN0aW9uIE9SKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnT1JbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTIgfHwgZTEgPyAxIDogMCk7XG59XG5cbi8vIE5PVFtdIGxvZ2ljYWwgTk9UXG4vLyAweDVDXG5mdW5jdGlvbiBOT1Qoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05PVFtdJywgZSk7IH1cblxuICAgIHN0YWNrLnB1c2goZSA/IDAgOiAxKTtcbn1cblxuLy8gREVMVEFQMVtdIERFTFRBIGV4Y2VwdGlvbiBQMVxuLy8gREVMVEFQMltdIERFTFRBIGV4Y2VwdGlvbiBQMlxuLy8gREVMVEFQM1tdIERFTFRBIGV4Y2VwdGlvbiBQM1xuLy8gMHg1RCwgMHg3MSwgMHg3MlxuZnVuY3Rpb24gREVMVEFQMTIzKGIsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcbiAgICB2YXIgcHBlbSA9IHN0YXRlLnBwZW07XG4gICAgdmFyIGJhc2UgPSBzdGF0ZS5kZWx0YUJhc2UgKyAoYiAtIDEpICogMTY7XG4gICAgdmFyIGRzID0gc3RhdGUuZGVsdGFTaGlmdDtcbiAgICB2YXIgejAgPSBzdGF0ZS56MDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERUxUQVBbJyArIGIgKyAnXScsIG4sIHN0YWNrKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBhcmcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGFwcGVtID0gYmFzZSArICgoYXJnICYgMHhGMCkgPj4gNCk7XG4gICAgICAgIGlmIChhcHBlbSAhPT0gcHBlbSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBtYWcgPSAoYXJnICYgMHgwRikgLSA4O1xuICAgICAgICBpZiAobWFnID49IDApIHsgbWFnKys7IH1cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBUEZJWCcsIHBpLCAnYnknLCBtYWcgKiBkcyk7IH1cblxuICAgICAgICB2YXIgcCA9IHowW3BpXTtcbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgbWFnICogZHMsIHB2KTtcbiAgICB9XG59XG5cbi8vIFNEQltdIFNldCBEZWx0YSBCYXNlIGluIHRoZSBncmFwaGljcyBzdGF0ZVxuLy8gMHg1RVxuZnVuY3Rpb24gU0RCKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTREJbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS5kZWx0YUJhc2UgPSBuO1xufVxuXG4vLyBTRFNbXSBTZXQgRGVsdGEgU2hpZnQgaW4gdGhlIGdyYXBoaWNzIHN0YXRlXG4vLyAweDVGXG5mdW5jdGlvbiBTRFMoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NEU1tdJywgbik7IH1cblxuICAgIHN0YXRlLmRlbHRhU2hpZnQgPSBNYXRoLnBvdygwLjUsIG4pO1xufVxuXG4vLyBBRERbXSBBRERcbi8vIDB4NjBcbmZ1bmN0aW9uIEFERChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0FERFtdJywgbjIsIG4xKTsgfVxuXG4gICAgc3RhY2sucHVzaChuMSArIG4yKTtcbn1cblxuLy8gU1VCW10gU1VCXG4vLyAweDYxXG5mdW5jdGlvbiBTVUIoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTVUJbXScsIG4yLCBuMSk7IH1cblxuICAgIHN0YWNrLnB1c2gobjEgLSBuMik7XG59XG5cbi8vIERJVltdIERJVlxuLy8gMHg2MlxuZnVuY3Rpb24gRElWKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRElWW10nLCBuMiwgbjEpOyB9XG5cbiAgICBzdGFjay5wdXNoKG4xICogNjQgLyBuMik7XG59XG5cbi8vIE1VTFtdIE1VTFxuLy8gMHg2M1xuZnVuY3Rpb24gTVVMKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTVVMW10nLCBuMiwgbjEpOyB9XG5cbiAgICBzdGFjay5wdXNoKG4xICogbjIgLyA2NCk7XG59XG5cbi8vIEFCU1tdIEFCU29sdXRlIHZhbHVlXG4vLyAweDY0XG5mdW5jdGlvbiBBQlMoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0FCU1tdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5hYnMobikpO1xufVxuXG4vLyBORUdbXSBORUdhdGVcbi8vIDB4NjVcbmZ1bmN0aW9uIE5FRyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTkVHW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaCgtbik7XG59XG5cbi8vIEZMT09SW10gRkxPT1Jcbi8vIDB4NjZcbmZ1bmN0aW9uIEZMT09SKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdGTE9PUltdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5mbG9vcihuIC8gMHg0MCkgKiAweDQwKTtcbn1cblxuLy8gQ0VJTElOR1tdIENFSUxJTkdcbi8vIDB4NjdcbmZ1bmN0aW9uIENFSUxJTkcoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NFSUxJTkdbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGguY2VpbChuIC8gMHg0MCkgKiAweDQwKTtcbn1cblxuLy8gUk9VTkRbYWJdIFJPVU5EIHZhbHVlXG4vLyAweDY4LTB4NkJcbmZ1bmN0aW9uIFJPVU5EKGR0LCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9VTkRbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YXRlLnJvdW5kKG4gLyAweDQwKSAqIDB4NDApO1xufVxuXG4vLyBXQ1ZURltdIFdyaXRlIENvbnRyb2wgVmFsdWUgVGFibGUgaW4gRnVuaXRzXG4vLyAweDcwXG5mdW5jdGlvbiBXQ1ZURihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGwgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXQ1ZURltdJywgdiwgbCk7IH1cblxuICAgIHN0YXRlLmN2dFtsXSA9IHYgKiBzdGF0ZS5wcGVtIC8gc3RhdGUuZm9udC51bml0c1BlckVtO1xufVxuXG4vLyBERUxUQUMxW10gREVMVEEgZXhjZXB0aW9uIEMxXG4vLyBERUxUQUMyW10gREVMVEEgZXhjZXB0aW9uIEMyXG4vLyBERUxUQUMzW10gREVMVEEgZXhjZXB0aW9uIEMzXG4vLyAweDczLCAweDc0LCAweDc1XG5mdW5jdGlvbiBERUxUQUMxMjMoYiwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwcGVtID0gc3RhdGUucHBlbTtcbiAgICB2YXIgYmFzZSA9IHN0YXRlLmRlbHRhQmFzZSArIChiIC0gMSkgKiAxNjtcbiAgICB2YXIgZHMgPSBzdGF0ZS5kZWx0YVNoaWZ0O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBQ1snICsgYiArICddJywgbiwgc3RhY2spOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgYXJnID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBhcHBlbSA9IGJhc2UgKyAoKGFyZyAmIDB4RjApID4+IDQpO1xuICAgICAgICBpZiAoYXBwZW0gIT09IHBwZW0pIHsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgbWFnID0gKGFyZyAmIDB4MEYpIC0gODtcbiAgICAgICAgaWYgKG1hZyA+PSAwKSB7IG1hZysrOyB9XG5cbiAgICAgICAgdmFyIGRlbHRhID0gbWFnICogZHM7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBQ0ZJWCcsIGMsICdieScsIGRlbHRhKTsgfVxuXG4gICAgICAgIHN0YXRlLmN2dFtjXSArPSBkZWx0YTtcbiAgICB9XG59XG5cbi8vIFNST1VORFtdIFN1cGVyIFJPVU5EXG4vLyAweDc2XG5mdW5jdGlvbiBTUk9VTkQoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NST1VORFtdJywgbik7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRTdXBlcjtcblxuICAgIHZhciBwZXJpb2Q7XG5cbiAgICBzd2l0Y2ggKG4gJiAweEMwKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDAuNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4NDA6XG4gICAgICAgICAgICBwZXJpb2QgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg4MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTUk9VTkQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5zclBlcmlvZCA9IHBlcmlvZDtcblxuICAgIHN3aXRjaCAobiAmIDB4MzApIHtcbiAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDEwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuMjUgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDIwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuNSAgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDMwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuNzUgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFNST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIG4gJj0gMHgwRjtcblxuICAgIGlmIChuID09PSAwKSB7IHN0YXRlLnNyVGhyZXNob2xkID0gMDsgfVxuICAgIGVsc2UgeyBzdGF0ZS5zclRocmVzaG9sZCA9IChuIC8gOCAtIDAuNSkgKiBwZXJpb2Q7IH1cbn1cblxuLy8gUzQ1Uk9VTkRbXSBTdXBlciBST1VORCA0NSBkZWdyZWVzXG4vLyAweDc3XG5mdW5jdGlvbiBTNDVST1VORChzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUzQ1Uk9VTkRbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kU3VwZXI7XG5cbiAgICB2YXIgcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHhDMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBwZXJpb2QgPSBNYXRoLnNxcnQoMikgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg0MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IE1hdGguc3FydCgyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4ODA6XG4gICAgICAgICAgICBwZXJpb2QgPSAyICogTWF0aC5zcXJ0KDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUzQ1Uk9VTkQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5zclBlcmlvZCA9IHBlcmlvZDtcblxuICAgIHN3aXRjaCAobiAmIDB4MzApIHtcbiAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDEwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuMjUgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDIwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuNSAgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDMwOlxuICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuNzUgKiBwZXJpb2Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTNDVST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIG4gJj0gMHgwRjtcblxuICAgIGlmIChuID09PSAwKSB7IHN0YXRlLnNyVGhyZXNob2xkID0gMDsgfVxuICAgIGVsc2UgeyBzdGF0ZS5zclRocmVzaG9sZCA9IChuIC8gOCAtIDAuNSkgKiBwZXJpb2Q7IH1cbn1cblxuLy8gUk9GRltdIFJvdW5kIE9mZlxuLy8gMHg3QVxuZnVuY3Rpb24gUk9GRihzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdST0ZGW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZE9mZjtcbn1cblxuLy8gUlVUR1tdIFJvdW5kIFVwIFRvIEdyaWRcbi8vIDB4N0NcbmZ1bmN0aW9uIFJVVEcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlVUR1tdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRVcFRvR3JpZDtcbn1cblxuLy8gUkRUR1tdIFJvdW5kIERvd24gVG8gR3JpZFxuLy8gMHg3RFxuZnVuY3Rpb24gUkRURyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSRFRHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZERvd25Ub0dyaWQ7XG59XG5cbi8vIFNDQU5DVFJMW10gU0NBTiBjb252ZXJzaW9uIENvblRSb0xcbi8vIDB4ODVcbmZ1bmN0aW9uIFNDQU5DVFJMKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIC8vIGlnbm9yZWQgYnkgb3BlbnR5cGUuanNcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTQ0FOQ1RSTFtdJywgbik7IH1cbn1cblxuLy8gU0RQVlRMW2FdIFNldCBEdWFsIFByb2plY3Rpb24gVmVjdG9yIFRvIExpbmVcbi8vIDB4ODYtMHg4N1xuZnVuY3Rpb24gU0RQVlRMKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHAyaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDIgPSBzdGF0ZS56MltwMmldO1xuICAgIHZhciBwMSA9IHN0YXRlLnoxW3AxaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0RQVlRMWycgKyBhICsgJ10nLCBwMmksIHAxaSk7IH1cblxuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG5cbiAgICBpZiAoIWEpIHtcbiAgICAgICAgZHggPSBwMS54IC0gcDIueDtcbiAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IHAyLnkgLSBwMS55O1xuICAgICAgICBkeSA9IHAxLnggLSBwMi54O1xuICAgIH1cblxuICAgIHN0YXRlLmRwdiA9IGdldFVuaXRWZWN0b3IoZHgsIGR5KTtcbn1cblxuLy8gR0VUSU5GT1tdIEdFVCBJTkZPcm1hdGlvblxuLy8gMHg4OFxuZnVuY3Rpb24gR0VUSU5GTyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBzZWwgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgciA9IDA7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR0VUSU5GT1tdJywgc2VsKTsgfVxuXG4gICAgLy8gdjM1IGFzIGluIG5vIHN1YnBpeGVsIGhpbnRpbmdcbiAgICBpZiAoc2VsICYgMHgwMSkgeyByID0gMzU7IH1cblxuICAgIC8vIFRPRE8gcm90YXRpb24gYW5kIHN0cmV0Y2ggY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcbiAgICAvLyBhbmQgdGh1cyB0aG9zZSBHRVRJTkZPIGFyZSBhbHdheXMgMC5cblxuICAgIC8vIG9wZW50eXBlLmpzIGlzIGFsd2F5cyBncmF5IHNjYWxpbmdcbiAgICBpZiAoc2VsICYgMHgyMCkgeyByIHw9IDB4MTAwMDsgfVxuXG4gICAgc3RhY2sucHVzaChyKTtcbn1cblxuLy8gUk9MTFtdIFJPTEwgdGhlIHRvcCB0aHJlZSBzdGFjayBlbGVtZW50c1xuLy8gMHg4QVxuZnVuY3Rpb24gUk9MTChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBhID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgYyA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPTExbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKGIpO1xuICAgIHN0YWNrLnB1c2goYSk7XG4gICAgc3RhY2sucHVzaChjKTtcbn1cblxuLy8gTUFYW10gTUFYaW11bSBvZiB0b3AgdHdvIHN0YWNrIGVsZW1lbnRzXG4vLyAweDhCXG5mdW5jdGlvbiBNQVgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNQVhbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5tYXgoZTEsIGUyKSk7XG59XG5cbi8vIE1JTltdIE1JTmltdW0gb2YgdG9wIHR3byBzdGFjayBlbGVtZW50c1xuLy8gMHg4Q1xuZnVuY3Rpb24gTUlOKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTUlOW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGgubWluKGUxLCBlMikpO1xufVxuXG4vLyBTQ0FOVFlQRVtdIFNDQU5UWVBFXG4vLyAweDhEXG5mdW5jdGlvbiBTQ0FOVFlQRShzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgLy8gaWdub3JlZCBieSBvcGVudHlwZS5qc1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTQ0FOVFlQRVtdJywgbik7IH1cbn1cblxuLy8gSU5TVENUUkxbXSBJTlNUQ1RSTFxuLy8gMHg4RFxuZnVuY3Rpb24gSU5TVENUUkwoc3RhdGUpIHtcbiAgICB2YXIgcyA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgIHZhciB2ID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSU5TVENUUkxbXScsIHMsIHYpOyB9XG5cbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgY2FzZSAxIDogc3RhdGUuaW5oaWJpdEdyaWRGaXQgPSAhIXY7IHJldHVybjtcbiAgICAgICAgY2FzZSAyIDogc3RhdGUuaWdub3JlQ3Z0ID0gISF2OyByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignaW52YWxpZCBJTlNUQ1RSTFtdIHNlbGVjdG9yJyk7XG4gICAgfVxufVxuXG4vLyBQVVNIQlthYmNdIFBVU0ggQnl0ZXNcbi8vIDB4QjAtMHhCN1xuZnVuY3Rpb24gUFVTSEIobiwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUFVTSEJbJyArIG4gKyAnXScpOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgeyBzdGFjay5wdXNoKHByb2dbKytpcF0pOyB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vLyBQVVNIV1thYmNdIFBVU0ggV29yZHNcbi8vIDB4QjgtMHhCRlxuZnVuY3Rpb24gUFVTSFcobiwgc3RhdGUpIHtcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5pcCwgJ1BVU0hXWycgKyBuICsgJ10nKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSAocHJvZ1srK2lwXSA8PCA4KSB8IHByb2dbKytpcF07XG4gICAgICAgIGlmICh3ICYgMHg4MDAwKSB7IHcgPSAtKCh3IF4gMHhmZmZmKSArIDEpOyB9XG4gICAgICAgIHN0YWNrLnB1c2godyk7XG4gICAgfVxuXG4gICAgc3RhdGUuaXAgPSBpcDtcbn1cblxuLy8gTURSUFthYmNkZV0gTW92ZSBEaXJlY3QgUmVsYXRpdmUgUG9pbnRcbi8vIDB4RDAtMHhFRlxuLy8gKGlmIGluZGlyZWN0IGlzIDApXG4vL1xuLy8gYW5kXG4vL1xuLy8gTUlSUFthYmNkZV0gTW92ZSBJbmRpcmVjdCBSZWxhdGl2ZSBQb2ludFxuLy8gMHhFMC0weEZGXG4vLyAoaWYgaW5kaXJlY3QgaXMgMSlcblxuZnVuY3Rpb24gTURSUF9NSVJQKGluZGlyZWN0LCBzZXRScDAsIGtlZXBELCBybywgZHQsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGN2dGUgPSBpbmRpcmVjdCAmJiBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcnAwaSA9IHN0YXRlLnJwMDtcbiAgICB2YXIgcnAgPSBzdGF0ZS56MFtycDBpXTtcbiAgICB2YXIgcCA9IHN0YXRlLnoxW3BpXTtcblxuICAgIHZhciBtZCA9IHN0YXRlLm1pbkRpcztcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5kcHY7XG4gICAgdmFyIG9kOyAvLyBvcmlnaW5hbCBkaXN0YW5jZVxuICAgIHZhciBkOyAvLyBtb3ZpbmcgZGlzdGFuY2VcbiAgICB2YXIgc2lnbjsgLy8gc2lnbiBvZiBkaXN0YW5jZVxuICAgIHZhciBjdjtcblxuICAgIGQgPSBvZCA9IHB2LmRpc3RhbmNlKHAsIHJwLCB0cnVlLCB0cnVlKTtcbiAgICBzaWduID0gZCA+PSAwID8gMSA6IC0xOyAvLyBNYXRoLnNpZ24gd291bGQgYmUgMCBpbiBjYXNlIG9mIDBcblxuICAgIC8vIFRPRE8gY29uc2lkZXIgYXV0b0ZsaXBcbiAgICBkID0gTWF0aC5hYnMoZCk7XG5cbiAgICBpZiAoaW5kaXJlY3QpIHtcbiAgICAgICAgY3YgPSBzdGF0ZS5jdnRbY3Z0ZV07XG5cbiAgICAgICAgaWYgKHJvICYmIE1hdGguYWJzKGQgLSBjdikgPCBzdGF0ZS5jdkN1dEluKSB7IGQgPSBjdjsgfVxuICAgIH1cblxuICAgIGlmIChrZWVwRCAmJiBkIDwgbWQpIHsgZCA9IG1kOyB9XG5cbiAgICBpZiAocm8pIHsgZCA9IHN0YXRlLnJvdW5kKGQpOyB9XG5cbiAgICBmdi5zZXRSZWxhdGl2ZShwLCBycCwgc2lnbiAqIGQsIHB2KTtcbiAgICBmdi50b3VjaChwKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgIChpbmRpcmVjdCA/ICdNSVJQWycgOiAnTURSUFsnKSArXG4gICAgICAgICAgICAoc2V0UnAwID8gJ00nIDogJ20nKSArXG4gICAgICAgICAgICAoa2VlcEQgPyAnPicgOiAnXycpICtcbiAgICAgICAgICAgIChybyA/ICdSJyA6ICdfJykgK1xuICAgICAgICAgICAgKGR0ID09PSAwID8gJ0dyJyA6IChkdCA9PT0gMSA/ICdCbCcgOiAoZHQgPT09IDIgPyAnV2gnIDogJycpKSkgK1xuICAgICAgICAgICAgJ10nLFxuICAgICAgICAgICAgaW5kaXJlY3QgP1xuICAgICAgICAgICAgICAgIGN2dGUgKyAnKCcgKyBzdGF0ZS5jdnRbY3Z0ZV0gKyAnLCcgKyAgY3YgKyAnKScgOlxuICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgcGksXG4gICAgICAgICAgICAnKGQgPScsIG9kLCAnLT4nLCBzaWduICogZCwgJyknXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGUucnAxID0gc3RhdGUucnAwO1xuICAgIHN0YXRlLnJwMiA9IHBpO1xuICAgIGlmIChzZXRScDApIHsgc3RhdGUucnAwID0gcGk7IH1cbn1cblxuLypcbiogVGhlIGluc3RydWN0aW9uIHRhYmxlLlxuKi9cbmluc3RydWN0aW9uVGFibGUgPSBbXG4gICAgLyogMHgwMCAqLyBTVlRDQS5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDEgKi8gU1ZUQ0EuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAvKiAweDAyICovIFNQVlRDQS5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDMgKi8gU1BWVENBLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG4gICAgLyogMHgwNCAqLyBTRlZUQ0EuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcbiAgICAvKiAweDA1ICovIFNGVlRDQS5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDYgKi8gU1BWVEwuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MDcgKi8gU1BWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MDggKi8gU0ZWVEwuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MDkgKi8gU0ZWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MEEgKi8gU1BWRlMsXG4gICAgLyogMHgwQiAqLyBTRlZGUyxcbiAgICAvKiAweDBDICovIEdQVixcbiAgICAvKiAweDBEICovIEdGVixcbiAgICAvKiAweDBFICovIFNGVlRQVixcbiAgICAvKiAweDBGICovIElTRUNULFxuICAgIC8qIDB4MTAgKi8gU1JQMCxcbiAgICAvKiAweDExICovIFNSUDEsXG4gICAgLyogMHgxMiAqLyBTUlAyLFxuICAgIC8qIDB4MTMgKi8gU1pQMCxcbiAgICAvKiAweDE0ICovIFNaUDEsXG4gICAgLyogMHgxNSAqLyBTWlAyLFxuICAgIC8qIDB4MTYgKi8gU1pQUyxcbiAgICAvKiAweDE3ICovIFNMT09QLFxuICAgIC8qIDB4MTggKi8gUlRHLFxuICAgIC8qIDB4MTkgKi8gUlRIRyxcbiAgICAvKiAweDFBICovIFNNRCxcbiAgICAvKiAweDFCICovIEVMU0UsXG4gICAgLyogMHgxQyAqLyBKTVBSLFxuICAgIC8qIDB4MUQgKi8gU0NWVENJLFxuICAgIC8qIDB4MUUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gU1NXQ0lcbiAgICAvKiAweDFGICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFNTV1xuICAgIC8qIDB4MjAgKi8gRFVQLFxuICAgIC8qIDB4MjEgKi8gUE9QLFxuICAgIC8qIDB4MjIgKi8gQ0xFQVIsXG4gICAgLyogMHgyMyAqLyBTV0FQLFxuICAgIC8qIDB4MjQgKi8gREVQVEgsXG4gICAgLyogMHgyNSAqLyBDSU5ERVgsXG4gICAgLyogMHgyNiAqLyBNSU5ERVgsXG4gICAgLyogMHgyNyAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBBTElHTlBUU1xuICAgIC8qIDB4MjggKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4MjkgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gVVRQXG4gICAgLyogMHgyQSAqLyBMT09QQ0FMTCxcbiAgICAvKiAweDJCICovIENBTEwsXG4gICAgLyogMHgyQyAqLyBGREVGLFxuICAgIC8qIDB4MkQgKi8gdW5kZWZpbmVkLCAgIC8vIEVOREYgKGVhdGVuIGJ5IEZERUYpXG4gICAgLyogMHgyRSAqLyBNREFQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDJGICovIE1EQVAuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MzAgKi8gSVVQLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgLyogMHgzMSAqLyBJVVAuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAvKiAweDMyICovIFNIUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzMyAqLyBTSFAuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MzQgKi8gU0hDLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDM1ICovIFNIQy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzNiAqLyBTSFouYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MzcgKi8gU0haLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDM4ICovIFNIUElYLFxuICAgIC8qIDB4MzkgKi8gSVAsXG4gICAgLyogMHgzQSAqLyBNU0lSUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzQiAqLyBNU0lSUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzQyAqLyBBTElHTlJQLFxuICAgIC8qIDB4M0QgKi8gUlRERyxcbiAgICAvKiAweDNFICovIE1JQVAuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4M0YgKi8gTUlBUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg0MCAqLyBOUFVTSEIsXG4gICAgLyogMHg0MSAqLyBOUFVTSFcsXG4gICAgLyogMHg0MiAqLyBXUyxcbiAgICAvKiAweDQzICovIFJTLFxuICAgIC8qIDB4NDQgKi8gV0NWVFAsXG4gICAgLyogMHg0NSAqLyBSQ1ZULFxuICAgIC8qIDB4NDYgKi8gR0MuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4NDcgKi8gR0MuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NDggKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gU0NGU1xuICAgIC8qIDB4NDkgKi8gTUQuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4NEEgKi8gTUQuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NEIgKi8gTVBQRU0sXG4gICAgLyogMHg0QyAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBNUFNcbiAgICAvKiAweDREICovIEZMSVBPTixcbiAgICAvKiAweDRFICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBPRkZcbiAgICAvKiAweDRGICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIERFQlVHXG4gICAgLyogMHg1MCAqLyBMVCxcbiAgICAvKiAweDUxICovIExURVEsXG4gICAgLyogMHg1MiAqLyBHVCxcbiAgICAvKiAweDUzICovIEdURVEsXG4gICAgLyogMHg1NCAqLyBFUSxcbiAgICAvKiAweDU1ICovIE5FUSxcbiAgICAvKiAweDU2ICovIE9ERCxcbiAgICAvKiAweDU3ICovIEVWRU4sXG4gICAgLyogMHg1OCAqLyBJRixcbiAgICAvKiAweDU5ICovIEVJRixcbiAgICAvKiAweDVBICovIEFORCxcbiAgICAvKiAweDVCICovIE9SLFxuICAgIC8qIDB4NUMgKi8gTk9ULFxuICAgIC8qIDB4NUQgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDVFICovIFNEQixcbiAgICAvKiAweDVGICovIFNEUyxcbiAgICAvKiAweDYwICovIEFERCxcbiAgICAvKiAweDYxICovIFNVQixcbiAgICAvKiAweDYyICovIERJVixcbiAgICAvKiAweDYzICovIE1VTCxcbiAgICAvKiAweDY0ICovIEFCUyxcbiAgICAvKiAweDY1ICovIE5FRyxcbiAgICAvKiAweDY2ICovIEZMT09SLFxuICAgIC8qIDB4NjcgKi8gQ0VJTElORyxcbiAgICAvKiAweDY4ICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDY5ICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDZBICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweDZCICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweDZDICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDZEICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDZFICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDZGICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDcwICovIFdDVlRGLFxuICAgIC8qIDB4NzEgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweDcyICovIERFTFRBUDEyMy5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHg3MyAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NzQgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweDc1ICovIERFTFRBQzEyMy5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHg3NiAqLyBTUk9VTkQsXG4gICAgLyogMHg3NyAqLyBTNDVST1VORCxcbiAgICAvKiAweDc4ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEpST1RbXVxuICAgIC8qIDB4NzkgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gSlJPRltdXG4gICAgLyogMHg3QSAqLyBST0ZGLFxuICAgIC8qIDB4N0IgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4N0MgKi8gUlVURyxcbiAgICAvKiAweDdEICovIFJEVEcsXG4gICAgLyogMHg3RSAqLyBQT1AsIC8vIGFjdHVhbGx5IFNBTkdXLCBzdXBwb3NlZCB0byBkbyBvbmx5IGEgcG9wIHRob3VnaFxuICAgIC8qIDB4N0YgKi8gUE9QLCAvLyBhY3R1YWxseSBBQSwgc3VwcG9zZWQgdG8gZG8gb25seSBhIHBvcCB0aG91Z2hcbiAgICAvKiAweDgwICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBQVFxuICAgIC8qIDB4ODEgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFJHT05cbiAgICAvKiAweDgyICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBSR09GRlxuICAgIC8qIDB4ODMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4ODQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4ODUgKi8gU0NBTkNUUkwsXG4gICAgLyogMHg4NiAqLyBTRFBWVEwuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4ODcgKi8gU0RQVlRMLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDg4ICovIEdFVElORk8sXG4gICAgLyogMHg4OSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBJREVGXG4gICAgLyogMHg4QSAqLyBST0xMLFxuICAgIC8qIDB4OEIgKi8gTUFYLFxuICAgIC8qIDB4OEMgKi8gTUlOLFxuICAgIC8qIDB4OEQgKi8gU0NBTlRZUEUsXG4gICAgLyogMHg4RSAqLyBJTlNUQ1RSTCxcbiAgICAvKiAweDhGICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkwICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkxICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkyICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkzICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk0ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk1ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk2ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk3ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk4ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk5ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlBICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlCICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlDICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlEICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlFICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlGICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEEwICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEExICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEEyICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEEzICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE0ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE1ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE2ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE3ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE4ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE5ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFBICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFCICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFDICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFEICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFFICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFGICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEIwICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweEIxICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweEIyICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweEIzICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA0KSxcbiAgICAvKiAweEI0ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA1KSxcbiAgICAvKiAweEI1ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA2KSxcbiAgICAvKiAweEI2ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA3KSxcbiAgICAvKiAweEI3ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA4KSxcbiAgICAvKiAweEI4ICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweEI5ICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweEJBICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweEJCICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA0KSxcbiAgICAvKiAweEJDICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA1KSxcbiAgICAvKiAweEJEICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA2KSxcbiAgICAvKiAweEJFICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA3KSxcbiAgICAvKiAweEJGICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA4KSxcbiAgICAvKiAweEMwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMCksXG4gICAgLyogMHhDMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDEpLFxuICAgIC8qIDB4QzIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAyKSxcbiAgICAvKiAweEMzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMyksXG4gICAgLyogMHhDNCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDApLFxuICAgIC8qIDB4QzUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAxKSxcbiAgICAvKiAweEM2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMiksXG4gICAgLyogMHhDNyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDMpLFxuICAgIC8qIDB4QzggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAwKSxcbiAgICAvKiAweEM5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMCwgMSksXG4gICAgLyogMHhDQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDIpLFxuICAgIC8qIDB4Q0IgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAzKSxcbiAgICAvKiAweENDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMCksXG4gICAgLyogMHhDRCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDEpLFxuICAgIC8qIDB4Q0UgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAyKSxcbiAgICAvKiAweENGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMyksXG4gICAgLyogMHhEMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDApLFxuICAgIC8qIDB4RDEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAxKSxcbiAgICAvKiAweEQyICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMiksXG4gICAgLyogMHhEMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDMpLFxuICAgIC8qIDB4RDQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAwKSxcbiAgICAvKiAweEQ1ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMSwgMSksXG4gICAgLyogMHhENiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDIpLFxuICAgIC8qIDB4RDcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAzKSxcbiAgICAvKiAweEQ4ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMCksXG4gICAgLyogMHhEOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDEpLFxuICAgIC8qIDB4REEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAyKSxcbiAgICAvKiAweERCICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMyksXG4gICAgLyogMHhEQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDApLFxuICAgIC8qIDB4REQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAxKSxcbiAgICAvKiAweERFICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMiksXG4gICAgLyogMHhERiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDMpLFxuICAgIC8qIDB4RTAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAwKSxcbiAgICAvKiAweEUxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMCwgMSksXG4gICAgLyogMHhFMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDIpLFxuICAgIC8qIDB4RTMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAzKSxcbiAgICAvKiAweEU0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMCksXG4gICAgLyogMHhFNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDEpLFxuICAgIC8qIDB4RTYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAyKSxcbiAgICAvKiAweEU3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMyksXG4gICAgLyogMHhFOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDApLFxuICAgIC8qIDB4RTkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAxKSxcbiAgICAvKiAweEVBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMiksXG4gICAgLyogMHhFQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDMpLFxuICAgIC8qIDB4RUMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAwKSxcbiAgICAvKiAweEVEICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMSwgMSksXG4gICAgLyogMHhFRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDIpLFxuICAgIC8qIDB4RUYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAzKSxcbiAgICAvKiAweEYwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMCksXG4gICAgLyogMHhGMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDEpLFxuICAgIC8qIDB4RjIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAyKSxcbiAgICAvKiAweEYzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMyksXG4gICAgLyogMHhGNCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDApLFxuICAgIC8qIDB4RjUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAxKSxcbiAgICAvKiAweEY2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMiksXG4gICAgLyogMHhGNyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDMpLFxuICAgIC8qIDB4RjggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAwKSxcbiAgICAvKiAweEY5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMCwgMSksXG4gICAgLyogMHhGQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDIpLFxuICAgIC8qIDB4RkIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAzKSxcbiAgICAvKiAweEZDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMCksXG4gICAgLyogMHhGRCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDEpLFxuICAgIC8qIDB4RkUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAyKSxcbiAgICAvKiAweEZGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMylcbl07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICBNYXRoZW1hdGljYWwgQ29uc2lkZXJhdGlvbnNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5mdiAuLi4gcmVmZXJzIHRvIGZyZWVkb20gdmVjdG9yXG5wdiAuLi4gcmVmZXJzIHRvIHByb2plY3Rpb24gdmVjdG9yXG5ycCAuLi4gcmVmZXJzIHRvIHJlZmVyZW5jZSBwb2ludFxucCAgLi4uIHJlZmVycyB0byB0byBwb2ludCBiZWluZyBvcGVyYXRlZCBvblxuZCAgLi4uIHJlZmVycyB0byBkaXN0YW5jZVxuXG5TRVRSRUxBVElWRTpcbj09PT09PT09PT09PVxuXG5jYXNlIGZyZWVkb20gdmVjdG9yID09IHgtYXhpczpcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAocHYpXG4gICAgICAgICAgICAgICAgICAgICAuLSdcbiAgICAgICAgICAgICAgcnBkIC4tJ1xuICAgICAgICAgICAgICAgLi0qXG4gICAgICAgICAgZCAuLSc5MMKwJ1xuICAgICAgICAgLi0nICAgICAgICdcbiAgICAgIC4tJyAgICAgICAgICAgJ1xuICAgKi0nICAgICAgICAgICAgICAgJyBiXG4gIHJwICAgICAgICAgICAgICAgICAgJ1xuICAgICAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICBwICotLS0tLS0tLS0tKi0tLS0tLS0tLS0tLS0tIChmdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG1cblxuICBycGR4ID0gcnB4ICsgZCAqIHB2LnhcbiAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cbiAgZXF1YXRpb24gb2YgbGluZSBiXG5cbiAgIHkgLSBycGR5ID0gcHZucyAqICh4LSBycGR4KVxuXG4gICB5ID0gcC55XG5cbiAgIHggPSBycGR4ICsgKCBwLnkgLSBycGR5ICkgLyBwdm5zXG5cblxuY2FzZSBmcmVlZG9tIHZlY3RvciA9PSB5LWF4aXM6XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICogcG1cbiAgICB8XFxcbiAgICB8IFxcXG4gICAgfCAgXFxcbiAgICB8ICAgXFxcbiAgICB8ICAgIFxcXG4gICAgfCAgICAgXFxcbiAgICB8ICAgICAgXFxcbiAgICB8ICAgICAgIFxcXG4gICAgfCAgICAgICAgXFxcbiAgICB8ICAgICAgICAgXFwgYlxuICAgIHwgICAgICAgICAgXFxcbiAgICB8ICAgICAgICAgICBcXFxuICAgIHwgICAgICAgICAgICBcXCAgICAuLScgKHB2KVxuICAgIHwgICAgICAgICA5MMKwIFxcLi0nXG4gICAgfCAgICAgICAgICAgLi0nKiBycGRcbiAgICB8ICAgICAgICAuLSdcbiAgICAqICAgICAqLScgIGRcbiAgICBwICAgICBycFxuXG4gIHJwZHggPSBycHggKyBkICogcHYueFxuICBycGR5ID0gcnB5ICsgZCAqIHB2LnlcblxuICBlcXVhdGlvbiBvZiBsaW5lIGI6XG4gICAgICAgICAgIHB2bnMgLi4uIG5vcm1hbCBzbG9wZSB0byBwdlxuXG4gICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cbiAgIHggPSBwLnhcblxuICAgeSA9IHJwZHkgKyAgcHZucyAqIChwLnggLSBycGR4KVxuXG5cblxuZ2VuZXJpYyBjYXNlOlxuLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4nKGZ2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC4qIHBtXG4gICAgICAgICAgICAgICAgICAgICAgICAuJyAhXG4gICAgICAgICAgICAgICAgICAgICAgLicgICAgLlxuICAgICAgICAgICAgICAgICAgICAuJyAgICAgICFcbiAgICAgICAgICAgICAgICAgIC4nICAgICAgICAgLiBiXG4gICAgICAgICAgICAgICAgLicgICAgICAgICAgICFcbiAgICAgICAgICAgICAgICogICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgcCAgICAgICAgICAgICAgICFcbiAgICAgICAgICAgICAgICAgICAgICAgICA5MMKwICAgLiAgICAuLi4gKHB2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uLSotJycnXG4gICAgICAgICAgICAgICAgICAuLi4tLS0nJycgICAgcnBkXG4gICAgICAgICAuLi4tLS0nJycgICBkXG4gICAqLS0nJydcbiAgcnBcblxuICAgIHJwZHggPSBycHggKyBkICogcHYueFxuICAgIHJwZHkgPSBycHkgKyBkICogcHYueVxuXG4gZXF1YXRpb24gb2YgbGluZSBiOlxuICAgIHB2bnMuLi4gbm9ybWFsIHNsb3BlIHRvIHB2XG5cbiAgICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cbiBlcXVhdGlvbiBvZiBmcmVlZG9tIHZlY3RvciBsaW5lOlxuICAgIGZ2cyAuLi4gc2xvcGUgb2YgZnJlZWRvbSB2ZWN0b3IgKD1meS9meClcblxuICAgIHkgLSBweSA9IGZ2cyAqICh4IC0gcHgpXG5cblxuICBvbiBwbSBib3RoIGVxdWF0aW9ucyBhcmUgdHJ1ZSBmb3Igc2FtZSB4L3lcblxuICAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuICAgIHkgLSBweSA9IGZ2cyAqICh4IC0gcHgpXG5cbiAgZm9ybSB0byB5IGFuZCBzZXQgZXF1YWw6XG5cbiAgICBwdm5zICogKHggLSBycGR4KSArIHJwZHkgPSBmdnMgKiAoeCAtIHB4KSArIHB5XG5cbiAgZXhwYW5kOlxuXG4gICAgcHZucyAqIHggLSBwdm5zICogcnBkeCArIHJwZHkgPSBmdnMgKiB4IC0gZnZzICogcHggKyBweVxuXG4gIHN3aXRjaDpcblxuICAgIGZ2cyAqIHggLSBmdnMgKiBweCArIHB5ID0gcHZucyAqIHggLSBwdm5zICogcnBkeCArIHJwZHlcblxuICBzb2x2ZSBmb3IgeDpcblxuICAgIGZ2cyAqIHggLSBwdm5zICogeCA9IGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggLSBweSArIHJwZHlcblxuXG5cbiAgICAgICAgICBmdnMgKiBweCAtIHB2bnMgKiBycGR4ICsgcnBkeSAtIHB5XG4gICAgeCA9ICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICBmdnMgLSBwdm5zXG5cbiAgYW5kOlxuXG4gICAgeSA9IGZ2cyAqICh4IC0gcHgpICsgcHlcblxuXG5cbklOVEVSUE9MQVRFOlxuPT09PT09PT09PT09XG5cbkV4YW1wbGVzIG9mIHBvaW50IGludGVycG9sYXRpb24uXG5cblRoZSB3ZWlnaHQgb2YgdGhlIG1vdmVtZW50IG9mIHRoZSByZWZlcmVuY2UgcG9pbnQgZ2V0cyBiaWdnZXJcbnRoZSBmdXJ0aGVyIHRoZSBvdGhlciByZWZlcmVuY2UgcG9pbnQgaXMgYXdheSwgdGh1cyB0aGUgc2FmZXN0XG5vcHRpb24gKHRoYXQgaXMgYXZvaWRpbmcgMC8wIGRpdmlzaW9ucykgaXMgdG8gd2VpZ2h0IHRoZVxub3JpZ2luYWwgZGlzdGFuY2Ugb2YgdGhlIG90aGVyIHBvaW50IGJ5IHRoZSBzdW0gb2YgYm90aCBkaXN0YW5jZXMuXG5cbklmIHRoZSBzdW0gb2YgYm90aCBkaXN0YW5jZXMgaXMgMCwgdGhlbiBtb3ZlIHRoZSBwb2ludCBieSB0aGVcbmFyaXRobWV0aWMgYXZlcmFnZSBvZiB0aGUgbW92ZW1lbnQgb2YgYm90aCByZWZlcmVuY2UgcG9pbnRzLlxuXG5cblxuXG4gICAgICAgICAgICgrNilcbiAgICBycDFvICotLS0tPipycDFcbiAgICAgICAgIC4gICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgICgrMTIpXG4gICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgcnAybyAqLS0tLS0tLS0tLT4qIHJwMlxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgLiAgICAxMCAgICAgICAgICAyMCAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgfC4uLi4uLi4uLnwuLi4uLi4uLi4uLi4uLi4uLi4ufCAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgIC4gKCs4KSAgICAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgIHBvICotLS0tLS0+KnAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgICAxMiAgICAgLiAgICAgICAgICAyNCAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgfC4uLi4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDM2XG5cblxuLS0tLS0tLVxuXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgICAgICgtMTApXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgcnAyICo8LS0tLS0tLS0tKiBycG8yXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuICAgICAgICAgLlxuICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIC4gICAgMTAgICAuICAgICAgICAgIDMwICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICB8Li4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gKCs1KSAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgIHBvICotLS0+KiBwICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gICAgLiAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gICAgLiAgIDIwICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIHwuLi4ufC4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgICAgNSAgICAgICAgMTVcblxuXG4tLS0tLS0tXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgICAgICAgLlxuICAgIHJwMm8gKi0tLS0tLS0tPipycDJcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCsxMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG8gKi0tLS0tLS0tPiogcFxuXG4tLS0tLS0tXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgICAgICAgLigrMzApXG4gICAgcnAybyAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4qcnAyXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgrMjUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4qIHBcblxuXG5cbnZpbTogc2V0IHRzPTQgc3c9NCBleHBhbmR0YWI6XG4qKioqKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBpbnRvIGEgbGlzdCBvZiB0b2tlbnMuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIGEgc2luZ2xlIGNoYXJcbiAqL1xuZnVuY3Rpb24gVG9rZW4oY2hhcikge1xuICAgIHRoaXMuY2hhciA9IGNoYXI7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMuYWN0aXZlU3RhdGUgPSBudWxsO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjb250ZXh0IHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCByYW5nZSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZE9mZnNldCByYW5nZSBlbmQgaW5kZXggb2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgb3duZXIgY29udGV4dCBuYW1lXG4gKi9cbmZ1bmN0aW9uIENvbnRleHRSYW5nZShzdGFydEluZGV4LCBlbmRPZmZzZXQsIGNvbnRleHROYW1lKSB7XG4gICAgdGhpcy5jb250ZXh0TmFtZSA9IGNvbnRleHROYW1lO1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgdGhpcy5lbmRPZmZzZXQgPSBlbmRPZmZzZXQ7XG59XG5cbi8qKlxuICogQ2hlY2sgY29udGV4dCBzdGFydCBhbmQgZW5kXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgYSB1bmlxdWUgY29udGV4dCBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjaGVja1N0YXJ0IGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoZSBpbmRpY2F0ZXMgYSBjb250ZXh0J3Mgc3RhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNoZWNrRW5kIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoZSBpbmRpY2F0ZXMgYSBjb250ZXh0J3MgZW5kXG4gKi9cbmZ1bmN0aW9uIENvbnRleHRDaGVja2VyKGNvbnRleHROYW1lLCBjaGVja1N0YXJ0LCBjaGVja0VuZCkge1xuICAgIHRoaXMuY29udGV4dE5hbWUgPSBjb250ZXh0TmFtZTtcbiAgICB0aGlzLm9wZW5SYW5nZSA9IG51bGw7XG4gICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB0aGlzLmNoZWNrU3RhcnQgPSBjaGVja1N0YXJ0O1xuICAgIHRoaXMuY2hlY2tFbmQgPSBjaGVja0VuZDtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBDb250ZXh0UGFyYW1zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7YXJyYXl9IGNvbnRleHQgY29udGV4dCBpdGVtc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGN1cnJlbnRJbmRleCBjdXJyZW50IGl0ZW0gaW5kZXhcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnRleHQgcGFyYW1zXG4gKiBAcGFyYW0ge2FycmF5fSBjb250ZXh0IGEgbGlzdCBvZiBpdGVtc1xuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRJbmRleCBjdXJyZW50IGl0ZW0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gQ29udGV4dFBhcmFtcyhjb250ZXh0LCBjdXJyZW50SW5kZXgpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuaW5kZXggPSBjdXJyZW50SW5kZXg7XG4gICAgdGhpcy5sZW5ndGggPSBjb250ZXh0Lmxlbmd0aDtcbiAgICB0aGlzLmN1cnJlbnQgPSBjb250ZXh0W2N1cnJlbnRJbmRleF07XG4gICAgdGhpcy5iYWNrdHJhY2sgPSBjb250ZXh0LnNsaWNlKDAsIGN1cnJlbnRJbmRleCk7XG4gICAgdGhpcy5sb29rYWhlYWQgPSBjb250ZXh0LnNsaWNlKGN1cnJlbnRJbmRleCArIDEpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBldmVudCBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50SWQgZXZlbnQgdW5pcXVlIGlkXG4gKi9cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50SWQpIHtcbiAgICB0aGlzLmV2ZW50SWQgPSBldmVudElkO1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgY29yZSBldmVudHMgYW5kIGF1dG8gc3Vic2NyaWJlIHJlcXVpcmVkIGV2ZW50IGhhbmRsZXJzXG4gKiBAcGFyYW0ge2FueX0gZXZlbnRzIGFuIG9iamVjdCB0aGF0IGVubGlzdHMgY29yZSBldmVudHMgaGFuZGxlcnNcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUNvcmVFdmVudHMoZXZlbnRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY29yZUV2ZW50cyA9IFtcbiAgICAgICAgJ3N0YXJ0JywgJ2VuZCcsICduZXh0JywgJ25ld1Rva2VuJywgJ2NvbnRleHRTdGFydCcsXG4gICAgICAgICdjb250ZXh0RW5kJywgJ2luc2VydFRva2VuJywgJ3JlbW92ZVRva2VuJywgJ3JlbW92ZVJhbmdlJyxcbiAgICAgICAgJ3JlcGxhY2VUb2tlbicsICdyZXBsYWNlUmFuZ2UnLCAnY29tcG9zZVJVRCcsICd1cGRhdGVDb250ZXh0c1JhbmdlcydcbiAgICBdO1xuXG4gICAgY29yZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudElkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzJDEuZXZlbnRzLCBldmVudElkLCB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IEV2ZW50KGV2ZW50SWQpXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKCEhZXZlbnRzKSB7XG4gICAgICAgIGNvcmVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJZCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZXZlbnRzW2V2ZW50SWRdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMkMS5ldmVudHNbZXZlbnRJZF0uc3Vic2NyaWJlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByZXF1aXJlc0NvbnRleHRVcGRhdGUgPSBbXG4gICAgICAgICdpbnNlcnRUb2tlbicsICdyZW1vdmVUb2tlbicsICdyZW1vdmVSYW5nZScsXG4gICAgICAgICdyZXBsYWNlVG9rZW4nLCAncmVwbGFjZVJhbmdlJywgJ2NvbXBvc2VSVUQnXG4gICAgXTtcbiAgICByZXF1aXJlc0NvbnRleHRVcGRhdGUuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJZCkge1xuICAgICAgICB0aGlzJDEuZXZlbnRzW2V2ZW50SWRdLnN1YnNjcmliZShcbiAgICAgICAgICAgIHRoaXMkMS51cGRhdGVDb250ZXh0c1Jhbmdlc1xuICAgICAgICApO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHthbnl9IGV2ZW50cyB0b2tlbml6ZXIgY29yZSBldmVudHNcbiAqL1xuZnVuY3Rpb24gVG9rZW5pemVyKGV2ZW50cykge1xuICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgdGhpcy5yZWdpc3RlcmVkQ29udGV4dHMgPSB7fTtcbiAgICB0aGlzLmNvbnRleHRDaGVja2VycyA9IFtdO1xuICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgdGhpcy5yZWdpc3RlcmVkTW9kaWZpZXJzID0gW107XG5cbiAgICBpbml0aWFsaXplQ29yZUV2ZW50cy5jYWxsKHRoaXMsIGV2ZW50cyk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhdGUgb2YgYSB0b2tlbiwgdXN1YWxseSBjYWxsZWQgYnkgYSBzdGF0ZSBtb2RpZmllci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3RhdGUgaXRlbSBrZXlcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBzdGF0ZSBpdGVtIHZhbHVlXG4gKi9cblRva2VuLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICB0aGlzLmFjdGl2ZVN0YXRlID0geyBrZXk6IGtleSwgdmFsdWU6IHRoaXMuc3RhdGVba2V5XSB9O1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZVN0YXRlO1xufTtcblxuVG9rZW4ucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlSWQpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVtzdGF0ZUlkXSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gaW5kZXggZXhpc3RzIGluIHRoZSB0b2tlbnMgbGlzdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmluYm91bmRJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENvbXBvc2UgYW5kIGFwcGx5IGEgbGlzdCBvZiBvcGVyYXRpb25zIChyZXBsYWNlLCB1cGRhdGUsIGRlbGV0ZSlcbiAqIEBwYXJhbSB7YXJyYXl9IFJVRHMgcmVwbGFjZSwgdXBkYXRlIGFuZCBkZWxldGUgb3BlcmF0aW9uc1xuICogVE9ETzogUGVyZi4gT3B0aW1pemF0aW9uIChsZW5ndGhCZWZvcmUgPT09IGxlbmd0aEFmdGVyID8gZGlzcGF0Y2ggb25jZSlcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5jb21wb3NlUlVEID0gZnVuY3Rpb24gKFJVRHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzaWxlbnQgPSB0cnVlO1xuICAgIHZhciBzdGF0ZSA9IFJVRHMubWFwKGZ1bmN0aW9uIChSVUQpIHsgcmV0dXJuIChcbiAgICAgICAgdGhpcyQxW1JVRFswXV0uYXBwbHkodGhpcyQxLCBSVUQuc2xpY2UoMSkuY29uY2F0KHNpbGVudCkpXG4gICAgKTsgfSk7XG4gICAgdmFyIGhhc0ZBSUxPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eSgnRkFJTCcpXG4gICAgKTsgfTtcbiAgICBpZiAoc3RhdGUuZXZlcnkoaGFzRkFJTE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEZBSUw6IFwiY29tcG9zZVJVRDogb25lIG9yIG1vcmUgb3BlcmF0aW9ucyBoYXNuJ3QgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVwiLFxuICAgICAgICAgICAgcmVwb3J0OiBzdGF0ZS5maWx0ZXIoaGFzRkFJTE9iamVjdClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaCgnY29tcG9zZVJVRCcsIFtzdGF0ZS5maWx0ZXIoZnVuY3Rpb24gKG9wKSB7IHJldHVybiAhaGFzRkFJTE9iamVjdChvcCk7IH0pXSk7XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYSByYW5nZSBvZiB0b2tlbnMgd2l0aCBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCByYW5nZSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCByYW5nZSBvZmZzZXRcbiAqIEBwYXJhbSB7dG9rZW59IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zIHRvIHJlcGxhY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVwbGFjZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0SW5kZXgsIG9mZnNldCwgdG9rZW5zLCBzaWxlbnQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgIT09IG51bGwgPyBvZmZzZXQgOiB0aGlzLnRva2Vucy5sZW5ndGg7XG4gICAgdmFyIGlzVG9rZW5UeXBlID0gdG9rZW5zLmV2ZXJ5KGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4gaW5zdGFuY2VvZiBUb2tlbjsgfSk7XG4gICAgaWYgKCFpc05hTihzdGFydEluZGV4KSAmJiB0aGlzLmluYm91bmRJbmRleChzdGFydEluZGV4KSAmJiBpc1Rva2VuVHlwZSkge1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSB0aGlzLnRva2Vucy5zcGxpY2UuYXBwbHkoXG4gICAgICAgICAgICB0aGlzLnRva2VucywgW3N0YXJ0SW5kZXgsIG9mZnNldF0uY29uY2F0KHRva2VucylcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHsgdGhpcy5kaXNwYXRjaCgncmVwbGFjZVRva2VuJywgW3N0YXJ0SW5kZXgsIG9mZnNldCwgdG9rZW5zXSk7IH1cbiAgICAgICAgcmV0dXJuIFtyZXBsYWNlZCwgdG9rZW5zXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBGQUlMOiAncmVwbGFjZVJhbmdlOiBpbnZhbGlkIHRva2VucyBvciBzdGFydEluZGV4LicgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYSB0b2tlbiB3aXRoIGFub3RoZXIgdG9rZW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICogQHBhcmFtIHt0b2tlbn0gdG9rZW4gYSB0b2tlbiB0byByZXBsYWNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlcGxhY2VUb2tlbiA9IGZ1bmN0aW9uIChpbmRleCwgdG9rZW4sIHNpbGVudCkge1xuICAgIGlmICghaXNOYU4oaW5kZXgpICYmIHRoaXMuaW5ib3VuZEluZGV4KGluZGV4KSAmJiB0b2tlbiBpbnN0YW5jZW9mIFRva2VuKSB7XG4gICAgICAgIHZhciByZXBsYWNlZCA9IHRoaXMudG9rZW5zLnNwbGljZShpbmRleCwgMSwgdG9rZW4pO1xuICAgICAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdyZXBsYWNlVG9rZW4nLCBbaW5kZXgsIHRva2VuXSk7IH1cbiAgICAgICAgcmV0dXJuIFtyZXBsYWNlZFswXSwgdG9rZW5dO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IEZBSUw6ICdyZXBsYWNlVG9rZW46IGludmFsaWQgdG9rZW4gb3IgaW5kZXguJyB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHJhbmdlIG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggcmFuZ2Ugc3RhcnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgcmFuZ2Ugb2Zmc2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlbW92ZVJhbmdlID0gZnVuY3Rpb24oc3RhcnRJbmRleCwgb2Zmc2V0LCBzaWxlbnQpIHtcbiAgICBvZmZzZXQgPSAhaXNOYU4ob2Zmc2V0KSA/IG9mZnNldCA6IHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnMuc3BsaWNlKHN0YXJ0SW5kZXgsIG9mZnNldCk7XG4gICAgaWYgKCFzaWxlbnQpIHsgdGhpcy5kaXNwYXRjaCgncmVtb3ZlUmFuZ2UnLCBbdG9rZW5zLCBzdGFydEluZGV4LCBvZmZzZXRdKTsgfVxuICAgIHJldHVybiB0b2tlbnM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHRva2VuIGF0IGEgY2VydGFpbiBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlbW92ZVRva2VuID0gZnVuY3Rpb24oaW5kZXgsIHNpbGVudCkge1xuICAgIGlmICghaXNOYU4oaW5kZXgpICYmIHRoaXMuaW5ib3VuZEluZGV4KGluZGV4KSkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2Vucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAoIXNpbGVudCkgeyB0aGlzLmRpc3BhdGNoKCdyZW1vdmVUb2tlbicsIFt0b2tlbiwgaW5kZXhdKTsgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgRkFJTDogJ3JlbW92ZVRva2VuOiBpbnZhbGlkIHRva2VuIGluZGV4LicgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEluc2VydCBhIGxpc3Qgb2YgdG9rZW5zIGF0IGEgY2VydGFpbiBpbmRleFxuICogQHBhcmFtIHthcnJheX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnMgdG8gaW5zZXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5zZXJ0IHRoZSBsaXN0IG9mIHRva2VucyBhdCBpbmRleFxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgZGlzcGF0Y2ggZXZlbnRzIGFuZCB1cGRhdGUgY29udGV4dCByYW5nZXNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5pbnNlcnRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbnMsIGluZGV4LCBzaWxlbnQpIHtcbiAgICB2YXIgdG9rZW5UeXBlID0gdG9rZW5zLmV2ZXJ5KFxuICAgICAgICBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuIGluc3RhbmNlb2YgVG9rZW47IH1cbiAgICApO1xuICAgIGlmICh0b2tlblR5cGUpIHtcbiAgICAgICAgdGhpcy50b2tlbnMuc3BsaWNlLmFwcGx5KFxuICAgICAgICAgICAgdGhpcy50b2tlbnMsIFtpbmRleCwgMF0uY29uY2F0KHRva2VucylcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHsgdGhpcy5kaXNwYXRjaCgnaW5zZXJ0VG9rZW4nLCBbdG9rZW5zLCBpbmRleF0pOyB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgRkFJTDogJ2luc2VydFRva2VuOiBpbnZhbGlkIHRva2VuKHMpLicgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEEgc3RhdGUgbW9kaWZpZXIgdGhhdCBpcyBjYWxsZWQgb24gJ25ld1Rva2VuJyBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGlmaWVySWQgc3RhdGUgbW9kaWZpZXIgaWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBvciBmYWxzZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbW9kaWZpZXIgYSBmdW5jdGlvbiB0byB1cGRhdGUgdG9rZW4gc3RhdGVcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5yZWdpc3Rlck1vZGlmaWVyID0gZnVuY3Rpb24obW9kaWZpZXJJZCwgY29uZGl0aW9uLCBtb2RpZmllcikge1xuICAgIHRoaXMuZXZlbnRzLm5ld1Rva2VuLnN1YnNjcmliZShmdW5jdGlvbih0b2tlbiwgY29udGV4dFBhcmFtcykge1xuICAgICAgICB2YXIgY29uZGl0aW9uUGFyYW1zID0gW3Rva2VuLCBjb250ZXh0UGFyYW1zXTtcbiAgICAgICAgdmFyIGNhbkFwcGx5TW9kaWZpZXIgPSAoXG4gICAgICAgICAgICBjb25kaXRpb24gPT09IG51bGwgfHxcbiAgICAgICAgICAgIGNvbmRpdGlvbi5hcHBseSh0aGlzLCBjb25kaXRpb25QYXJhbXMpID09PSB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHZhciBtb2RpZmllclBhcmFtcyA9IFt0b2tlbiwgY29udGV4dFBhcmFtc107XG4gICAgICAgIGlmIChjYW5BcHBseU1vZGlmaWVyKSB7XG4gICAgICAgICAgICB2YXIgbmV3U3RhdGVWYWx1ZSA9IG1vZGlmaWVyLmFwcGx5KHRoaXMsIG1vZGlmaWVyUGFyYW1zKTtcbiAgICAgICAgICAgIHRva2VuLnNldFN0YXRlKG1vZGlmaWVySWQsIG5ld1N0YXRlVmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcmVkTW9kaWZpZXJzLnB1c2gobW9kaWZpZXJJZCk7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZSBhIGhhbmRsZXIgdG8gYW4gZXZlbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGV2ZW50SGFuZGxlciBhbiBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gKi9cbkV2ZW50LnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZXZlbnRIYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5zdWJzY3JpYmVycy5wdXNoKGV2ZW50SGFuZGxlcikpIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgRkFJTDogKFwiaW52YWxpZCAnXCIgKyAodGhpcy5ldmVudElkKSArIFwiJyBldmVudCBoYW5kbGVyXCIpfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGFuIGV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWJzSWQgc3Vic2NyaXB0aW9uIGlkXG4gKi9cbkV2ZW50LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzSWQpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLnNwbGljZShzdWJzSWQsIDEpO1xufTtcblxuLyoqXG4gKiBTZXRzIGNvbnRleHQgcGFyYW1zIGN1cnJlbnQgdmFsdWUgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBjb250ZXh0IHBhcmFtcyBjdXJyZW50IHZhbHVlIGluZGV4XG4gKi9cbkNvbnRleHRQYXJhbXMucHJvdG90eXBlLnNldEN1cnJlbnRJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY29udGV4dFtpbmRleF07XG4gICAgdGhpcy5iYWNrdHJhY2sgPSB0aGlzLmNvbnRleHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgIHRoaXMubG9va2FoZWFkID0gdGhpcy5jb250ZXh0LnNsaWNlKGluZGV4ICsgMSk7XG59O1xuXG4vKipcbiAqIEdldCBhbiBpdGVtIGF0IGFuIG9mZnNldCBmcm9tIHRoZSBjdXJyZW50IHZhbHVlXG4gKiBleGFtcGxlIChjdXJyZW50IHZhbHVlIGlzIDMpOlxuICogIDEgICAgMiAgIFszXSAgIDQgICAgNSAgIHwgICBpdGVtcyB2YWx1ZXNcbiAqIC0yICAgLTEgICAgMCAgICAxICAgIDIgICB8ICAgb2Zmc2V0IHZhbHVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBhbiBvZmZzZXQgZnJvbSBjdXJyZW50IHZhbHVlIGluZGV4XG4gKi9cbkNvbnRleHRQYXJhbXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSAob2Zmc2V0ID09PSAwKTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIGNhc2UgKG9mZnNldCA8IDAgJiYgTWF0aC5hYnMob2Zmc2V0KSA8PSB0aGlzLmJhY2t0cmFjay5sZW5ndGgpOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFja3RyYWNrLnNsaWNlKG9mZnNldClbMF07XG4gICAgICAgIGNhc2UgKG9mZnNldCA+IDAgJiYgb2Zmc2V0IDw9IHRoaXMubG9va2FoZWFkLmxlbmd0aCk6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWRbb2Zmc2V0IC0gMV07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgY29udGV4dCByYW5nZSBpbnRvIGEgc3RyaW5nIHZhbHVlXG4gKiBAcGFyYW0ge2NvbnRleHRSYW5nZX0gcmFuZ2UgYSBjb250ZXh0IHJhbmdlXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmFuZ2VUb1RleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb250ZXh0UmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmNoYXI7IH0pLmpvaW4oJycpXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbGwgdG9rZW5zIGludG8gYSBzdHJpbmdcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5jaGFyOyB9KS5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogR2V0IGEgY29udGV4dCBieSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgY29udGV4dCBuYW1lIHRvIGdldFxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dE5hbWUpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMucmVnaXN0ZXJlZENvbnRleHRzW2NvbnRleHROYW1lXTtcbiAgICByZXR1cm4gISFjb250ZXh0ID8gY29udGV4dCA6IG51bGw7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXMgYSBuZXcgZXZlbnQgaGFuZGxlciB0byBhbiBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lIHRvIHN1YnNjcmliZSB0b1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZXZlbnRIYW5kbGVyIGEgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBvbiBldmVudFxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdO1xuICAgIGlmICghIWV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5zdWJzY3JpYmUoZXZlbnRIYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgZXZlbnQgbmFtZVxuICogQHBhcmFtIHthbnl9IGFyZ3MgZXZlbnQgaGFuZGxlciBhcmd1bWVudHNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgYXJncykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGV2ZW50ID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXTtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgICBldmVudC5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmFwcGx5KHRoaXMkMSwgYXJncyB8fCBbXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgY29udGV4dCBjaGVja2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgYSB1bmlxdWUgY29udGV4dCBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb250ZXh0U3RhcnRDaGVjayBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBvbiBjb250ZXh0IHN0YXJ0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb250ZXh0RW5kQ2hlY2sgIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9uIGNvbnRleHQgZW5kXG4gKiBUT0RPOiBjYWxsIHRva2VuaXplIG9uIHJlZ2lzdHJhdGlvbiB0byB1cGRhdGUgY29udGV4dCByYW5nZXMgd2l0aCB0aGUgbmV3IGNvbnRleHQuXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUucmVnaXN0ZXJDb250ZXh0Q2hlY2tlciA9IGZ1bmN0aW9uKGNvbnRleHROYW1lLCBjb250ZXh0U3RhcnRDaGVjaywgY29udGV4dEVuZENoZWNrKSB7XG4gICAgaWYgKCEhdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKSkgeyByZXR1cm4ge1xuICAgICAgICBGQUlMOlxuICAgICAgICAoXCJjb250ZXh0IG5hbWUgJ1wiICsgY29udGV4dE5hbWUgKyBcIicgaXMgYWxyZWFkeSByZWdpc3RlcmVkLlwiKVxuICAgIH07IH1cbiAgICBpZiAodHlwZW9mIGNvbnRleHRTdGFydENoZWNrICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiB7XG4gICAgICAgIEZBSUw6XG4gICAgICAgIFwibWlzc2luZyBjb250ZXh0IHN0YXJ0IGNoZWNrLlwiXG4gICAgfTsgfVxuICAgIGlmICh0eXBlb2YgY29udGV4dEVuZENoZWNrICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiB7XG4gICAgICAgIEZBSUw6XG4gICAgICAgIFwibWlzc2luZyBjb250ZXh0IGVuZCBjaGVjay5cIlxuICAgIH07IH1cbiAgICB2YXIgY29udGV4dENoZWNrZXJzID0gbmV3IENvbnRleHRDaGVja2VyKFxuICAgICAgICBjb250ZXh0TmFtZSwgY29udGV4dFN0YXJ0Q2hlY2ssIGNvbnRleHRFbmRDaGVja1xuICAgICk7XG4gICAgdGhpcy5yZWdpc3RlcmVkQ29udGV4dHNbY29udGV4dE5hbWVdID0gY29udGV4dENoZWNrZXJzO1xuICAgIHRoaXMuY29udGV4dENoZWNrZXJzLnB1c2goY29udGV4dENoZWNrZXJzKTtcbiAgICByZXR1cm4gY29udGV4dENoZWNrZXJzO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgY29udGV4dCByYW5nZSB0b2tlbnNcbiAqIEBwYXJhbSB7Y29udGV4dFJhbmdlfSByYW5nZSBhIGNvbnRleHQgcmFuZ2VcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5nZXRSYW5nZVRva2VucyA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgdmFyIGVuZEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleCArIHJhbmdlLmVuZE9mZnNldDtcbiAgICByZXR1cm4gW10uY29uY2F0KFxuICAgICAgICB0aGlzLnRva2Vuc1xuICAgICAgICAgICAgLnNsaWNlKHJhbmdlLnN0YXJ0SW5kZXgsIGVuZEluZGV4KVxuICAgICk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHJhbmdlcyBvZiBhIGNvbnRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBjb250ZXh0IG5hbWVcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS5nZXRDb250ZXh0UmFuZ2VzID0gZnVuY3Rpb24oY29udGV4dE5hbWUpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSk7XG4gICAgaWYgKCEhY29udGV4dCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5yYW5nZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgRkFJTDogKFwiY29udGV4dCBjaGVja2VyICdcIiArIGNvbnRleHROYW1lICsgXCInIGlzIG5vdCByZWdpc3RlcmVkLlwiKSB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVzZXRzIGNvbnRleHQgcmFuZ2VzIHRvIHJ1biBjb250ZXh0IHVwZGF0ZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJlc2V0Q29udGV4dHNSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlZ2lzdGVyZWRDb250ZXh0cyA9IHRoaXMucmVnaXN0ZXJlZENvbnRleHRzO1xuICAgIGZvciAodmFyIGNvbnRleHROYW1lIGluIHJlZ2lzdGVyZWRDb250ZXh0cykge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZENvbnRleHRzLmhhc093blByb3BlcnR5KGNvbnRleHROYW1lKSkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSByZWdpc3RlcmVkQ29udGV4dHNbY29udGV4dE5hbWVdO1xuICAgICAgICAgICAgY29udGV4dC5yYW5nZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyBjb250ZXh0IHJhbmdlc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnVwZGF0ZUNvbnRleHRzUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzZXRDb250ZXh0c1JhbmdlcygpO1xuICAgIHZhciBjaGFycyA9IHRoaXMudG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmNoYXI7IH0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbnRleHRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhjaGFycywgaSk7XG4gICAgICAgIHRoaXMucnVuQ29udGV4dENoZWNrKGNvbnRleHRQYXJhbXMpO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoKCd1cGRhdGVDb250ZXh0c1JhbmdlcycsIFt0aGlzLnJlZ2lzdGVyZWRDb250ZXh0c10pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBlbmQgb2Zmc2V0IG9mIGFuIG9wZW4gcmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgcmFuZ2UgZW5kIG9mZnNldFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIGNvbnRleHQgbmFtZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnNldEVuZE9mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXQsIGNvbnRleHROYW1lKSB7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpLm9wZW5SYW5nZS5zdGFydEluZGV4O1xuICAgIHZhciByYW5nZSA9IG5ldyBDb250ZXh0UmFuZ2Uoc3RhcnRJbmRleCwgb2Zmc2V0LCBjb250ZXh0TmFtZSk7XG4gICAgdmFyIHJhbmdlcyA9IHRoaXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkucmFuZ2VzO1xuICAgIHJhbmdlLnJhbmdlSWQgPSBjb250ZXh0TmFtZSArIFwiLlwiICsgKHJhbmdlcy5sZW5ndGgpO1xuICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICB0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpLm9wZW5SYW5nZSA9IG51bGw7XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcblxuLyoqXG4gKiBSdW5zIGEgY29udGV4dCBjaGVjayBvbiB0aGUgY3VycmVudCBjb250ZXh0XG4gKiBAcGFyYW0ge2NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY3VycmVudCBjb250ZXh0IHBhcmFtc1xuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLnJ1bkNvbnRleHRDaGVjayA9IGZ1bmN0aW9uKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpbmRleCA9IGNvbnRleHRQYXJhbXMuaW5kZXg7XG4gICAgdGhpcy5jb250ZXh0Q2hlY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udGV4dENoZWNrZXIpIHtcbiAgICAgICAgdmFyIGNvbnRleHROYW1lID0gY29udGV4dENoZWNrZXIuY29udGV4dE5hbWU7XG4gICAgICAgIHZhciBvcGVuUmFuZ2UgPSB0aGlzJDEuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkub3BlblJhbmdlO1xuICAgICAgICBpZiAoIW9wZW5SYW5nZSAmJiBjb250ZXh0Q2hlY2tlci5jaGVja1N0YXJ0KGNvbnRleHRQYXJhbXMpKSB7XG4gICAgICAgICAgICBvcGVuUmFuZ2UgPSBuZXcgQ29udGV4dFJhbmdlKGluZGV4LCBudWxsLCBjb250ZXh0TmFtZSk7XG4gICAgICAgICAgICB0aGlzJDEuZ2V0Q29udGV4dChjb250ZXh0TmFtZSkub3BlblJhbmdlID0gb3BlblJhbmdlO1xuICAgICAgICAgICAgdGhpcyQxLmRpc3BhdGNoKCdjb250ZXh0U3RhcnQnLCBbY29udGV4dE5hbWUsIGluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhb3BlblJhbmdlICYmIGNvbnRleHRDaGVja2VyLmNoZWNrRW5kKGNvbnRleHRQYXJhbXMpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKGluZGV4IC0gb3BlblJhbmdlLnN0YXJ0SW5kZXgpICsgMTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMkMS5zZXRFbmRPZmZzZXQob2Zmc2V0LCBjb250ZXh0TmFtZSk7XG4gICAgICAgICAgICB0aGlzJDEuZGlzcGF0Y2goJ2NvbnRleHRFbmQnLCBbY29udGV4dE5hbWUsIHJhbmdlXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSB0ZXh0IGludG8gYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgYSB0ZXh0IHRvIHRva2VuaXplXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgdGhpcy5yZXNldENvbnRleHRzUmFuZ2VzKCk7XG4gICAgdmFyIGNoYXJzID0gQXJyYXkuZnJvbSh0ZXh0KTtcbiAgICB0aGlzLmRpc3BhdGNoKCdzdGFydCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXIgPSBjaGFyc1tpXTtcbiAgICAgICAgdmFyIGNvbnRleHRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhjaGFycywgaSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goJ25leHQnLCBbY29udGV4dFBhcmFtc10pO1xuICAgICAgICB0aGlzLnJ1bkNvbnRleHRDaGVjayhjb250ZXh0UGFyYW1zKTtcbiAgICAgICAgdmFyIHRva2VuID0gbmV3IFRva2VuKGNoYXIpO1xuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgnbmV3VG9rZW4nLCBbdG9rZW4sIGNvbnRleHRQYXJhbXNdKTtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaCgnZW5kJywgW3RoaXMudG9rZW5zXSk7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zO1xufTtcblxuLy8g4pWt4pSA4pSE4pSE4pSE4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSE4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pWuXG4vLyDilIogQ2hhcmFjdGVyIENsYXNzIEFzc2VydGlvbnMg4pSKIENoZWNrcyBpZiBhIGNoYXIgYmVsb25ncyB0byBhIGNlcnRhaW4gY2xhc3Mg4pSKXG4vLyDilbDilIDilb7ilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilITilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDila9cbi8vIGpzY3M6ZGlzYWJsZSBtYXhpbXVtTGluZUxlbmd0aFxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXIgaXMgQXJhYmljXG4gKiBAcGFyYW0ge3N0cmluZ30gYyBhIHNpbmdsZSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzQXJhYmljQ2hhcihjKSB7XG4gICAgcmV0dXJuIC9bXFx1MDYwMC1cXHUwNjVGXFx1MDY2QS1cXHUwNkQyXFx1MDZGQS1cXHUwNkZGXS8udGVzdChjKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXIgaXMgYW4gaXNvbGF0ZWQgYXJhYmljIGNoYXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNJc29sYXRlZEFyYWJpY0NoYXIoY2hhcikge1xuICAgIHJldHVybiAvW1xcdTA2MzBcXHUwNjkwXFx1MDYyMVxcdTA2MzFcXHUwNjYxXFx1MDY3MVxcdTA2MjJcXHUwNjMyXFx1MDY3MlxcdTA2OTJcXHUwNkMyXFx1MDYyM1xcdTA2NzNcXHUwNjkzXFx1MDZDM1xcdTA2MjRcXHUwNjk0XFx1MDZDNFxcdTA2MjVcXHUwNjc1XFx1MDY5NVxcdTA2QzVcXHUwNkU1XFx1MDY3NlxcdTA2OTZcXHUwNkM2XFx1MDYyN1xcdTA2NzdcXHUwNjk3XFx1MDZDN1xcdTA2NDhcXHUwNjg4XFx1MDY5OFxcdTA2QzhcXHUwNjg5XFx1MDY5OVxcdTA2QzlcXHUwNjhBXFx1MDZDQVxcdTA2NkJcXHUwNjhCXFx1MDZDQlxcdTA2OENcXHUwNjhEXFx1MDZDRFxcdTA2RkRcXHUwNjhFXFx1MDZFRVxcdTA2RkVcXHUwNjJGXFx1MDY4RlxcdTA2Q0ZcXHUwNkVGXS8udGVzdChjaGFyKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXIgaXMgYW4gQXJhYmljIFRhc2hrZWVsIGNoYXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNUYXNoa2VlbEFyYWJpY0NoYXIoY2hhcikge1xuICAgIHJldHVybiAvW1xcdTA2MDAtXFx1MDYwNVxcdTA2MEMtXFx1MDYwRVxcdTA2MTAtXFx1MDYxQlxcdTA2MUVcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURdLy50ZXN0KGNoYXIpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBpcyBMYXRpblxuICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuICovXG5mdW5jdGlvbiBpc0xhdGluQ2hhcihjKSB7XG4gICAgcmV0dXJuIC9bQS16XS8udGVzdChjKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYXIgaXMgd2hpdGVzcGFjZSBjaGFyXG4gKiBAcGFyYW0ge3N0cmluZ30gYyBhIHNpbmdsZSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjKSB7XG4gICAgcmV0dXJuIC9cXHMvLnRlc3QoYyk7XG59XG5cbi8qKlxuICogUXVlcnkgYSBmZWF0dXJlIGJ5IHNvbWUgb2YgaXQncyBwcm9wZXJ0aWVzIHRvIGxvb2t1cCBhIGdseXBoIHN1YnN0aXR1dGlvbi5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBmZWF0dXJlIHF1ZXJ5IGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZvbnR9IGZvbnQgb3BlbnR5cGUgZm9udCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBGZWF0dXJlUXVlcnkoZm9udCkge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgdGhpcy5mZWF0dXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFN1YnN0aXR1dGlvbkFjdGlvblxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaWQgc3Vic3RpdHV0aW9uIHR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YWcgZmVhdHVyZSB0YWdcbiAqIEBwcm9wZXJ0eSB7YW55fSBzdWJzdGl0dXRpb24gc3Vic3RpdHV0aW9uIHZhbHVlKHMpXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBzdWJzdGl0dXRpb24gYWN0aW9uIGluc3RhbmNlXG4gKiBAcGFyYW0ge1N1YnN0aXR1dGlvbkFjdGlvbn0gYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFN1YnN0aXR1dGlvbkFjdGlvbihhY3Rpb24pIHtcbiAgICB0aGlzLmlkID0gYWN0aW9uLmlkO1xuICAgIHRoaXMudGFnID0gYWN0aW9uLnRhZztcbiAgICB0aGlzLnN1YnN0aXR1dGlvbiA9IGFjdGlvbi5zdWJzdGl0dXRpb247XG59XG5cbi8qKlxuICogTG9va3VwIGEgY292ZXJhZ2UgdGFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBnbHlwaEluZGV4IGdseXBoIGluZGV4XG4gKiBAcGFyYW0ge0NvdmVyYWdlVGFibGV9IGNvdmVyYWdlIGNvdmVyYWdlIHRhYmxlXG4gKi9cbmZ1bmN0aW9uIGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIGNvdmVyYWdlKSB7XG4gICAgaWYgKCFnbHlwaEluZGV4KSB7IHJldHVybiAtMTsgfVxuICAgIHN3aXRjaCAoY292ZXJhZ2UuZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBjb3ZlcmFnZS5nbHlwaHMuaW5kZXhPZihnbHlwaEluZGV4KTtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gY292ZXJhZ2UucmFuZ2VzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoSW5kZXggPj0gcmFuZ2Uuc3RhcnQgJiYgZ2x5cGhJbmRleCA8PSByYW5nZS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGdseXBoSW5kZXggLSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIC0xOyAvLyBub3QgZm91bmRcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEhhbmRsZSBhIHNpbmdsZSBzdWJzdGl0dXRpb24gLSBmb3JtYXQgMVxuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuICovXG5mdW5jdGlvbiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQxKGdseXBoSW5kZXgsIHN1YnRhYmxlKSB7XG4gICAgdmFyIHN1YnN0aXR1dGVJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICBpZiAoc3Vic3RpdHV0ZUluZGV4ID09PSAtMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHJldHVybiBnbHlwaEluZGV4ICsgc3VidGFibGUuZGVsdGFHbHlwaElkO1xufVxuXG4vKipcbiAqIEhhbmRsZSBhIHNpbmdsZSBzdWJzdGl0dXRpb24gLSBmb3JtYXQgMlxuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuICovXG5mdW5jdGlvbiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQyKGdseXBoSW5kZXgsIHN1YnRhYmxlKSB7XG4gICAgdmFyIHN1YnN0aXR1dGVJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICBpZiAoc3Vic3RpdHV0ZUluZGV4ID09PSAtMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHJldHVybiBzdWJ0YWJsZS5zdWJzdGl0dXRlW3N1YnN0aXR1dGVJbmRleF07XG59XG5cbi8qKlxuICogTG9va3VwIGEgbGlzdCBvZiBjb3ZlcmFnZSB0YWJsZXNcbiAqIEBwYXJhbSB7YW55fSBjb3ZlcmFnZUxpc3QgYSBsaXN0IG9mIGNvdmVyYWdlIHRhYmxlc1xuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuICovXG5mdW5jdGlvbiBsb29rdXBDb3ZlcmFnZUxpc3QoY292ZXJhZ2VMaXN0LCBjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIGxvb2t1cExpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdmVyYWdlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY292ZXJhZ2UgPSBjb3ZlcmFnZUxpc3RbaV07XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gY29udGV4dFBhcmFtcy5jdXJyZW50O1xuICAgICAgICBnbHlwaEluZGV4ID0gQXJyYXkuaXNBcnJheShnbHlwaEluZGV4KSA/IGdseXBoSW5kZXhbMF0gOiBnbHlwaEluZGV4O1xuICAgICAgICB2YXIgbG9va3VwSW5kZXggPSBsb29rdXBDb3ZlcmFnZShnbHlwaEluZGV4LCBjb3ZlcmFnZSk7XG4gICAgICAgIGlmIChsb29rdXBJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxvb2t1cExpc3QucHVzaChsb29rdXBJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxvb2t1cExpc3QubGVuZ3RoICE9PSBjb3ZlcmFnZUxpc3QubGVuZ3RoKSB7IHJldHVybiAtMTsgfVxuICAgIHJldHVybiBsb29rdXBMaXN0O1xufVxuXG4vKipcbiAqIEhhbmRsZSBjaGFpbmluZyBjb250ZXh0IHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAzXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG4gKi9cbmZ1bmN0aW9uIGNoYWluaW5nU3Vic3RpdHV0aW9uRm9ybWF0Myhjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZSkge1xuICAgIHZhciBsb29rdXBzQ291bnQgPSAoXG4gICAgICAgIHN1YnRhYmxlLmlucHV0Q292ZXJhZ2UubGVuZ3RoICtcbiAgICAgICAgc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UubGVuZ3RoICtcbiAgICAgICAgc3VidGFibGUuYmFja3RyYWNrQ292ZXJhZ2UubGVuZ3RoXG4gICAgKTtcbiAgICBpZiAoY29udGV4dFBhcmFtcy5jb250ZXh0Lmxlbmd0aCA8IGxvb2t1cHNDb3VudCkgeyByZXR1cm4gW107IH1cbiAgICAvLyBJTlBVVCBMT09LVVAgLy9cbiAgICB2YXIgaW5wdXRMb29rdXBzID0gbG9va3VwQ292ZXJhZ2VMaXN0KFxuICAgICAgICBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLCBjb250ZXh0UGFyYW1zXG4gICAgKTtcbiAgICBpZiAoaW5wdXRMb29rdXBzID09PSAtMSkgeyByZXR1cm4gW107IH1cbiAgICAvLyBMT09LQUhFQUQgTE9PS1VQIC8vXG4gICAgdmFyIGxvb2thaGVhZE9mZnNldCA9IHN1YnRhYmxlLmlucHV0Q292ZXJhZ2UubGVuZ3RoIC0gMTtcbiAgICBpZiAoY29udGV4dFBhcmFtcy5sb29rYWhlYWQubGVuZ3RoIDwgc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UubGVuZ3RoKSB7IHJldHVybiBbXTsgfVxuICAgIHZhciBsb29rYWhlYWRDb250ZXh0ID0gY29udGV4dFBhcmFtcy5sb29rYWhlYWQuc2xpY2UobG9va2FoZWFkT2Zmc2V0KTtcbiAgICB3aGlsZSAobG9va2FoZWFkQ29udGV4dC5sZW5ndGggJiYgaXNUYXNoa2VlbEFyYWJpY0NoYXIobG9va2FoZWFkQ29udGV4dFswXS5jaGFyKSkge1xuICAgICAgICBsb29rYWhlYWRDb250ZXh0LnNoaWZ0KCk7XG4gICAgfVxuICAgIHZhciBsb29rYWhlYWRQYXJhbXMgPSBuZXcgQ29udGV4dFBhcmFtcyhsb29rYWhlYWRDb250ZXh0LCAwKTtcbiAgICB2YXIgbG9va2FoZWFkTG9va3VwcyA9IGxvb2t1cENvdmVyYWdlTGlzdChcbiAgICAgICAgc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UsIGxvb2thaGVhZFBhcmFtc1xuICAgICk7XG4gICAgLy8gQkFDS1RSQUNLIExPT0tVUCAvL1xuICAgIHZhciBiYWNrdHJhY2tDb250ZXh0ID0gW10uY29uY2F0KGNvbnRleHRQYXJhbXMuYmFja3RyYWNrKTtcbiAgICBiYWNrdHJhY2tDb250ZXh0LnJldmVyc2UoKTtcbiAgICB3aGlsZSAoYmFja3RyYWNrQ29udGV4dC5sZW5ndGggJiYgaXNUYXNoa2VlbEFyYWJpY0NoYXIoYmFja3RyYWNrQ29udGV4dFswXS5jaGFyKSkge1xuICAgICAgICBiYWNrdHJhY2tDb250ZXh0LnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChiYWNrdHJhY2tDb250ZXh0Lmxlbmd0aCA8IHN1YnRhYmxlLmJhY2t0cmFja0NvdmVyYWdlLmxlbmd0aCkgeyByZXR1cm4gW107IH1cbiAgICB2YXIgYmFja3RyYWNrUGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoYmFja3RyYWNrQ29udGV4dCwgMCk7XG4gICAgdmFyIGJhY2t0cmFja0xvb2t1cHMgPSBsb29rdXBDb3ZlcmFnZUxpc3QoXG4gICAgICAgIHN1YnRhYmxlLmJhY2t0cmFja0NvdmVyYWdlLCBiYWNrdHJhY2tQYXJhbXNcbiAgICApO1xuICAgIHZhciBjb250ZXh0UnVsZXNNYXRjaCA9IChcbiAgICAgICAgaW5wdXRMb29rdXBzLmxlbmd0aCA9PT0gc3VidGFibGUuaW5wdXRDb3ZlcmFnZS5sZW5ndGggJiZcbiAgICAgICAgbG9va2FoZWFkTG9va3Vwcy5sZW5ndGggPT09IHN1YnRhYmxlLmxvb2thaGVhZENvdmVyYWdlLmxlbmd0aCAmJlxuICAgICAgICBiYWNrdHJhY2tMb29rdXBzLmxlbmd0aCA9PT0gc3VidGFibGUuYmFja3RyYWNrQ292ZXJhZ2UubGVuZ3RoXG4gICAgKTtcbiAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdO1xuICAgIGlmIChjb250ZXh0UnVsZXNNYXRjaCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlLmxvb2t1cFJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb29rdXBSZWNvcmQgPSBzdWJ0YWJsZS5sb29rdXBSZWNvcmRzW2ldO1xuICAgICAgICAgICAgdmFyIGxvb2t1cExpc3RJbmRleCA9IGxvb2t1cFJlY29yZC5sb29rdXBMaXN0SW5kZXg7XG4gICAgICAgICAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cEJ5SW5kZXgobG9va3VwTGlzdEluZGV4KTtcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgbG9va3VwVGFibGUuc3VidGFibGVzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnRhYmxlJDEgPSBsb29rdXBUYWJsZS5zdWJ0YWJsZXNbc107XG4gICAgICAgICAgICAgICAgdmFyIGxvb2t1cCA9IHRoaXMuZ2V0TG9va3VwTWV0aG9kKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSQxKTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0aW9uVHlwZSA9IHRoaXMuZ2V0U3Vic3RpdHV0aW9uVHlwZShsb29rdXBUYWJsZSwgc3VidGFibGUkMSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvblR5cGUgPT09ICcxMicpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBpbnB1dExvb2t1cHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnbHlwaEluZGV4ID0gY29udGV4dFBhcmFtcy5nZXQobik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0aW9uID0gbG9va3VwKGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbikgeyBzdWJzdGl0dXRpb25zLnB1c2goc3Vic3RpdHV0aW9uKTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzdGl0dXRpb25zO1xufVxuXG4vKipcbiAqIEhhbmRsZSBsaWdhdHVyZSBzdWJzdGl0dXRpb24gLSBmb3JtYXQgMVxuICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuICovXG5mdW5jdGlvbiBsaWdhdHVyZVN1YnN0aXR1dGlvbkZvcm1hdDEoY29udGV4dFBhcmFtcywgc3VidGFibGUpIHtcbiAgICAvLyBDT1ZFUkFHRSBMT09LVVAgLy9cbiAgICB2YXIgZ2x5cGhJbmRleCA9IGNvbnRleHRQYXJhbXMuY3VycmVudDtcbiAgICB2YXIgbGlnU2V0SW5kZXggPSBsb29rdXBDb3ZlcmFnZShnbHlwaEluZGV4LCBzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgaWYgKGxpZ1NldEluZGV4ID09PSAtMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8vIENPTVBPTkVOVFMgTE9PS1VQXG4gICAgLy8gKCEpIG5vdGUsIGNvbXBvbmVudHMgYXJlIG9yZGVyZWQgaW4gdGhlIHdyaXR0ZW4gZGlyZWN0aW9uLlxuICAgIHZhciBsaWdhdHVyZTtcbiAgICB2YXIgbGlnYXR1cmVTZXQgPSBzdWJ0YWJsZS5saWdhdHVyZVNldHNbbGlnU2V0SW5kZXhdO1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgbGlnYXR1cmVTZXQubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgbGlnYXR1cmUgPSBsaWdhdHVyZVNldFtzXTtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaWdhdHVyZS5jb21wb25lbnRzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICB2YXIgbG9va2FoZWFkSXRlbSA9IGNvbnRleHRQYXJhbXMubG9va2FoZWFkW2xdO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGxpZ2F0dXJlLmNvbXBvbmVudHNbbF07XG4gICAgICAgICAgICBpZiAobG9va2FoZWFkSXRlbSAhPT0gY29tcG9uZW50KSB7IGJyZWFrOyB9XG4gICAgICAgICAgICBpZiAobCA9PT0gbGlnYXR1cmUuY29tcG9uZW50cy5sZW5ndGggLSAxKSB7IHJldHVybiBsaWdhdHVyZTsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEhhbmRsZSBkZWNvbXBvc2l0aW9uIHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAxXG4gKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCBnbHlwaCBpbmRleFxuICogQHBhcmFtIHthbnl9IHN1YnRhYmxlIHN1YnRhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlY29tcG9zaXRpb25TdWJzdGl0dXRpb25Gb3JtYXQxKGdseXBoSW5kZXgsIHN1YnRhYmxlKSB7XG4gICAgdmFyIHN1YnN0aXR1dGVJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICBpZiAoc3Vic3RpdHV0ZUluZGV4ID09PSAtMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHJldHVybiBzdWJ0YWJsZS5zZXF1ZW5jZXNbc3Vic3RpdHV0ZUluZGV4XTtcbn1cblxuLyoqXG4gKiBHZXQgZGVmYXVsdCBzY3JpcHQgZmVhdHVyZXMgaW5kZXhlc1xuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldERlZmF1bHRTY3JpcHRGZWF0dXJlc0luZGV4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcmlwdHMgPSB0aGlzLmZvbnQudGFibGVzLmdzdWIuc2NyaXB0cztcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNjcmlwdHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IHNjcmlwdHNbc107XG4gICAgICAgIGlmIChzY3JpcHQudGFnID09PSAnREZMVCcpIHsgcmV0dXJuIChcbiAgICAgICAgICAgIHNjcmlwdC5zY3JpcHQuZGVmYXVsdExhbmdTeXMuZmVhdHVyZUluZGV4ZXNcbiAgICAgICAgKTsgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuXG4vKipcbiAqIEdldCBmZWF0dXJlIGluZGV4ZXMgb2YgYSBzcGVjaWZpYyBzY3JpcHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHRUYWcgc2NyaXB0IHRhZ1xuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldFNjcmlwdEZlYXR1cmVzSW5kZXhlcyA9IGZ1bmN0aW9uKHNjcmlwdFRhZykge1xuICAgIHZhciB0YWJsZXMgPSB0aGlzLmZvbnQudGFibGVzO1xuICAgIGlmICghdGFibGVzLmdzdWIpIHsgcmV0dXJuIFtdOyB9XG4gICAgaWYgKCFzY3JpcHRUYWcpIHsgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFNjcmlwdEZlYXR1cmVzSW5kZXhlcygpOyB9XG4gICAgdmFyIHNjcmlwdHMgPSB0aGlzLmZvbnQudGFibGVzLmdzdWIuc2NyaXB0cztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IHNjcmlwdHNbaV07XG4gICAgICAgIGlmIChzY3JpcHQudGFnID09PSBzY3JpcHRUYWcgJiYgc2NyaXB0LnNjcmlwdC5kZWZhdWx0TGFuZ1N5cykge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdC5zY3JpcHQuZGVmYXVsdExhbmdTeXMuZmVhdHVyZUluZGV4ZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGFuZ1N5c1JlY29yZHMgPSBzY3JpcHQubGFuZ1N5c1JlY29yZHM7XG4gICAgICAgICAgICBpZiAoISFsYW5nU3lzUmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGFuZ1N5c1JlY29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmdTeXNSZWNvcmQgPSBsYW5nU3lzUmVjb3Jkc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdTeXNSZWNvcmQudGFnID09PSBzY3JpcHRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5nU3lzID0gbGFuZ1N5c1JlY29yZC5sYW5nU3lzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmdTeXMuZmVhdHVyZUluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFNjcmlwdEZlYXR1cmVzSW5kZXhlcygpO1xufTtcblxuLyoqXG4gKiBNYXAgYSBmZWF0dXJlIHRhZyB0byBhIGdzdWIgZmVhdHVyZVxuICogQHBhcmFtIHthbnl9IGZlYXR1cmVzIGdzdWIgZmVhdHVyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHRUYWcgc2NyaXB0IHRhZ1xuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLm1hcFRhZ3NUb0ZlYXR1cmVzID0gZnVuY3Rpb24gKGZlYXR1cmVzLCBzY3JpcHRUYWcpIHtcbiAgICB2YXIgdGFncyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRhZyA9IGZlYXR1cmVzW2ldLnRhZztcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXS5mZWF0dXJlO1xuICAgICAgICB0YWdzW3RhZ10gPSBmZWF0dXJlO1xuICAgIH1cbiAgICB0aGlzLmZlYXR1cmVzW3NjcmlwdFRhZ10udGFncyA9IHRhZ3M7XG59O1xuXG4vKipcbiAqIEdldCBmZWF0dXJlcyBvZiBhIHNwZWNpZmljIHNjcmlwdFxuICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdFRhZyBzY3JpcHQgdGFnXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0U2NyaXB0RmVhdHVyZXMgPSBmdW5jdGlvbiAoc2NyaXB0VGFnKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc1tzY3JpcHRUYWddO1xuICAgIGlmICh0aGlzLmZlYXR1cmVzLmhhc093blByb3BlcnR5KHNjcmlwdFRhZykpIHsgcmV0dXJuIGZlYXR1cmVzOyB9XG4gICAgdmFyIGZlYXR1cmVzSW5kZXhlcyA9IHRoaXMuZ2V0U2NyaXB0RmVhdHVyZXNJbmRleGVzKHNjcmlwdFRhZyk7XG4gICAgaWYgKCFmZWF0dXJlc0luZGV4ZXMpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB2YXIgZ3N1YiA9IHRoaXMuZm9udC50YWJsZXMuZ3N1YjtcbiAgICBmZWF0dXJlcyA9IGZlYXR1cmVzSW5kZXhlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBnc3ViLmZlYXR1cmVzW2luZGV4XTsgfSk7XG4gICAgdGhpcy5mZWF0dXJlc1tzY3JpcHRUYWddID0gZmVhdHVyZXM7XG4gICAgdGhpcy5tYXBUYWdzVG9GZWF0dXJlcyhmZWF0dXJlcywgc2NyaXB0VGFnKTtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG59O1xuXG4vKipcbiAqIEdldCBzdWJzdGl0dXRpb24gdHlwZVxuICogQHBhcmFtIHthbnl9IGxvb2t1cFRhYmxlIGxvb2t1cCB0YWJsZVxuICogQHBhcmFtIHthbnl9IHN1YnRhYmxlIHN1YnRhYmxlXG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0U3Vic3RpdHV0aW9uVHlwZSA9IGZ1bmN0aW9uKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSkge1xuICAgIHZhciBsb29rdXBUeXBlID0gbG9va3VwVGFibGUubG9va3VwVHlwZS50b1N0cmluZygpO1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHN1YnRhYmxlLnN1YnN0Rm9ybWF0LnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIGxvb2t1cFR5cGUgKyBzdWJzdEZvcm1hdDtcbn07XG5cbi8qKlxuICogR2V0IGxvb2t1cCBtZXRob2RcbiAqIEBwYXJhbSB7YW55fSBsb29rdXBUYWJsZSBsb29rdXAgdGFibGVcbiAqIEBwYXJhbSB7YW55fSBzdWJ0YWJsZSBzdWJ0YWJsZVxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldExvb2t1cE1ldGhvZCA9IGZ1bmN0aW9uKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHN1YnN0aXR1dGlvblR5cGUgPSB0aGlzLmdldFN1YnN0aXR1dGlvblR5cGUobG9va3VwVGFibGUsIHN1YnRhYmxlKTtcbiAgICBzd2l0Y2ggKHN1YnN0aXR1dGlvblR5cGUpIHtcbiAgICAgICAgY2FzZSAnMTEnOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbHlwaEluZGV4KSB7IHJldHVybiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQxLmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMkMSwgW2dseXBoSW5kZXgsIHN1YnRhYmxlXVxuICAgICAgICAgICAgKTsgfTtcbiAgICAgICAgY2FzZSAnMTInOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbHlwaEluZGV4KSB7IHJldHVybiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQyLmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMkMSwgW2dseXBoSW5kZXgsIHN1YnRhYmxlXVxuICAgICAgICAgICAgKTsgfTtcbiAgICAgICAgY2FzZSAnNjMnOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0UGFyYW1zKSB7IHJldHVybiBjaGFpbmluZ1N1YnN0aXR1dGlvbkZvcm1hdDMuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyQxLCBbY29udGV4dFBhcmFtcywgc3VidGFibGVdXG4gICAgICAgICAgICApOyB9O1xuICAgICAgICBjYXNlICc0MSc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHRQYXJhbXMpIHsgcmV0dXJuIGxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MS5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzJDEsIFtjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZV1cbiAgICAgICAgICAgICk7IH07XG4gICAgICAgIGNhc2UgJzIxJzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2x5cGhJbmRleCkgeyByZXR1cm4gZGVjb21wb3NpdGlvblN1YnN0aXR1dGlvbkZvcm1hdDEuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyQxLCBbZ2x5cGhJbmRleCwgc3VidGFibGVdXG4gICAgICAgICAgICApOyB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwibG9va3VwVHlwZTogXCIgKyAobG9va3VwVGFibGUubG9va3VwVHlwZSkgKyBcIiAtIFwiICtcbiAgICAgICAgICAgICAgICBcInN1YnN0Rm9ybWF0OiBcIiArIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCkgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgXCJpcyBub3QgeWV0IHN1cHBvcnRlZFwiXG4gICAgICAgICAgICApO1xuICAgIH1cbn07XG5cbi8qKlxuICogWyBMT09LVVAgVFlQRVMgXVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogU2luZ2xlICAgICAgICAgICAgICAgICAgICAgICAgMTtcbiAqIE11bHRpcGxlICAgICAgICAgICAgICAgICAgICAgIDI7XG4gKiBBbHRlcm5hdGUgICAgICAgICAgICAgICAgICAgICAzO1xuICogTGlnYXR1cmUgICAgICAgICAgICAgICAgICAgICAgNDtcbiAqIENvbnRleHQgICAgICAgICAgICAgICAgICAgICAgIDU7XG4gKiBDaGFpbmluZ0NvbnRleHQgICAgICAgICAgICAgICA2O1xuICogRXh0ZW5zaW9uU3Vic3RpdHV0aW9uICAgICAgICAgNztcbiAqIFJldmVyc2VDaGFpbmluZ0NvbnRleHQgICAgICAgIDg7XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgRlF1ZXJ5XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgZmVhdHVyZSB0YWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHQgZmVhdHVyZSBzY3JpcHRcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtc1xuICovXG5cbi8qKlxuICogTG9va3VwIGEgZmVhdHVyZSB1c2luZyBhIHF1ZXJ5IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RlF1ZXJ5fSBxdWVyeSBmZWF0dXJlIHF1ZXJ5XG4gKi9cbkZlYXR1cmVRdWVyeS5wcm90b3R5cGUubG9va3VwRmVhdHVyZSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIHZhciBjb250ZXh0UGFyYW1zID0gcXVlcnkuY29udGV4dFBhcmFtcztcbiAgICB2YXIgY3VycmVudEluZGV4ID0gY29udGV4dFBhcmFtcy5pbmRleDtcbiAgICB2YXIgZmVhdHVyZSA9IHRoaXMuZ2V0RmVhdHVyZSh7XG4gICAgICAgIHRhZzogcXVlcnkudGFnLCBzY3JpcHQ6IHF1ZXJ5LnNjcmlwdFxuICAgIH0pO1xuICAgIGlmICghZmVhdHVyZSkgeyByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICBcImZvbnQgJ1wiICsgKHRoaXMuZm9udC5uYW1lcy5mdWxsTmFtZS5lbikgKyBcIicgXCIgK1xuICAgICAgICBcImRvZXNuJ3Qgc3VwcG9ydCBmZWF0dXJlICdcIiArIChxdWVyeS50YWcpICsgXCInIFwiICtcbiAgICAgICAgXCJmb3Igc2NyaXB0ICdcIiArIChxdWVyeS5zY3JpcHQpICsgXCInLlwiXG4gICAgKTsgfVxuICAgIHZhciBsb29rdXBzID0gdGhpcy5nZXRGZWF0dXJlTG9va3VwcyhmZWF0dXJlKTtcbiAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdLmNvbmNhdChjb250ZXh0UGFyYW1zLmNvbnRleHQpO1xuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbG9va3Vwcy5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgbG9va3VwVGFibGUgPSBsb29rdXBzW2xdO1xuICAgICAgICB2YXIgc3VidGFibGVzID0gdGhpcy5nZXRMb29rdXBTdWJ0YWJsZXMobG9va3VwVGFibGUpO1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHN1YnRhYmxlcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW3NdO1xuICAgICAgICAgICAgdmFyIHN1YnN0VHlwZSA9IHRoaXMuZ2V0U3Vic3RpdHV0aW9uVHlwZShsb29rdXBUYWJsZSwgc3VidGFibGUpO1xuICAgICAgICAgICAgdmFyIGxvb2t1cCA9IHRoaXMuZ2V0TG9va3VwTWV0aG9kKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSk7XG4gICAgICAgICAgICB2YXIgc3Vic3RpdHV0aW9uID0gKHZvaWQgMCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHN1YnN0VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJzExJzpcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbG9va3VwKGNvbnRleHRQYXJhbXMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDExLCB0YWc6IHF1ZXJ5LnRhZywgc3Vic3RpdHV0aW9uOiBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcxMic6XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAxMiwgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnNjMnOlxuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YnN0aXR1dGlvbikgJiYgc3Vic3RpdHV0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5zcGxpY2UoY3VycmVudEluZGV4LCAxLCBuZXcgU3Vic3RpdHV0aW9uQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogNjMsIHRhZzogcXVlcnkudGFnLCBzdWJzdGl0dXRpb246IHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzQxJzpcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbG9va3VwKGNvbnRleHRQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiA0MSwgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnMjEnOlxuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5zcGxpY2UoY3VycmVudEluZGV4LCAxLCBuZXcgU3Vic3RpdHV0aW9uQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogMjEsIHRhZzogcXVlcnkudGFnLCBzdWJzdGl0dXRpb246IHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKHN1YnN0aXR1dGlvbnMsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJzdGl0dXRpb24pICYmICFzdWJzdGl0dXRpb24ubGVuZ3RoKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzdGl0dXRpb25zLmxlbmd0aCA/IHN1YnN0aXR1dGlvbnMgOiBudWxsO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBmb250IHN1cHBvcnRzIGEgc3BlY2lmaWMgZmVhdHVyZXNcbiAqIEBwYXJhbSB7RlF1ZXJ5fSBxdWVyeSBmZWF0dXJlIHF1ZXJ5IG9iamVjdFxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgaWYgKCFxdWVyeS5zY3JpcHQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgdGhpcy5nZXRTY3JpcHRGZWF0dXJlcyhxdWVyeS5zY3JpcHQpO1xuICAgIHZhciBzdXBwb3J0ZWRTY3JpcHQgPSB0aGlzLmZlYXR1cmVzLmhhc093blByb3BlcnR5KHF1ZXJ5LnNjcmlwdCk7XG4gICAgaWYgKCFxdWVyeS50YWcpIHsgcmV0dXJuIHN1cHBvcnRlZFNjcmlwdDsgfVxuICAgIHZhciBzdXBwb3J0ZWRGZWF0dXJlID0gKFxuICAgICAgICB0aGlzLmZlYXR1cmVzW3F1ZXJ5LnNjcmlwdF0uc29tZShmdW5jdGlvbiAoZmVhdHVyZSkgeyByZXR1cm4gZmVhdHVyZS50YWcgPT09IHF1ZXJ5LnRhZzsgfSlcbiAgICApO1xuICAgIHJldHVybiBzdXBwb3J0ZWRTY3JpcHQgJiYgc3VwcG9ydGVkRmVhdHVyZTtcbn07XG5cbi8qKlxuICogR2V0IGxvb2t1cCB0YWJsZSBzdWJ0YWJsZXNcbiAqIEBwYXJhbSB7YW55fSBsb29rdXBUYWJsZSBsb29rdXAgdGFibGVcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRMb29rdXBTdWJ0YWJsZXMgPSBmdW5jdGlvbiAobG9va3VwVGFibGUpIHtcbiAgICByZXR1cm4gbG9va3VwVGFibGUuc3VidGFibGVzIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEdldCBsb29rdXAgdGFibGUgYnkgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBsb29rdXAgdGFibGUgaW5kZXhcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRMb29rdXBCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGxvb2t1cHMgPSB0aGlzLmZvbnQudGFibGVzLmdzdWIubG9va3VwcztcbiAgICByZXR1cm4gbG9va3Vwc1tpbmRleF0gfHwgbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IGxvb2t1cCB0YWJsZXMgZm9yIGEgZmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmVcbiAqL1xuRmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRGZWF0dXJlTG9va3VwcyA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgLy8gVE9ETzogbWVtb2l6ZVxuICAgIHJldHVybiBmZWF0dXJlLmxvb2t1cExpc3RJbmRleGVzLm1hcCh0aGlzLmdldExvb2t1cEJ5SW5kZXguYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIFF1ZXJ5IGEgZmVhdHVyZSBieSBpdCdzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7YW55fSBxdWVyeSBhbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgYSBxdWVyeVxuICovXG5GZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldEZlYXR1cmUgPSBmdW5jdGlvbiBnZXRGZWF0dXJlKHF1ZXJ5KSB7XG4gICAgaWYgKCF0aGlzLmZvbnQpIHsgcmV0dXJuIHsgRkFJTDogXCJObyBmb250IHdhcyBmb3VuZFwifTsgfVxuICAgIGlmICghdGhpcy5mZWF0dXJlcy5oYXNPd25Qcm9wZXJ0eShxdWVyeS5zY3JpcHQpKSB7XG4gICAgICAgIHRoaXMuZ2V0U2NyaXB0RmVhdHVyZXMocXVlcnkuc2NyaXB0KTtcbiAgICB9XG4gICAgdmFyIHNjcmlwdEZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc1txdWVyeS5zY3JpcHRdO1xuICAgIGlmICghc2NyaXB0RmVhdHVyZXMpIHsgcmV0dXJuIChcbiAgICAgICAgeyBGQUlMOiAoXCJObyBmZWF0dXJlIGZvciBzY3JpcHQgXCIgKyAocXVlcnkuc2NyaXB0KSl9XG4gICAgKTsgfVxuICAgIGlmICghc2NyaXB0RmVhdHVyZXMudGFnc1txdWVyeS50YWddKSB7IHJldHVybiBudWxsOyB9XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNbcXVlcnkuc2NyaXB0XS50YWdzW3F1ZXJ5LnRhZ107XG59O1xuXG4vKipcbiAqIEFyYWJpYyB3b3JkIGNvbnRleHQgY2hlY2tlcnNcbiAqL1xuXG5mdW5jdGlvbiBhcmFiaWNXb3JkU3RhcnRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIGNoYXIgPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG4gICAgdmFyIHByZXZDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoLTEpO1xuICAgIHJldHVybiAoXG4gICAgICAgIC8vID8gYXJhYmljIGZpcnN0IGNoYXJcbiAgICAgICAgKHByZXZDaGFyID09PSBudWxsICYmIGlzQXJhYmljQ2hhcihjaGFyKSkgfHxcbiAgICAgICAgLy8gPyBhcmFiaWMgY2hhciBwcmVjZWRlZCB3aXRoIGEgbm9uIGFyYWJpYyBjaGFyXG4gICAgICAgICghaXNBcmFiaWNDaGFyKHByZXZDaGFyKSAmJiBpc0FyYWJpY0NoYXIoY2hhcikpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gYXJhYmljV29yZEVuZENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgbmV4dENoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgxKTtcbiAgICByZXR1cm4gKFxuICAgICAgICAvLyA/IGxhc3QgYXJhYmljIGNoYXJcbiAgICAgICAgKG5leHRDaGFyID09PSBudWxsKSB8fFxuICAgICAgICAvLyA/IG5leHQgY2hhciBpcyBub3QgYXJhYmljXG4gICAgICAgICghaXNBcmFiaWNDaGFyKG5leHRDaGFyKSlcbiAgICApO1xufVxuXG52YXIgYXJhYmljV29yZENoZWNrID0ge1xuICAgIHN0YXJ0Q2hlY2s6IGFyYWJpY1dvcmRTdGFydENoZWNrLFxuICAgIGVuZENoZWNrOiBhcmFiaWNXb3JkRW5kQ2hlY2tcbn07XG5cbi8qKlxuICogQXJhYmljIHNlbnRlbmNlIGNvbnRleHQgY2hlY2tlcnNcbiAqL1xuXG5mdW5jdGlvbiBhcmFiaWNTZW50ZW5jZVN0YXJ0Q2hlY2soY29udGV4dFBhcmFtcykge1xuICAgIHZhciBjaGFyID0gY29udGV4dFBhcmFtcy5jdXJyZW50O1xuICAgIHZhciBwcmV2Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KC0xKTtcbiAgICByZXR1cm4gKFxuICAgICAgICAvLyA/IGFuIGFyYWJpYyBjaGFyIHByZWNlZGVkIHdpdGggYSBub24gYXJhYmljIGNoYXJcbiAgICAgICAgKGlzQXJhYmljQ2hhcihjaGFyKSB8fCBpc1Rhc2hrZWVsQXJhYmljQ2hhcihjaGFyKSkgJiZcbiAgICAgICAgIWlzQXJhYmljQ2hhcihwcmV2Q2hhcilcbiAgICApO1xufVxuXG5mdW5jdGlvbiBhcmFiaWNTZW50ZW5jZUVuZENoZWNrKGNvbnRleHRQYXJhbXMpIHtcbiAgICB2YXIgbmV4dENoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgxKTtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSBuZXh0Q2hhciA9PT0gbnVsbDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICghaXNBcmFiaWNDaGFyKG5leHRDaGFyKSAmJiAhaXNUYXNoa2VlbEFyYWJpY0NoYXIobmV4dENoYXIpKTpcbiAgICAgICAgICAgIHZhciBuZXh0SXNXaGl0ZXNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcbiAgICAgICAgICAgIGlmICghbmV4dElzV2hpdGVzcGFjZSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKG5leHRJc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJhYmljQ2hhckFoZWFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYXJhYmljQ2hhckFoZWFkID0gKFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0UGFyYW1zLmxvb2thaGVhZC5zb21lKFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGlzQXJhYmljQ2hhcihjKSB8fCBpc1Rhc2hrZWVsQXJhYmljQ2hhcihjKTsgfVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFyYWJpY0NoYXJBaGVhZCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG52YXIgYXJhYmljU2VudGVuY2VDaGVjayA9IHtcbiAgICBzdGFydENoZWNrOiBhcmFiaWNTZW50ZW5jZVN0YXJ0Q2hlY2ssXG4gICAgZW5kQ2hlY2s6IGFyYWJpY1NlbnRlbmNlRW5kQ2hlY2tcbn07XG5cbi8qKlxuICogQXBwbHkgc2luZ2xlIHN1YnN0aXR1dGlvbiBmb3JtYXQgMVxuICogQHBhcmFtIHtBcnJheX0gc3Vic3RpdHV0aW9ucyBzdWJzdGl0dXRpb25zXG4gKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuICovXG5mdW5jdGlvbiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQxJDEoYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG4gICAgdG9rZW5zW2luZGV4XS5zZXRTdGF0ZShhY3Rpb24udGFnLCBhY3Rpb24uc3Vic3RpdHV0aW9uKTtcbn1cblxuLyoqXG4gKiBBcHBseSBzaW5nbGUgc3Vic3RpdHV0aW9uIGZvcm1hdCAyXG4gKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKi9cbmZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDIkMShhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcbiAgICB0b2tlbnNbaW5kZXhdLnNldFN0YXRlKGFjdGlvbi50YWcsIGFjdGlvbi5zdWJzdGl0dXRpb24pO1xufVxuXG4vKipcbiAqIEFwcGx5IGNoYWluaW5nIGNvbnRleHQgc3Vic3RpdHV0aW9uIGZvcm1hdCAzXG4gKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGNoYWluaW5nU3Vic3RpdHV0aW9uRm9ybWF0MyQxKGFjdGlvbiwgdG9rZW5zLCBpbmRleCkge1xuICAgIGFjdGlvbi5zdWJzdGl0dXRpb24uZm9yRWFjaChmdW5jdGlvbiAoc3Vic3QsIG9mZnNldCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaW5kZXggKyBvZmZzZXRdO1xuICAgICAgICB0b2tlbi5zZXRTdGF0ZShhY3Rpb24udGFnLCBzdWJzdCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQXBwbHkgbGlnYXR1cmUgc3Vic3RpdHV0aW9uIGZvcm1hdCAxXG4gKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGxpZ2F0dXJlU3Vic3RpdHV0aW9uRm9ybWF0MSQxKGFjdGlvbiwgdG9rZW5zLCBpbmRleCkge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpbmRleF07XG4gICAgdG9rZW4uc2V0U3RhdGUoYWN0aW9uLnRhZywgYWN0aW9uLnN1YnN0aXR1dGlvbi5saWdHbHlwaCk7XG4gICAgdmFyIGNvbXBzQ291bnQgPSBhY3Rpb24uc3Vic3RpdHV0aW9uLmNvbXBvbmVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcHNDb3VudDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2luZGV4ICsgaSArIDFdO1xuICAgICAgICB0b2tlbi5zZXRTdGF0ZSgnZGVsZXRlZCcsIHRydWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdXBwb3J0ZWQgc3Vic3RpdHV0aW9uc1xuICovXG52YXIgU1VCU1RJVFVUSU9OUyA9IHtcbiAgICAxMTogc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MSQxLFxuICAgIDEyOiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQyJDEsXG4gICAgNjM6IGNoYWluaW5nU3Vic3RpdHV0aW9uRm9ybWF0MyQxLFxuICAgIDQxOiBsaWdhdHVyZVN1YnN0aXR1dGlvbkZvcm1hdDEkMVxufTtcblxuLyoqXG4gKiBBcHBseSBzdWJzdGl0dXRpb25zIHRvIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdWJzdGl0dXRpb24oYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG4gICAgaWYgKGFjdGlvbiBpbnN0YW5jZW9mIFN1YnN0aXR1dGlvbkFjdGlvbiAmJiBTVUJTVElUVVRJT05TW2FjdGlvbi5pZF0pIHtcbiAgICAgICAgU1VCU1RJVFVUSU9OU1thY3Rpb24uaWRdKGFjdGlvbiwgdG9rZW5zLCBpbmRleCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFwcGx5IEFyYWJpYyBwcmVzZW50YXRpb24gZm9ybXMgdG8gYSByYW5nZSBvZiB0b2tlbnNcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBjYW4gYmUgY29ubmVjdGVkIHRvIGl0J3MgcHJlY2VkaW5nIGNoYXJcbiAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY2hhckNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgb2YgYSBjaGFyXG4gKi9cbmZ1bmN0aW9uIHdpbGxDb25uZWN0UHJldihjaGFyQ29udGV4dFBhcmFtcykge1xuICAgIHZhciBiYWNrdHJhY2sgPSBbXS5jb25jYXQoY2hhckNvbnRleHRQYXJhbXMuYmFja3RyYWNrKTtcbiAgICBmb3IgKHZhciBpID0gYmFja3RyYWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBwcmV2Q2hhciA9IGJhY2t0cmFja1tpXTtcbiAgICAgICAgdmFyIGlzb2xhdGVkID0gaXNJc29sYXRlZEFyYWJpY0NoYXIocHJldkNoYXIpO1xuICAgICAgICB2YXIgdGFzaGtlZWwgPSBpc1Rhc2hrZWVsQXJhYmljQ2hhcihwcmV2Q2hhcik7XG4gICAgICAgIGlmICghaXNvbGF0ZWQgJiYgIXRhc2hrZWVsKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgIGlmIChpc29sYXRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhciBjYW4gYmUgY29ubmVjdGVkIHRvIGl0J3MgcHJvY2VlZGluZyBjaGFyXG4gKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNoYXJDb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIG9mIGEgY2hhclxuICovXG5mdW5jdGlvbiB3aWxsQ29ubmVjdE5leHQoY2hhckNvbnRleHRQYXJhbXMpIHtcbiAgICBpZiAoaXNJc29sYXRlZEFyYWJpY0NoYXIoY2hhckNvbnRleHRQYXJhbXMuY3VycmVudCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyQ29udGV4dFBhcmFtcy5sb29rYWhlYWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5leHRDaGFyID0gY2hhckNvbnRleHRQYXJhbXMubG9va2FoZWFkW2ldO1xuICAgICAgICB2YXIgdGFzaGtlZWwgPSBpc1Rhc2hrZWVsQXJhYmljQ2hhcihuZXh0Q2hhcik7XG4gICAgICAgIGlmICghdGFzaGtlZWwpIHsgcmV0dXJuIHRydWU7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEFwcGx5IGFyYWJpYyBwcmVzZW50YXRpb24gZm9ybXMgdG8gYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtDb250ZXh0UmFuZ2V9IHJhbmdlIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGFyYWJpY1ByZXNlbnRhdGlvbkZvcm1zKHJhbmdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2NyaXB0ID0gJ2FyYWInO1xuICAgIHZhciB0YWdzID0gdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XTtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbml6ZXIuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7IHJldHVybjsgfVxuICAgIHZhciBjb250ZXh0UGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoXG4gICAgICAgIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5nZXRTdGF0ZSgnZ2x5cGhJbmRleCcpOyB9XG4gICAgKSwgMCk7XG4gICAgdmFyIGNoYXJDb250ZXh0UGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoXG4gICAgICAgIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5jaGFyOyB9XG4gICAgKSwgMCk7XG4gICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuLCBpbmRleCkge1xuICAgICAgICBpZiAoaXNUYXNoa2VlbEFyYWJpY0NoYXIodG9rZW4uY2hhcikpIHsgcmV0dXJuOyB9XG4gICAgICAgIGNvbnRleHRQYXJhbXMuc2V0Q3VycmVudEluZGV4KGluZGV4KTtcbiAgICAgICAgY2hhckNvbnRleHRQYXJhbXMuc2V0Q3VycmVudEluZGV4KGluZGV4KTtcbiAgICAgICAgdmFyIENPTk5FQ1QgPSAwOyAvLyAyIGJpdHMgMDAgKDEwOiBjYW4gY29ubmVjdCBuZXh0KSAoMDE6IGNhbiBjb25uZWN0IHByZXYpXG4gICAgICAgIGlmICh3aWxsQ29ubmVjdFByZXYoY2hhckNvbnRleHRQYXJhbXMpKSB7IENPTk5FQ1QgfD0gMTsgfVxuICAgICAgICBpZiAod2lsbENvbm5lY3ROZXh0KGNoYXJDb250ZXh0UGFyYW1zKSkgeyBDT05ORUNUIHw9IDI7IH1cbiAgICAgICAgdmFyIHRhZztcbiAgICAgICAgc3dpdGNoIChDT05ORUNUKSB7XG4gICAgICAgICAgICBjYXNlIDE6ICh0YWcgPSAnZmluYScpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjogKHRhZyA9ICdpbml0Jyk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOiAodGFnID0gJ21lZGknKTsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZ3MuaW5kZXhPZih0YWcpID09PSAtMSkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIHN1YnN0aXR1dGlvbnMgPSB0aGlzJDEucXVlcnkubG9va3VwRmVhdHVyZSh7XG4gICAgICAgICAgICB0YWc6IHRhZywgc2NyaXB0OiBzY3JpcHQsIGNvbnRleHRQYXJhbXM6IGNvbnRleHRQYXJhbXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdWJzdGl0dXRpb25zIGluc3RhbmNlb2YgRXJyb3IpIHsgcmV0dXJuIGNvbnNvbGUuaW5mbyhzdWJzdGl0dXRpb25zLm1lc3NhZ2UpOyB9XG4gICAgICAgIHN1YnN0aXR1dGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGFjdGlvbiBpbnN0YW5jZW9mIFN1YnN0aXR1dGlvbkFjdGlvbikge1xuICAgICAgICAgICAgICAgIGFwcGx5U3Vic3RpdHV0aW9uKGFjdGlvbiwgdG9rZW5zLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29udGV4dFBhcmFtcy5jb250ZXh0W2luZGV4XSA9IGFjdGlvbi5zdWJzdGl0dXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFwcGx5IEFyYWJpYyByZXF1aXJlZCBsaWdhdHVyZXMgZmVhdHVyZSB0byBhIHJhbmdlIG9mIHRva2Vuc1xuICovXG5cbi8qKlxuICogVXBkYXRlIGNvbnRleHQgcGFyYW1zXG4gKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBjdXJyZW50IGl0ZW0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dFBhcmFtcyh0b2tlbnMsIGluZGV4KSB7XG4gICAgdmFyIGNvbnRleHQgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uYWN0aXZlU3RhdGUudmFsdWU7IH0pO1xuICAgIHJldHVybiBuZXcgQ29udGV4dFBhcmFtcyhjb250ZXh0LCBpbmRleCB8fCAwKTtcbn1cblxuLyoqXG4gKiBBcHBseSBBcmFiaWMgcmVxdWlyZWQgbGlnYXR1cmVzIHRvIGEgY29udGV4dCByYW5nZVxuICogQHBhcmFtIHtDb250ZXh0UmFuZ2V9IHJhbmdlIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGFyYWJpY1JlcXVpcmVkTGlnYXR1cmVzKHJhbmdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2NyaXB0ID0gJ2FyYWInO1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2VuaXplci5nZXRSYW5nZVRva2VucyhyYW5nZSk7XG4gICAgdmFyIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zKHRva2Vucyk7XG4gICAgY29udGV4dFBhcmFtcy5jb250ZXh0LmZvckVhY2goZnVuY3Rpb24gKGdseXBoSW5kZXgsIGluZGV4KSB7XG4gICAgICAgIGNvbnRleHRQYXJhbXMuc2V0Q3VycmVudEluZGV4KGluZGV4KTtcbiAgICAgICAgdmFyIHN1YnN0aXR1dGlvbnMgPSB0aGlzJDEucXVlcnkubG9va3VwRmVhdHVyZSh7XG4gICAgICAgICAgICB0YWc6ICdybGlnJywgc2NyaXB0OiBzY3JpcHQsIGNvbnRleHRQYXJhbXM6IGNvbnRleHRQYXJhbXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdWJzdGl0dXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFwcGx5U3Vic3RpdHV0aW9uKGFjdGlvbiwgdG9rZW5zLCBpbmRleCk7IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250ZXh0UGFyYW1zID0gZ2V0Q29udGV4dFBhcmFtcyh0b2tlbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogTGF0aW4gd29yZCBjb250ZXh0IGNoZWNrZXJzXG4gKi9cblxuZnVuY3Rpb24gbGF0aW5Xb3JkU3RhcnRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG4gICAgdmFyIGNoYXIgPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG4gICAgdmFyIHByZXZDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoLTEpO1xuICAgIHJldHVybiAoXG4gICAgICAgIC8vID8gbGF0aW4gZmlyc3QgY2hhclxuICAgICAgICAocHJldkNoYXIgPT09IG51bGwgJiYgaXNMYXRpbkNoYXIoY2hhcikpIHx8XG4gICAgICAgIC8vID8gbGF0aW4gY2hhciBwcmVjZWRlZCB3aXRoIGEgbm9uIGxhdGluIGNoYXJcbiAgICAgICAgKCFpc0xhdGluQ2hhcihwcmV2Q2hhcikgJiYgaXNMYXRpbkNoYXIoY2hhcikpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbGF0aW5Xb3JkRW5kQ2hlY2soY29udGV4dFBhcmFtcykge1xuICAgIHZhciBuZXh0Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KDEpO1xuICAgIHJldHVybiAoXG4gICAgICAgIC8vID8gbGFzdCBsYXRpbiBjaGFyXG4gICAgICAgIChuZXh0Q2hhciA9PT0gbnVsbCkgfHxcbiAgICAgICAgLy8gPyBuZXh0IGNoYXIgaXMgbm90IGxhdGluXG4gICAgICAgICghaXNMYXRpbkNoYXIobmV4dENoYXIpKVxuICAgICk7XG59XG5cbnZhciBsYXRpbldvcmRDaGVjayA9IHtcbiAgICBzdGFydENoZWNrOiBsYXRpbldvcmRTdGFydENoZWNrLFxuICAgIGVuZENoZWNrOiBsYXRpbldvcmRFbmRDaGVja1xufTtcblxuLyoqXG4gKiBBcHBseSBMYXRpbiBsaWdhdHVyZSBmZWF0dXJlIHRvIGEgcmFuZ2Ugb2YgdG9rZW5zXG4gKi9cblxuLyoqXG4gKiBVcGRhdGUgY29udGV4dCBwYXJhbXNcbiAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0UGFyYW1zJDEodG9rZW5zLCBpbmRleCkge1xuICAgIHZhciBjb250ZXh0ID0gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuLmFjdGl2ZVN0YXRlLnZhbHVlOyB9KTtcbiAgICByZXR1cm4gbmV3IENvbnRleHRQYXJhbXMoY29udGV4dCwgaW5kZXggfHwgMCk7XG59XG5cbi8qKlxuICogQXBwbHkgQXJhYmljIHJlcXVpcmVkIGxpZ2F0dXJlcyB0byBhIGNvbnRleHQgcmFuZ2VcbiAqIEBwYXJhbSB7Q29udGV4dFJhbmdlfSByYW5nZSBhIHJhbmdlIG9mIHRva2Vuc1xuICovXG5mdW5jdGlvbiBsYXRpbkxpZ2F0dXJlKHJhbmdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2NyaXB0ID0gJ2xhdG4nO1xuICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2VuaXplci5nZXRSYW5nZVRva2VucyhyYW5nZSk7XG4gICAgdmFyIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zJDEodG9rZW5zKTtcbiAgICBjb250ZXh0UGFyYW1zLmNvbnRleHQuZm9yRWFjaChmdW5jdGlvbiAoZ2x5cGhJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgY29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IHRoaXMkMS5xdWVyeS5sb29rdXBGZWF0dXJlKHtcbiAgICAgICAgICAgIHRhZzogJ2xpZ2EnLCBzY3JpcHQ6IHNjcmlwdCwgY29udGV4dFBhcmFtczogY29udGV4dFBhcmFtc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1YnN0aXR1dGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdWJzdGl0dXRpb25zLmZvckVhY2goXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gYXBwbHlTdWJzdGl0dXRpb24oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTsgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zJDEodG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEluZmVyIGJpZGlyZWN0aW9uYWwgcHJvcGVydGllcyBmb3IgYSBnaXZlbiB0ZXh0IGFuZCBhcHBseVxuICogdGhlIGNvcnJlc3BvbmRpbmcgbGF5b3V0IHJ1bGVzLlxuICovXG5cbi8qKlxuICogQ3JlYXRlIEJpZGkuIGZlYXR1cmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZURpciB0ZXh0IGJhc2UgZGlyZWN0aW9uLiB2YWx1ZSBlaXRoZXIgJ2x0cicgb3IgJ3J0bCdcbiAqL1xuZnVuY3Rpb24gQmlkaShiYXNlRGlyKSB7XG4gICAgdGhpcy5iYXNlRGlyID0gYmFzZURpciB8fCAnbHRyJztcbiAgICB0aGlzLnRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoKTtcbiAgICB0aGlzLmZlYXR1cmVzVGFncyA9IHt9O1xufVxuXG4vKipcbiAqIFNldHMgQmlkaSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBhIHRleHQgaW5wdXRcbiAqL1xuQmlkaS5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbn07XG5cbi8qKlxuICogU3RvcmUgZXNzZW50aWFsIGNvbnRleHQgY2hlY2tzOlxuICogYXJhYmljIHdvcmQgY2hlY2sgZm9yIGFwcGx5aW5nIGdzdWIgZmVhdHVyZXNcbiAqIGFyYWJpYyBzZW50ZW5jZSBjaGVjayBmb3IgYWRqdXN0aW5nIGFyYWJpYyBsYXlvdXRcbiAqL1xuQmlkaS5wcm90b3R5cGUuY29udGV4dENoZWNrcyA9ICh7XG4gICAgbGF0aW5Xb3JkQ2hlY2s6IGxhdGluV29yZENoZWNrLFxuICAgIGFyYWJpY1dvcmRDaGVjazogYXJhYmljV29yZENoZWNrLFxuICAgIGFyYWJpY1NlbnRlbmNlQ2hlY2s6IGFyYWJpY1NlbnRlbmNlQ2hlY2tcbn0pO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGFyYWJpYyB3b3JkIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29udGV4dENoZWNrZXIoY2hlY2tJZCkge1xuICAgIHZhciBjaGVjayA9IHRoaXMuY29udGV4dENoZWNrc1soY2hlY2tJZCArIFwiQ2hlY2tcIildO1xuICAgIHJldHVybiB0aGlzLnRva2VuaXplci5yZWdpc3RlckNvbnRleHRDaGVja2VyKFxuICAgICAgICBjaGVja0lkLCBjaGVjay5zdGFydENoZWNrLCBjaGVjay5lbmRDaGVja1xuICAgICk7XG59XG5cbi8qKlxuICogUGVyZm9ybSBwcmUgdG9rZW5pemF0aW9uIHByb2NlZHVyZSB0aGVuXG4gKiB0b2tlbml6ZSB0ZXh0IGlucHV0XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplVGV4dCgpIHtcbiAgICByZWdpc3RlckNvbnRleHRDaGVja2VyLmNhbGwodGhpcywgJ2xhdGluV29yZCcpO1xuICAgIHJlZ2lzdGVyQ29udGV4dENoZWNrZXIuY2FsbCh0aGlzLCAnYXJhYmljV29yZCcpO1xuICAgIHJlZ2lzdGVyQ29udGV4dENoZWNrZXIuY2FsbCh0aGlzLCAnYXJhYmljU2VudGVuY2UnKTtcbiAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIudG9rZW5pemUodGhpcy50ZXh0KTtcbn1cblxuLyoqXG4gKiBSZXZlcnNlIGFyYWJpYyBzZW50ZW5jZSBsYXlvdXRcbiAqIFRPRE86IGNoZWNrIGJhc2UgZGlyIGJlZm9yZSBhcHBseWluZyBhZGp1c3RtZW50cyAtIHByaW9yaXR5IGxvd1xuICovXG5mdW5jdGlvbiByZXZlcnNlQXJhYmljU2VudGVuY2VzKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2FyYWJpY1NlbnRlbmNlJyk7XG4gICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciByYW5nZVRva2VucyA9IHRoaXMkMS50b2tlbml6ZXIuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpO1xuICAgICAgICB0aGlzJDEudG9rZW5pemVyLnJlcGxhY2VSYW5nZShcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0SW5kZXgsXG4gICAgICAgICAgICByYW5nZS5lbmRPZmZzZXQsXG4gICAgICAgICAgICByYW5nZVRva2Vucy5yZXZlcnNlKClcbiAgICAgICAgKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlciBzdXBwb3J0ZWQgZmVhdHVyZXMgdGFnc1xuICogQHBhcmFtIHtzY3JpcHR9IHNjcmlwdCBzY3JpcHQgdGFnXG4gKiBAcGFyYW0ge0FycmF5fSB0YWdzIGZlYXR1cmVzIHRhZ3MgbGlzdFxuICovXG5CaWRpLnByb3RvdHlwZS5yZWdpc3RlckZlYXR1cmVzID0gZnVuY3Rpb24gKHNjcmlwdCwgdGFncykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHN1cHBvcnRlZFRhZ3MgPSB0YWdzLmZpbHRlcihcbiAgICAgICAgZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGhpcyQxLnF1ZXJ5LnN1cHBvcnRzKHtzY3JpcHQ6IHNjcmlwdCwgdGFnOiB0YWd9KTsgfVxuICAgICk7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzVGFncy5oYXNPd25Qcm9wZXJ0eShzY3JpcHQpKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF0gPSBzdXBwb3J0ZWRUYWdzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF0gPVxuICAgICAgICB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdLmNvbmNhdChzdXBwb3J0ZWRUYWdzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFwcGx5IEdTVUIgZmVhdHVyZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHRhZ3NMaXN0IGEgbGlzdCBvZiBmZWF0dXJlcyB0YWdzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0IGEgc2NyaXB0IHRhZ1xuICogQHBhcmFtIHtGb250fSBmb250IG9wZW50eXBlIGZvbnQgaW5zdGFuY2VcbiAqL1xuQmlkaS5wcm90b3R5cGUuYXBwbHlGZWF0dXJlcyA9IGZ1bmN0aW9uIChmb250LCBmZWF0dXJlcykge1xuICAgIGlmICghZm9udCkgeyB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdObyB2YWxpZCBmb250IHdhcyBwcm92aWRlZCB0byBhcHBseSBmZWF0dXJlcydcbiAgICApOyB9XG4gICAgaWYgKCF0aGlzLnF1ZXJ5KSB7IHRoaXMucXVlcnkgPSBuZXcgRmVhdHVyZVF1ZXJ5KGZvbnQpOyB9XG4gICAgZm9yICh2YXIgZiA9IDA7IGYgPCBmZWF0dXJlcy5sZW5ndGg7IGYrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ZdO1xuICAgICAgICBpZiAoIXRoaXMucXVlcnkuc3VwcG9ydHMoe3NjcmlwdDogZmVhdHVyZS5zY3JpcHR9KSkgeyBjb250aW51ZTsgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZXMoZmVhdHVyZS5zY3JpcHQsIGZlYXR1cmUudGFncyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHN0YXRlIG1vZGlmaWVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kaWZpZXJJZCBzdGF0ZSBtb2RpZmllciBpZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uZGl0aW9uIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9yIGZhbHNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb2RpZmllciBhIG1vZGlmaWVyIGZ1bmN0aW9uIHRvIHNldCB0b2tlbiBzdGF0ZVxuICovXG5CaWRpLnByb3RvdHlwZS5yZWdpc3Rlck1vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVySWQsIGNvbmRpdGlvbiwgbW9kaWZpZXIpIHtcbiAgICB0aGlzLnRva2VuaXplci5yZWdpc3Rlck1vZGlmaWVyKG1vZGlmaWVySWQsIGNvbmRpdGlvbiwgbW9kaWZpZXIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiAnZ2x5cGhJbmRleCcgaXMgcmVnaXN0ZXJlZFxuICovXG5mdW5jdGlvbiBjaGVja0dseXBoSW5kZXhTdGF0dXMoKSB7XG4gICAgaWYgKHRoaXMudG9rZW5pemVyLnJlZ2lzdGVyZWRNb2RpZmllcnMuaW5kZXhPZignZ2x5cGhJbmRleCcpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnZ2x5cGhJbmRleCBtb2RpZmllciBpcyByZXF1aXJlZCB0byBhcHBseSAnICtcbiAgICAgICAgICAgICdhcmFiaWMgcHJlc2VudGF0aW9uIGZlYXR1cmVzLidcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogQXBwbHkgYXJhYmljIHByZXNlbnRhdGlvbiBmb3JtcyBmZWF0dXJlc1xuICovXG5mdW5jdGlvbiBhcHBseUFyYWJpY1ByZXNlbnRhdGlvbkZvcm1zKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNjcmlwdCA9ICdhcmFiJztcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNUYWdzLmhhc093blByb3BlcnR5KHNjcmlwdCkpIHsgcmV0dXJuOyB9XG4gICAgY2hlY2tHbHlwaEluZGV4U3RhdHVzLmNhbGwodGhpcyk7XG4gICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2FyYWJpY1dvcmQnKTtcbiAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgYXJhYmljUHJlc2VudGF0aW9uRm9ybXMuY2FsbCh0aGlzJDEsIHJhbmdlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseSByZXF1aXJlZCBhcmFiaWMgbGlnYXR1cmVzXG4gKi9cbmZ1bmN0aW9uIGFwcGx5QXJhYmljUmVxdWlyZUxpZ2F0dXJlcygpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzY3JpcHQgPSAnYXJhYic7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzVGFncy5oYXNPd25Qcm9wZXJ0eShzY3JpcHQpKSB7IHJldHVybjsgfVxuICAgIHZhciB0YWdzID0gdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XTtcbiAgICBpZiAodGFncy5pbmRleE9mKCdybGlnJykgPT09IC0xKSB7IHJldHVybjsgfVxuICAgIGNoZWNrR2x5cGhJbmRleFN0YXR1cy5jYWxsKHRoaXMpO1xuICAgIHZhciByYW5nZXMgPSB0aGlzLnRva2VuaXplci5nZXRDb250ZXh0UmFuZ2VzKCdhcmFiaWNXb3JkJyk7XG4gICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIGFyYWJpY1JlcXVpcmVkTGlnYXR1cmVzLmNhbGwodGhpcyQxLCByYW5nZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQXBwbHkgcmVxdWlyZWQgYXJhYmljIGxpZ2F0dXJlc1xuICovXG5mdW5jdGlvbiBhcHBseUxhdGluTGlnYXR1cmVzKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNjcmlwdCA9ICdsYXRuJztcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNUYWdzLmhhc093blByb3BlcnR5KHNjcmlwdCkpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHRhZ3MgPSB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdO1xuICAgIGlmICh0YWdzLmluZGV4T2YoJ2xpZ2EnKSA9PT0gLTEpIHsgcmV0dXJuOyB9XG4gICAgY2hlY2tHbHlwaEluZGV4U3RhdHVzLmNhbGwodGhpcyk7XG4gICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2xhdGluV29yZCcpO1xuICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBsYXRpbkxpZ2F0dXJlLmNhbGwodGhpcyQxLCByYW5nZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjb250ZXh0IGlzIHJlZ2lzdGVyZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0SWQgY29udGV4dCBpZFxuICovXG5CaWRpLnByb3RvdHlwZS5jaGVja0NvbnRleHRSZWFkeSA9IGZ1bmN0aW9uIChjb250ZXh0SWQpIHtcbiAgICByZXR1cm4gISF0aGlzLnRva2VuaXplci5nZXRDb250ZXh0KGNvbnRleHRJZCk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGZlYXR1cmVzIHRvIHJlZ2lzdGVyZWQgY29udGV4dHNcbiAqL1xuQmlkaS5wcm90b3R5cGUuYXBwbHlGZWF0dXJlc1RvQ29udGV4dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY2hlY2tDb250ZXh0UmVhZHkoJ2FyYWJpY1dvcmQnKSkge1xuICAgICAgICBhcHBseUFyYWJpY1ByZXNlbnRhdGlvbkZvcm1zLmNhbGwodGhpcyk7XG4gICAgICAgIGFwcGx5QXJhYmljUmVxdWlyZUxpZ2F0dXJlcy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGVja0NvbnRleHRSZWFkeSgnbGF0aW5Xb3JkJykpIHtcbiAgICAgICAgYXBwbHlMYXRpbkxpZ2F0dXJlcy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGVja0NvbnRleHRSZWFkeSgnYXJhYmljU2VudGVuY2UnKSkge1xuICAgICAgICByZXZlcnNlQXJhYmljU2VudGVuY2VzLmNhbGwodGhpcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBwcm9jZXNzIHRleHQgaW5wdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGFuIGlucHV0IHRleHRcbiAqL1xuQmlkaS5wcm90b3R5cGUucHJvY2Vzc1RleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgaWYgKCF0aGlzLnRleHQgfHwgdGhpcy50ZXh0ICE9PSB0ZXh0KSB7XG4gICAgICAgIHRoaXMuc2V0VGV4dCh0ZXh0KTtcbiAgICAgICAgdG9rZW5pemVUZXh0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYXBwbHlGZWF0dXJlc1RvQ29udGV4dHMoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgYSBzdHJpbmcgb2YgdGV4dCB0byBpZGVudGlmeSBhbmQgYWRqdXN0XG4gKiBiaWRpcmVjdGlvbmFsIHRleHQgZW50aXRpZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBpbnB1dCB0ZXh0XG4gKi9cbkJpZGkucHJvdG90eXBlLmdldEJpZGlUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB0aGlzLnByb2Nlc3NUZXh0KHRleHQpO1xuICAgIHJldHVybiB0aGlzLnRva2VuaXplci5nZXRUZXh0KCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzdGF0ZSBpbmRleCBvZiBlYWNoIHRva2VuXG4gKiBAcGFyYW0ge3RleHR9IHRleHQgYW4gaW5wdXQgdGV4dFxuICovXG5CaWRpLnByb3RvdHlwZS5nZXRUZXh0R2x5cGhzID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB0aGlzLnByb2Nlc3NUZXh0KHRleHQpO1xuICAgIHZhciBpbmRleGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRva2VuaXplci50b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy50b2tlbml6ZXIudG9rZW5zW2ldO1xuICAgICAgICBpZiAodG9rZW4uc3RhdGUuZGVsZXRlZCkgeyBjb250aW51ZTsgfVxuICAgICAgICB2YXIgaW5kZXggPSB0b2tlbi5hY3RpdmVTdGF0ZS52YWx1ZTtcbiAgICAgICAgaW5kZXhlcy5wdXNoKEFycmF5LmlzQXJyYXkoaW5kZXgpID8gaW5kZXhbMF0gOiBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleGVzO1xufTtcblxuLy8gVGhlIEZvbnQgb2JqZWN0XG5cbi8qKlxuICogQHR5cGVkZWYgRm9udE9wdGlvbnNcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBlbXB0eSAtIHdoZXRoZXIgdG8gY3JlYXRlIGEgbmV3IGVtcHR5IGZvbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmYW1pbHlOYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3R5bGVOYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGZ1bGxOYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZz19IHBvc3RTY3JpcHROYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGRlc2lnbmVyXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGRlc2lnbmVyVVJMXG4gKiBAcHJvcGVydHkge3N0cmluZz19IG1hbnVmYWN0dXJlclxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBtYW51ZmFjdHVyZXJVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbGljZW5zZVxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBsaWNlbnNlVVJMXG4gKiBAcHJvcGVydHkge3N0cmluZz19IHZlcnNpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzY3JpcHRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gY29weXJpZ2h0XG4gKiBAcHJvcGVydHkge3N0cmluZz19IHRyYWRlbWFya1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IHVuaXRzUGVyRW1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhc2NlbmRlclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlc2NlbmRlclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGNyZWF0ZWRUaW1lc3RhbXBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gd2VpZ2h0Q2xhc3NcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gd2lkdGhDbGFzc1xuICogQHByb3BlcnR5IHtzdHJpbmc9fSBmc1NlbGVjdGlvblxuICovXG5cbi8qKlxuICogQSBGb250IHJlcHJlc2VudHMgYSBsb2FkZWQgT3BlblR5cGUgZm9udCBmaWxlLlxuICogSXQgY29udGFpbnMgYSBzZXQgb2YgZ2x5cGhzIGFuZCBtZXRob2RzIHRvIGRyYXcgdGV4dCBvbiBhIGRyYXdpbmcgY29udGV4dCxcbiAqIG9yIHRvIGdldCBhIHBhdGggcmVwcmVzZW50aW5nIHRoZSB0ZXh0LlxuICogQGV4cG9ydHMgb3BlbnR5cGUuRm9udFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0ZvbnRPcHRpb25zfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZvbnQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudGFibGVzID0gb3B0aW9ucy50YWJsZXMgfHwge307XG5cbiAgICBpZiAoIW9wdGlvbnMuZW1wdHkpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSd2ZSBwcm92aWRlZCB0aGUgbWluaW11bSBzZXQgb2YgbmFtZXMuXG4gICAgICAgIGNoZWNrQXJndW1lbnQoXG4gICAgICAgICAgICBvcHRpb25zLmZhbWlseU5hbWUsXG4gICAgICAgICAgICAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgZmFtaWx5TmFtZSBpcyByZXF1aXJlZC4nXG4gICAgICAgICk7XG4gICAgICAgIGNoZWNrQXJndW1lbnQoXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlTmFtZSxcbiAgICAgICAgICAgICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBzdHlsZU5hbWUgaXMgcmVxdWlyZWQuJ1xuICAgICAgICApO1xuICAgICAgICBjaGVja0FyZ3VtZW50KFxuICAgICAgICAgICAgb3B0aW9ucy51bml0c1BlckVtLFxuICAgICAgICAgICAgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIHVuaXRzUGVyRW0gaXMgcmVxdWlyZWQuJ1xuICAgICAgICApO1xuICAgICAgICBjaGVja0FyZ3VtZW50KFxuICAgICAgICAgICAgb3B0aW9ucy5hc2NlbmRlcixcbiAgICAgICAgICAgICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBhc2NlbmRlciBpcyByZXF1aXJlZC4nXG4gICAgICAgICk7XG4gICAgICAgIGNoZWNrQXJndW1lbnQoXG4gICAgICAgICAgICBvcHRpb25zLmRlc2NlbmRlciA8PSAwLFxuICAgICAgICAgICAgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIG5lZ2F0aXZlIGRlc2NlbmRlciB2YWx1ZSBpcyByZXF1aXJlZC4nXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy51bml0c1BlckVtID0gb3B0aW9ucy51bml0c1BlckVtIHx8IDEwMDA7XG4gICAgICAgIHRoaXMuYXNjZW5kZXIgPSBvcHRpb25zLmFzY2VuZGVyO1xuICAgICAgICB0aGlzLmRlc2NlbmRlciA9IG9wdGlvbnMuZGVzY2VuZGVyO1xuICAgICAgICB0aGlzLmNyZWF0ZWRUaW1lc3RhbXAgPSBvcHRpb25zLmNyZWF0ZWRUaW1lc3RhbXA7XG4gICAgICAgIHRoaXMudGFibGVzID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLnRhYmxlcywge1xuICAgICAgICAgICAgb3MyOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdXNXZWlnaHRDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMud2VpZ2h0Q2xhc3MgfHwgdGhpcy51c1dlaWdodENsYXNzZXMuTUVESVVNLFxuICAgICAgICAgICAgICAgICAgICB1c1dpZHRoQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLndpZHRoQ2xhc3MgfHwgdGhpcy51c1dpZHRoQ2xhc3Nlcy5NRURJVU0sXG4gICAgICAgICAgICAgICAgICAgIGZzU2VsZWN0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5mc1NlbGVjdGlvbiB8fCB0aGlzLmZzU2VsZWN0aW9uVmFsdWVzLlJFR1VMQVIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRhYmxlcy5vczJcbiAgICAgICAgICAgICksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc3VwcG9ydGVkID0gdHJ1ZTsgLy8gRGVwcmVjYXRlZDogcGFyc2VCdWZmZXIgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBmb250IGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgdGhpcy5nbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQodGhpcywgb3B0aW9ucy5nbHlwaHMgfHwgW10pO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBuZXcgRGVmYXVsdEVuY29kaW5nKHRoaXMpO1xuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgUG9zaXRpb24odGhpcyk7XG4gICAgdGhpcy5zdWJzdGl0dXRpb24gPSBuZXcgU3Vic3RpdHV0aW9uKHRoaXMpO1xuICAgIHRoaXMudGFibGVzID0gdGhpcy50YWJsZXMgfHwge307XG5cbiAgICAvLyBuZWVkZWQgZm9yIGxvdyBtZW1vcnkgbW9kZSBvbmx5LlxuICAgIHRoaXMuX3B1c2ggPSBudWxsO1xuICAgIHRoaXMuX2htdHhUYWJsZURhdGEgPSB7fTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaGludGluZycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGludGluZykgeyByZXR1cm4gdGhpcy5faGludGluZzsgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3V0bGluZXNGb3JtYXQgPT09ICd0cnVldHlwZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2hpbnRpbmcgPSBuZXcgSGludGluZyh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGZvbnQgaGFzIGEgZ2x5cGggZm9yIHRoZSBnaXZlbiBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Gb250LnByb3RvdHlwZS5oYXNDaGFyID0gZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KGMpICE9PSBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgZ2x5cGggaW5kZXguXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlblxuICogdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRm9udC5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RpbmcuY2hhclRvR2x5cGhJbmRleChzKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHRvIGEgc2luZ2xlIEdseXBoIG9iamVjdC5cbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuXG4gKiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGFuZCBhIGdseXBoOyBmb3IgY29tcGxleCBzY3JpcHRzIHRoaXMgbWlnaHQgbm90IGJlIHRoZSBjYXNlLlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbkZvbnQucHJvdG90eXBlLmNoYXJUb0dseXBoID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgZ2x5cGhJbmRleCA9IHRoaXMuY2hhclRvR2x5cGhJbmRleChjKTtcbiAgICB2YXIgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyAubm90ZGVmXG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbi8qKlxuICogVXBkYXRlIGZlYXR1cmVzXG4gKiBAcGFyYW0ge2FueX0gb3B0aW9ucyBmZWF0dXJlcyBvcHRpb25zXG4gKi9cbkZvbnQucHJvdG90eXBlLnVwZGF0ZUZlYXR1cmVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyBUT0RPOiB1cGRhdGUgYWxsIGZlYXR1cmVzIG9wdGlvbnMgbm90IG9ubHkgJ2xhdG4nLlxuICAgIHJldHVybiB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zLmZlYXR1cmVzLm1hcChmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoZmVhdHVyZS5zY3JpcHQgPT09ICdsYXRuJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQ6ICdsYXRuJyxcbiAgICAgICAgICAgICAgICB0YWdzOiBmZWF0dXJlLnRhZ3MuZmlsdGVyKGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIG9wdGlvbnNbdGFnXTsgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gdGV4dCB0byBhIGxpc3Qgb2YgR2x5cGggb2JqZWN0cy5cbiAqIE5vdGUgdGhhdCB0aGVyZSBpcyBubyBzdHJpY3Qgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW4gY2hhcmFjdGVycyBhbmRcbiAqIGdseXBocywgc28gdGhlIGxpc3Qgb2YgcmV0dXJuZWQgZ2x5cGhzIGNhbiBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGhbXX1cbiAqL1xuRm9udC5wcm90b3R5cGUuc3RyaW5nVG9HbHlwaHMgPSBmdW5jdGlvbiAocywgb3B0aW9ucykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGJpZGkgPSBuZXcgQmlkaSgpO1xuXG4gICAgLy8gQ3JlYXRlIGFuZCByZWdpc3RlciAnZ2x5cGhJbmRleCcgc3RhdGUgbW9kaWZpZXJcbiAgICB2YXIgY2hhclRvR2x5cGhJbmRleE1vZCA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdGhpcyQxLmNoYXJUb0dseXBoSW5kZXgodG9rZW4uY2hhcik7IH07XG4gICAgYmlkaS5yZWdpc3Rlck1vZGlmaWVyKCdnbHlwaEluZGV4JywgbnVsbCwgY2hhclRvR2x5cGhJbmRleE1vZCk7XG5cbiAgICAvLyByb2xsLWJhY2sgdG8gZGVmYXVsdCBmZWF0dXJlc1xuICAgIHZhciBmZWF0dXJlcyA9IG9wdGlvbnNcbiAgICAgICAgPyB0aGlzLnVwZGF0ZUZlYXR1cmVzKG9wdGlvbnMuZmVhdHVyZXMpXG4gICAgICAgIDogdGhpcy5kZWZhdWx0UmVuZGVyT3B0aW9ucy5mZWF0dXJlcztcblxuICAgIGJpZGkuYXBwbHlGZWF0dXJlcyh0aGlzLCBmZWF0dXJlcyk7XG5cbiAgICB2YXIgaW5kZXhlcyA9IGJpZGkuZ2V0VGV4dEdseXBocyhzKTtcblxuICAgIHZhciBsZW5ndGggPSBpbmRleGVzLmxlbmd0aDtcblxuICAgIC8vIGNvbnZlcnQgZ2x5cGggaW5kZXhlcyB0byBnbHlwaCBvYmplY3RzXG4gICAgdmFyIGdseXBocyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIHZhciBub3RkZWYgPSB0aGlzLmdseXBocy5nZXQoMCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBnbHlwaHNbaV0gPSB0aGlzLmdseXBocy5nZXQoaW5kZXhlc1tpXSkgfHwgbm90ZGVmO1xuICAgIH1cbiAgICByZXR1cm4gZ2x5cGhzO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIGtlcm5pbmcgcGFpciBiZXR3ZWVuIHRoZSBsZWZ0IGdseXBoIChvciBpdHMgaW5kZXgpXG4gKiBhbmQgdGhlIHJpZ2h0IGdseXBoIChvciBpdHMgaW5kZXgpLiBJZiBubyBrZXJuaW5nIHBhaXIgaXMgZm91bmQsIHJldHVybiAwLlxuICogVGhlIGtlcm5pbmcgdmFsdWUgZ2V0cyBhZGRlZCB0byB0aGUgYWR2YW5jZSB3aWR0aCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBzcGFjaW5nXG4gKiBiZXR3ZWVuIGdseXBocy5cbiAqIEZvciBHUE9TIGtlcm5pbmcsIHRoaXMgbWV0aG9kIHVzZXMgdGhlIGRlZmF1bHQgc2NyaXB0IGFuZCBsYW5ndWFnZSwgd2hpY2ggY292ZXJzXG4gKiBtb3N0IHVzZSBjYXNlcy4gVG8gaGF2ZSBncmVhdGVyIGNvbnRyb2wsIHVzZSBmb250LnBvc2l0aW9uLmdldEtlcm5pbmdWYWx1ZSAuXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5HbHlwaH0gbGVmdEdseXBoXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5HbHlwaH0gcmlnaHRHbHlwaFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Gb250LnByb3RvdHlwZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbiAobGVmdEdseXBoLCByaWdodEdseXBoKSB7XG4gICAgbGVmdEdseXBoID0gbGVmdEdseXBoLmluZGV4IHx8IGxlZnRHbHlwaDtcbiAgICByaWdodEdseXBoID0gcmlnaHRHbHlwaC5pbmRleCB8fCByaWdodEdseXBoO1xuICAgIHZhciBncG9zS2VybmluZyA9IHRoaXMucG9zaXRpb24uZGVmYXVsdEtlcm5pbmdUYWJsZXM7XG4gICAgaWYgKGdwb3NLZXJuaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmdldEtlcm5pbmdWYWx1ZShcbiAgICAgICAgICAgIGdwb3NLZXJuaW5nLFxuICAgICAgICAgICAgbGVmdEdseXBoLFxuICAgICAgICAgICAgcmlnaHRHbHlwaFxuICAgICAgICApO1xuICAgIH1cbiAgICAvLyBcImtlcm5cIiB0YWJsZVxuICAgIHJldHVybiB0aGlzLmtlcm5pbmdQYWlyc1tsZWZ0R2x5cGggKyAnLCcgKyByaWdodEdseXBoXSB8fCAwO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBHbHlwaFJlbmRlck9wdGlvbnNcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzY3JpcHRdIC0gc2NyaXB0IHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGZlYXR1cmVzIHRvIGFwcGx5LiBCeSBkZWZhdWx0LCAnREZMVCcgb3IgJ2xhdG4nIGlzIHVzZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9zY3JpcHR0YWdzLmh0bVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddIC0gbGFuZ3VhZ2Ugc3lzdGVtIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGZlYXR1cmVzIHRvIGFwcGx5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9kZXZlbG9wZXJzL29wZW50eXBlL2xhbmd1YWdldGFncy5hc3B4XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZXJuaW5nPXRydWVdIC0gd2hldGhlciB0byBpbmNsdWRlIGtlcm5pbmcgdmFsdWVzXG4gKiBAcHJvcGVydHkge29iamVjdH0gW2ZlYXR1cmVzXSAtIE9wZW5UeXBlIExheW91dCBmZWF0dXJlIHRhZ3MuIFVzZWQgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGZlYXR1cmVzIG9mIHRoZSBnaXZlbiBzY3JpcHQvbGFuZ3VhZ2Ugc3lzdGVtLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9mZWF0dXJldGFncy5odG1cbiAqL1xuRm9udC5wcm90b3R5cGUuZGVmYXVsdFJlbmRlck9wdGlvbnMgPSB7XG4gICAga2VybmluZzogdHJ1ZSxcbiAgICBmZWF0dXJlczogW1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlc2UgNCBmZWF0dXJlcyBhcmUgcmVxdWlyZWQgdG8gcmVuZGVyIEFyYWJpYyB0ZXh0IHByb3Blcmx5XG4gICAgICAgICAqIGFuZCBzaG91bGRuJ3QgYmUgdHVybmVkIG9mZiB3aGVuIHJlbmRlcmluZyBhcmFiaWMgdGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIHsgc2NyaXB0OiAnYXJhYicsIHRhZ3M6IFsnaW5pdCcsICdtZWRpJywgJ2ZpbmEnLCAncmxpZyddIH0sXG4gICAgICAgIHsgc2NyaXB0OiAnbGF0bicsIHRhZ3M6IFsnbGlnYScsICdybGlnJ10gfSBdLFxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZWFjaCBnbHlwaCBpbiB0aGUgZ2l2ZW4gdGV4dC5cbiAqIFRoZSBjYWxsYmFjayBnZXRzIGAoZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKWAuKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gYXBwbHkuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5Gb250LnByb3RvdHlwZS5mb3JFYWNoR2x5cGggPSBmdW5jdGlvbiAoXG4gICAgdGV4dCxcbiAgICB4LFxuICAgIHksXG4gICAgZm9udFNpemUsXG4gICAgb3B0aW9ucyxcbiAgICBjYWxsYmFja1xuKSB7XG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDcyO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zLCBvcHRpb25zKTtcbiAgICB2YXIgZm9udFNjYWxlID0gKDEgLyB0aGlzLnVuaXRzUGVyRW0pICogZm9udFNpemU7XG4gICAgdmFyIGdseXBocyA9IHRoaXMuc3RyaW5nVG9HbHlwaHModGV4dCwgb3B0aW9ucyk7XG4gICAgdmFyIGtlcm5pbmdMb29rdXBzO1xuICAgIGlmIChvcHRpb25zLmtlcm5pbmcpIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IG9wdGlvbnMuc2NyaXB0IHx8IHRoaXMucG9zaXRpb24uZ2V0RGVmYXVsdFNjcmlwdE5hbWUoKTtcbiAgICAgICAga2VybmluZ0xvb2t1cHMgPSB0aGlzLnBvc2l0aW9uLmdldEtlcm5pbmdUYWJsZXMoXG4gICAgICAgICAgICBzY3JpcHQsXG4gICAgICAgICAgICBvcHRpb25zLmxhbmd1YWdlXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBnbHlwaCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZ2x5cGguYWR2YW5jZVdpZHRoKSB7XG4gICAgICAgICAgICB4ICs9IGdseXBoLmFkdmFuY2VXaWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmtlcm5pbmcgJiYgaSA8IGdseXBocy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgYXBwbHkgcG9zaXRpb24gYWRqdXN0bWVudCBsb29rdXBzIGluIGEgbW9yZSBnZW5lcmljIHdheS5cbiAgICAgICAgICAgIC8vIEhlcmUgd2Ugb25seSB1c2UgdGhlIHhBZHZhbmNlIHZhbHVlLlxuICAgICAgICAgICAgdmFyIGtlcm5pbmdWYWx1ZSA9IGtlcm5pbmdMb29rdXBzXG4gICAgICAgICAgICAgICAgPyB0aGlzLnBvc2l0aW9uLmdldEtlcm5pbmdWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICBrZXJuaW5nTG9va3VwcyxcbiAgICAgICAgICAgICAgICAgICAgICBnbHlwaC5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBnbHlwaHNbaSArIDFdLmluZGV4XG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiB0aGlzLmdldEtlcm5pbmdWYWx1ZShnbHlwaCwgZ2x5cGhzW2kgKyAxXSk7XG4gICAgICAgICAgICB4ICs9IGtlcm5pbmdWYWx1ZSAqIGZvbnRTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgICAgIHggKz0gb3B0aW9ucy5sZXR0ZXJTcGFjaW5nICogZm9udFNpemU7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50cmFja2luZykge1xuICAgICAgICAgICAgeCArPSAob3B0aW9ucy50cmFja2luZyAvIDEwMDApICogZm9udFNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIFBhdGggb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZ2l2ZW4gdGV4dC5cbiAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICogQHJldHVybiB7b3BlbnR5cGUuUGF0aH1cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHZhciBmdWxsUGF0aCA9IG5ldyBQYXRoKCk7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgoXG4gICAgICAgIHRleHQsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmdW5jdGlvbiAoZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGhQYXRoID0gZ2x5cGguZ2V0UGF0aChnWCwgZ1ksIGdGb250U2l6ZSwgb3B0aW9ucywgdGhpcyk7XG4gICAgICAgICAgICBmdWxsUGF0aC5leHRlbmQoZ2x5cGhQYXRoKTtcbiAgICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGZ1bGxQYXRoO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgUGF0aCBvYmplY3RzIHRoYXQgcmVwcmVzZW50IHRoZSBnbHlwaHMgb2YgYSBnaXZlbiB0ZXh0LlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRoW119XG4gKi9cbkZvbnQucHJvdG90eXBlLmdldFBhdGhzID0gZnVuY3Rpb24gKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIGdseXBoUGF0aHMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2hHbHlwaChcbiAgICAgICAgdGV4dCxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9uIChnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgICAgIGdseXBoUGF0aHMucHVzaChnbHlwaFBhdGgpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiBnbHlwaFBhdGhzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhZHZhbmNlIHdpZHRoIG9mIGEgdGV4dC5cbiAqXG4gKiBUaGlzIGlzIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBQYXRoLmdldEJvdW5kaW5nQm94KCkgYXMgZm9yIGV4YW1wbGUgYVxuICogc3VmZml4ZWQgd2hpdGVzcGFjZSBpbmNyZWFzZXMgdGhlIGFkdmFuY2VXaWR0aCBidXQgbm90IHRoZSBib3VuZGluZyBib3hcbiAqIG9yIGFuIG92ZXJoYW5naW5nIGxldHRlciBsaWtlIGEgY2FsbGlncmFwaGljICdmJyBtaWdodCBoYXZlIGEgcXVpdGUgbGFyZ2VyXG4gKiBib3VuZGluZyBib3ggdGhhbiBpdHMgYWR2YW5jZSB3aWR0aC5cbiAqXG4gKiBUaGlzIGNvcnJlc3BvbmRzIHRvIGNhbnZhczJkQ29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aFxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcmV0dXJuIGFkdmFuY2Ugd2lkdGhcbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0QWR2YW5jZVdpZHRoID0gZnVuY3Rpb24gKHRleHQsIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIDAsIDAsIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbiAoKSB7fSk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLmZzU2VsZWN0aW9uVmFsdWVzID0ge1xuICAgIElUQUxJQzogMHgwMDEsIC8vMVxuICAgIFVOREVSU0NPUkU6IDB4MDAyLCAvLzJcbiAgICBORUdBVElWRTogMHgwMDQsIC8vNFxuICAgIE9VVExJTkVEOiAweDAwOCwgLy84XG4gICAgU1RSSUtFT1VUOiAweDAxMCwgLy8xNlxuICAgIEJPTEQ6IDB4MDIwLCAvLzMyXG4gICAgUkVHVUxBUjogMHgwNDAsIC8vNjRcbiAgICBVU0VSX1RZUE9fTUVUUklDUzogMHgwODAsIC8vMTI4XG4gICAgV1dTOiAweDEwMCwgLy8yNTZcbiAgICBPQkxJUVVFOiAweDIwMCwgLy81MTJcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRm9udC5wcm90b3R5cGUudXNXaWR0aENsYXNzZXMgPSB7XG4gICAgVUxUUkFfQ09OREVOU0VEOiAxLFxuICAgIEVYVFJBX0NPTkRFTlNFRDogMixcbiAgICBDT05ERU5TRUQ6IDMsXG4gICAgU0VNSV9DT05ERU5TRUQ6IDQsXG4gICAgTUVESVVNOiA1LFxuICAgIFNFTUlfRVhQQU5ERUQ6IDYsXG4gICAgRVhQQU5ERUQ6IDcsXG4gICAgRVhUUkFfRVhQQU5ERUQ6IDgsXG4gICAgVUxUUkFfRVhQQU5ERUQ6IDksXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLnVzV2VpZ2h0Q2xhc3NlcyA9IHtcbiAgICBUSElOOiAxMDAsXG4gICAgRVhUUkFfTElHSFQ6IDIwMCxcbiAgICBMSUdIVDogMzAwLFxuICAgIE5PUk1BTDogNDAwLFxuICAgIE1FRElVTTogNTAwLFxuICAgIFNFTUlfQk9MRDogNjAwLFxuICAgIEJPTEQ6IDcwMCxcbiAgICBFWFRSQV9CT0xEOiA4MDAsXG4gICAgQkxBQ0s6IDkwMCxcbn07XG5cbi8vIFRoZSBgY21hcGAgdGFibGUgc3RvcmVzIHRoZSBtYXBwaW5ncyBmcm9tIGNoYXJhY3RlcnMgdG8gZ2x5cGhzLlxuXG5mdW5jdGlvbiBwYXJzZUNtYXBUYWJsZUZvcm1hdDEyKGNtYXAsIHApIHtcbiAgICAvL1NraXAgcmVzZXJ2ZWQuXG4gICAgcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgLy8gTGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBzdWItdGFibGVzLlxuICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY21hcC5sYW5ndWFnZSA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgdmFyIGdyb3VwQ291bnQ7XG4gICAgY21hcC5ncm91cENvdW50ID0gZ3JvdXBDb3VudCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNtYXAuZ2x5cGhJbmRleE1hcCA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHN0YXJ0Q2hhckNvZGUgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIGVuZENoYXJDb2RlID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIHZhciBzdGFydEdseXBoSWQgPSBwLnBhcnNlVUxvbmcoKTtcblxuICAgICAgICBmb3IgKHZhciBjID0gc3RhcnRDaGFyQ29kZTsgYyA8PSBlbmRDaGFyQ29kZTsgYyArPSAxKSB7XG4gICAgICAgICAgICBjbWFwLmdseXBoSW5kZXhNYXBbY10gPSBzdGFydEdseXBoSWQ7XG4gICAgICAgICAgICBzdGFydEdseXBoSWQrKztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGVGb3JtYXQ0KGNtYXAsIHAsIGRhdGEsIHN0YXJ0LCBvZmZzZXQpIHtcbiAgICAvLyBMZW5ndGggaW4gYnl0ZXMgb2YgdGhlIHN1Yi10YWJsZXMuXG4gICAgY21hcC5sZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY21hcC5sYW5ndWFnZSA9IHAucGFyc2VVU2hvcnQoKTtcblxuICAgIC8vIHNlZ0NvdW50IGlzIHN0b3JlZCB4IDIuXG4gICAgdmFyIHNlZ0NvdW50O1xuICAgIGNtYXAuc2VnQ291bnQgPSBzZWdDb3VudCA9IHAucGFyc2VVU2hvcnQoKSA+PiAxO1xuXG4gICAgLy8gU2tpcCBzZWFyY2hSYW5nZSwgZW50cnlTZWxlY3RvciwgcmFuZ2VTaGlmdC5cbiAgICBwLnNraXAoJ3VTaG9ydCcsIDMpO1xuXG4gICAgLy8gVGhlIFwidW5yb2xsZWRcIiBtYXBwaW5nIGZyb20gY2hhcmFjdGVyIGNvZGVzIHRvIGdseXBoIGluZGljZXMuXG4gICAgY21hcC5nbHlwaEluZGV4TWFwID0ge307XG4gICAgdmFyIGVuZENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE0KTtcbiAgICB2YXIgc3RhcnRDb3VudFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDJcbiAgICApO1xuICAgIHZhciBpZERlbHRhUGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogNFxuICAgICk7XG4gICAgdmFyIGlkUmFuZ2VPZmZzZXRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKFxuICAgICAgICBkYXRhLFxuICAgICAgICBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA2XG4gICAgKTtcbiAgICB2YXIgZ2x5cGhJbmRleE9mZnNldCA9IHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdDb3VudCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGhJbmRleCA9ICh2b2lkIDApO1xuICAgICAgICB2YXIgZW5kQ291bnQgPSBlbmRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgc3RhcnRDb3VudCA9IHN0YXJ0Q291bnRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGlkRGVsdGEgPSBpZERlbHRhUGFyc2VyLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgdmFyIGlkUmFuZ2VPZmZzZXQgPSBpZFJhbmdlT2Zmc2V0UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGZvciAodmFyIGMgPSBzdGFydENvdW50OyBjIDw9IGVuZENvdW50OyBjICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChpZFJhbmdlT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGlkUmFuZ2VPZmZzZXQgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGlkUmFuZ2VPZmZzZXQgYXJyYXkuXG4gICAgICAgICAgICAgICAgLy8gVGFrZSB0aGUgY3VycmVudCBvZmZzZXQgaW4gdGhlIGlkUmFuZ2VPZmZzZXQgYXJyYXkuXG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleE9mZnNldCA9XG4gICAgICAgICAgICAgICAgICAgIGlkUmFuZ2VPZmZzZXRQYXJzZXIub2Zmc2V0ICtcbiAgICAgICAgICAgICAgICAgICAgaWRSYW5nZU9mZnNldFBhcnNlci5yZWxhdGl2ZU9mZnNldCAtXG4gICAgICAgICAgICAgICAgICAgIDI7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHZhbHVlIG9mIHRoZSBpZFJhbmdlT2Zmc2V0LCB3aGljaCB3aWxsIG1vdmUgdXMgaW50byB0aGUgZ2x5cGhJbmRleCBhcnJheS5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IGlkUmFuZ2VPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVuIGFkZCB0aGUgY2hhcmFjdGVyIGluZGV4IG9mIHRoZSBjdXJyZW50IHNlZ21lbnQsIG11bHRpcGxpZWQgYnkgMiBmb3IgVVNIT1JUcy5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IChjIC0gc3RhcnRDb3VudCkgKiAyO1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgZ2x5cGhJbmRleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IChnbHlwaEluZGV4ICsgaWREZWx0YSkgJiAweGZmZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGMgKyBpZERlbHRhKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY21hcC5nbHlwaEluZGV4TWFwW2NdID0gZ2x5cGhJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gUGFyc2UgdGhlIGBjbWFwYCB0YWJsZS4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG4vLyBUaGVyZSBhcmUgbWFueSBhdmFpbGFibGUgZm9ybWF0cywgYnV0IHdlIG9ubHkgc3VwcG9ydCB0aGUgV2luZG93cyBmb3JtYXQgNCBhbmQgMTIuXG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBgQ21hcEVuY29kaW5nYCBvYmplY3Qgb3IgbnVsbCBpZiBubyBzdXBwb3J0ZWQgZm9ybWF0IGNvdWxkIGJlIGZvdW5kLlxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgY21hcCA9IHt9O1xuICAgIGNtYXAudmVyc2lvbiA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCk7XG4gICAgY2hlY2suYXJndW1lbnQoY21hcC52ZXJzaW9uID09PSAwLCAnY21hcCB0YWJsZSB2ZXJzaW9uIHNob3VsZCBiZSAwLicpO1xuXG4gICAgLy8gVGhlIGNtYXAgdGFibGUgY2FuIGNvbnRhaW4gbWFueSBzdWItdGFibGVzLCBlYWNoIHdpdGggdGhlaXIgb3duIGZvcm1hdC5cbiAgICAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gYSBcInBsYXRmb3JtIDBcIiAoVW5pY29kZSBmb3JtYXQpIGFuZCBcInBsYXRmb3JtIDNcIiAoV2luZG93cyBmb3JtYXQpIHRhYmxlLlxuICAgIGNtYXAubnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgdmFyIG9mZnNldCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSBjbWFwLm51bVRhYmxlcyAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHZhciBwbGF0Zm9ybUlkID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgNCArIGkgKiA4KTtcbiAgICAgICAgdmFyIGVuY29kaW5nSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgaSAqIDggKyAyKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHBsYXRmb3JtSWQgPT09IDMgJiZcbiAgICAgICAgICAgICAgICAoZW5jb2RpbmdJZCA9PT0gMCB8fCBlbmNvZGluZ0lkID09PSAxIHx8IGVuY29kaW5nSWQgPT09IDEwKSkgfHxcbiAgICAgICAgICAgIChwbGF0Zm9ybUlkID09PSAwICYmXG4gICAgICAgICAgICAgICAgKGVuY29kaW5nSWQgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmdJZCA9PT0gMSB8fFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZ0lkID09PSAyIHx8XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nSWQgPT09IDMgfHxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmdJZCA9PT0gNCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgc3RhcnQgKyA0ICsgaSAqIDggKyA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gY21hcCB0YWJsZSBpbiB0aGUgZm9udCB0aGF0IHdlIHN1cHBvcnQuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgY21hcCBzdWItdGFibGVzIGZvdW5kLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCk7XG4gICAgY21hcC5mb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICBpZiAoY21hcC5mb3JtYXQgPT09IDEyKSB7XG4gICAgICAgIHBhcnNlQ21hcFRhYmxlRm9ybWF0MTIoY21hcCwgcCk7XG4gICAgfSBlbHNlIGlmIChjbWFwLmZvcm1hdCA9PT0gNCkge1xuICAgICAgICBwYXJzZUNtYXBUYWJsZUZvcm1hdDQoY21hcCwgcCwgZGF0YSwgc3RhcnQsIG9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ09ubHkgZm9ybWF0IDQgYW5kIDEyIGNtYXAgdGFibGVzIGFyZSBzdXBwb3J0ZWQgKGZvdW5kIGZvcm1hdCAnICtcbiAgICAgICAgICAgICAgICBjbWFwLmZvcm1hdCArXG4gICAgICAgICAgICAgICAgJykuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjbWFwO1xufVxuXG52YXIgY21hcCA9IHsgcGFyc2U6IHBhcnNlQ21hcFRhYmxlIH07XG5cbi8vIFRoZSBgQ0ZGYCB0YWJsZSBjb250YWlucyB0aGUgZ2x5cGggb3V0bGluZXMgaW4gUG9zdFNjcmlwdCBmb3JtYXQuXG5cbi8vIFN1YnJvdXRpbmVzIGFyZSBlbmNvZGVkIHVzaW5nIHRoZSBuZWdhdGl2ZSBoYWxmIG9mIHRoZSBudW1iZXIgc3BhY2UuXG4vLyBTZWUgdHlwZSAyIGNoYXB0ZXIgNC43IFwiU3Vicm91dGluZSBvcGVyYXRvcnNcIi5cbmZ1bmN0aW9uIGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhzdWJycykge1xuICAgIHZhciBiaWFzO1xuICAgIGlmIChzdWJycy5sZW5ndGggPCAxMjQwKSB7XG4gICAgICAgIGJpYXMgPSAxMDc7XG4gICAgfSBlbHNlIGlmIChzdWJycy5sZW5ndGggPCAzMzkwMCkge1xuICAgICAgICBiaWFzID0gMTEzMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBiaWFzID0gMzI3Njg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpYXM7XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgSU5ERVggYXJyYXkuXG4vLyBBbiBpbmRleCBhcnJheSBjb25zaXN0cyBvZiBhIGxpc3Qgb2Ygb2Zmc2V0cywgdGhlbiBhIGxpc3Qgb2Ygb2JqZWN0cyBhdCB0aG9zZSBvZmZzZXRzLlxuZnVuY3Rpb24gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCwgY29udmVyc2lvbkZuKSB7XG4gICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIHZhciBjb3VudCA9IHBhcnNlLmdldENhcmQxNihkYXRhLCBzdGFydCk7XG4gICAgdmFyIG9iamVjdE9mZnNldDtcbiAgICB2YXIgZW5kT2Zmc2V0O1xuICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICB2YXIgb2Zmc2V0U2l6ZSA9IHBhcnNlLmdldEJ5dGUoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICAgICAgb2JqZWN0T2Zmc2V0ID0gc3RhcnQgKyAoY291bnQgKyAxKSAqIG9mZnNldFNpemUgKyAyO1xuICAgICAgICB2YXIgcG9zID0gc3RhcnQgKyAzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICsgMTsgaSArPSAxKSB7XG4gICAgICAgICAgICBvZmZzZXRzLnB1c2gocGFyc2UuZ2V0T2Zmc2V0KGRhdGEsIHBvcywgb2Zmc2V0U2l6ZSkpO1xuICAgICAgICAgICAgcG9zICs9IG9mZnNldFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgaW5kZXggYXJyYXkgaXMgNCBoZWFkZXIgYnl0ZXMgKyB0aGUgdmFsdWUgb2YgdGhlIGxhc3Qgb2Zmc2V0LlxuICAgICAgICBlbmRPZmZzZXQgPSBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2NvdW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmRPZmZzZXQgPSBzdGFydCArIDI7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgb2Zmc2V0cy5sZW5ndGggLSAxOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZS5nZXRCeXRlcyhcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2kkMV0sXG4gICAgICAgICAgICBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2kkMSArIDFdXG4gICAgICAgICk7XG4gICAgICAgIGlmIChjb252ZXJzaW9uRm4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVyc2lvbkZuKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgb2JqZWN0czogb2JqZWN0cywgc3RhcnRPZmZzZXQ6IHN0YXJ0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldCB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUNGRkluZGV4TG93TWVtb3J5KGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICB2YXIgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBvYmplY3RPZmZzZXQ7XG4gICAgdmFyIGVuZE9mZnNldDtcbiAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgdmFyIG9mZnNldFNpemUgPSBwYXJzZS5nZXRCeXRlKGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgICAgIG9iamVjdE9mZnNldCA9IHN0YXJ0ICsgKGNvdW50ICsgMSkgKiBvZmZzZXRTaXplICsgMjtcbiAgICAgICAgdmFyIHBvcyA9IHN0YXJ0ICsgMztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCArIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKHBhcnNlLmdldE9mZnNldChkYXRhLCBwb3MsIG9mZnNldFNpemUpKTtcbiAgICAgICAgICAgIHBvcyArPSBvZmZzZXRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGluZGV4IGFycmF5IGlzIDQgaGVhZGVyIGJ5dGVzICsgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IG9mZnNldC5cbiAgICAgICAgZW5kT2Zmc2V0ID0gb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tjb3VudF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW5kT2Zmc2V0ID0gc3RhcnQgKyAyO1xuICAgIH1cblxuICAgIHJldHVybiB7IG9mZnNldHM6IG9mZnNldHMsIHN0YXJ0T2Zmc2V0OiBzdGFydCwgZW5kT2Zmc2V0OiBlbmRPZmZzZXQgfTtcbn1cbmZ1bmN0aW9uIGdldENmZkluZGV4T2JqZWN0KGksIG9mZnNldHMsIGRhdGEsIHN0YXJ0LCBjb252ZXJzaW9uRm4pIHtcbiAgICB2YXIgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBvYmplY3RPZmZzZXQgPSAwO1xuICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICB2YXIgb2Zmc2V0U2l6ZSA9IHBhcnNlLmdldEJ5dGUoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICAgICAgb2JqZWN0T2Zmc2V0ID0gc3RhcnQgKyAoY291bnQgKyAxKSAqIG9mZnNldFNpemUgKyAyO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHBhcnNlLmdldEJ5dGVzKFxuICAgICAgICBkYXRhLFxuICAgICAgICBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2ldLFxuICAgICAgICBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2kgKyAxXVxuICAgICk7XG4gICAgaWYgKGNvbnZlcnNpb25Gbikge1xuICAgICAgICB2YWx1ZSA9IGNvbnZlcnNpb25Gbih2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIHJlYWwgdmFsdWUuXG5mdW5jdGlvbiBwYXJzZUZsb2F0T3BlcmFuZChwYXJzZXIpIHtcbiAgICB2YXIgcyA9ICcnO1xuICAgIHZhciBlb2YgPSAxNTtcbiAgICB2YXIgbG9va3VwID0gW1xuICAgICAgICAnMCcsXG4gICAgICAgICcxJyxcbiAgICAgICAgJzInLFxuICAgICAgICAnMycsXG4gICAgICAgICc0JyxcbiAgICAgICAgJzUnLFxuICAgICAgICAnNicsXG4gICAgICAgICc3JyxcbiAgICAgICAgJzgnLFxuICAgICAgICAnOScsXG4gICAgICAgICcuJyxcbiAgICAgICAgJ0UnLFxuICAgICAgICAnRS0nLFxuICAgICAgICBudWxsLFxuICAgICAgICAnLScgXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgYiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgdmFyIG4xID0gYiA+PiA0O1xuICAgICAgICB2YXIgbjIgPSBiICYgMTU7XG5cbiAgICAgICAgaWYgKG4xID09PSBlb2YpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcyArPSBsb29rdXBbbjFdO1xuXG4gICAgICAgIGlmIChuMiA9PT0gZW9mKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gbG9va3VwW24yXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdChzKTtcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9wZXJhbmQuXG5mdW5jdGlvbiBwYXJzZU9wZXJhbmQocGFyc2VyLCBiMCkge1xuICAgIHZhciBiMTtcbiAgICB2YXIgYjI7XG4gICAgdmFyIGIzO1xuICAgIHZhciBiNDtcbiAgICBpZiAoYjAgPT09IDI4KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIChiMSA8PCA4KSB8IGIyO1xuICAgIH1cblxuICAgIGlmIChiMCA9PT0gMjkpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMyA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjQgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiAoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSB8IChiMyA8PCA4KSB8IGI0O1xuICAgIH1cblxuICAgIGlmIChiMCA9PT0gMzApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXRPcGVyYW5kKHBhcnNlcik7XG4gICAgfVxuXG4gICAgaWYgKGIwID49IDMyICYmIGIwIDw9IDI0Nikge1xuICAgICAgICByZXR1cm4gYjAgLSAxMzk7XG4gICAgfVxuXG4gICAgaWYgKGIwID49IDI0NyAmJiBiMCA8PSAyNTApIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiAoYjAgLSAyNDcpICogMjU2ICsgYjEgKyAxMDg7XG4gICAgfVxuXG4gICAgaWYgKGIwID49IDI1MSAmJiBiMCA8PSAyNTQpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiAtKGIwIC0gMjUxKSAqIDI1NiAtIGIxIC0gMTA4O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiMCAnICsgYjApO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBlbnRyaWVzIHJldHVybmVkIGJ5IGBwYXJzZURpY3RgIHRvIGEgcHJvcGVyIGRpY3Rpb25hcnkuXG4vLyBJZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBvbmUsIGl0IGlzIHVucGFja2VkLlxuZnVuY3Rpb24gZW50cmllc1RvT2JqZWN0KGVudHJpZXMpIHtcbiAgICB2YXIgbyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIga2V5ID0gZW50cmllc1tpXVswXTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGVudHJpZXNbaV1bMV07XG4gICAgICAgIHZhciB2YWx1ZSA9ICh2b2lkIDApO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkgJiYgIWlzTmFOKG9ba2V5XSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0ICcgKyBvICsgJyBhbHJlYWR5IGhhcyBrZXkgJyArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9iamVjdC5cbi8vIEEgZGljdGlvbmFyeSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgaW4gYSBjb21wYWN0IHRva2VuaXplZCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpIHtcbiAgICBzdGFydCA9IHN0YXJ0ICE9PSB1bmRlZmluZWQgPyBzdGFydCA6IDA7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgdmFyIG9wZXJhbmRzID0gW107XG4gICAgc2l6ZSA9IHNpemUgIT09IHVuZGVmaW5lZCA/IHNpemUgOiBkYXRhLmxlbmd0aDtcblxuICAgIHdoaWxlIChwYXJzZXIucmVsYXRpdmVPZmZzZXQgPCBzaXplKSB7XG4gICAgICAgIHZhciBvcCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgYnl0ZSBmb3IgZWFjaCBkaWN0IGl0ZW0gZGlzdGluZ3Vpc2hlcyBiZXR3ZWVuIG9wZXJhdG9yIChrZXkpIGFuZCBvcGVyYW5kICh2YWx1ZSkuXG4gICAgICAgIC8vIFZhbHVlcyA8PSAyMSBhcmUgb3BlcmF0b3JzLlxuICAgICAgICBpZiAob3AgPD0gMjEpIHtcbiAgICAgICAgICAgIC8vIFR3by1ieXRlIG9wZXJhdG9ycyBoYXZlIGFuIGluaXRpYWwgZXNjYXBlIGJ5dGUgb2YgMTIuXG4gICAgICAgICAgICBpZiAob3AgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgb3AgPSAxMjAwICsgcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW29wLCBvcGVyYW5kc10pO1xuICAgICAgICAgICAgb3BlcmFuZHMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBvcGVyYW5kcyAodmFsdWVzKSBjb21lIGJlZm9yZSB0aGUgb3BlcmF0b3JzIChrZXlzKSwgd2Ugc3RvcmUgYWxsIG9wZXJhbmRzIGluIGEgbGlzdFxuICAgICAgICAgICAgLy8gdW50aWwgd2UgZW5jb3VudGVyIGFuIG9wZXJhdG9yLlxuICAgICAgICAgICAgb3BlcmFuZHMucHVzaChwYXJzZU9wZXJhbmQocGFyc2VyLCBvcCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJpZXNUb09iamVjdChlbnRyaWVzKTtcbn1cblxuLy8gR2l2ZW4gYSBTdHJpbmcgSW5kZXggKFNJRCksIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cbi8vIFN0cmluZ3MgYmVsb3cgaW5kZXggMzkyIGFyZSBzdGFuZGFyZCBDRkYgc3RyaW5ncyBhbmQgYXJlIG5vdCBlbmNvZGVkIGluIHRoZSBmb250LlxuZnVuY3Rpb24gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDw9IDM5MCkge1xuICAgICAgICBpbmRleCA9IGNmZlN0YW5kYXJkU3RyaW5nc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBzdHJpbmdzW2luZGV4IC0gMzkxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbi8vIEludGVycHJldCBhIGRpY3Rpb25hcnkgYW5kIHJldHVybiBhIG5ldyBkaWN0aW9uYXJ5IHdpdGggcmVhZGFibGUga2V5cyBhbmQgdmFsdWVzIGZvciBtaXNzaW5nIGVudHJpZXMuXG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGBtZXRhYCB3aGljaCBpcyBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIGBvcGVyYW5kYCwgYG5hbWVgIGFuZCBgZGVmYXVsdGAuXG5mdW5jdGlvbiBpbnRlcnByZXREaWN0KGRpY3QsIG1ldGEsIHN0cmluZ3MpIHtcbiAgICB2YXIgbmV3RGljdCA9IHt9O1xuICAgIHZhciB2YWx1ZTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYWxzbyB3YW50IHRvIGluY2x1ZGUgbWlzc2luZyB2YWx1ZXMsIHdlIHN0YXJ0IG91dCBmcm9tIHRoZSBtZXRhIGxpc3RcbiAgICAvLyBhbmQgbG9va3VwIHZhbHVlcyBpbiB0aGUgZGljdC5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG0gPSBtZXRhW2ldO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG0udHlwZSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhbHVlcy5sZW5ndGggPSBtLnR5cGUubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtLnR5cGUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRpY3RbbS5vcF0gIT09IHVuZGVmaW5lZCA/IGRpY3RbbS5vcF1bal0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIG0udmFsdWVbal0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbS52YWx1ZVtqXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG0udHlwZVtqXSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRDRkZTdHJpbmcoc3RyaW5ncywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZXNbal0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0RpY3RbbS5uYW1lXSA9IHZhbHVlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gZGljdFttLm9wXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtLnZhbHVlICE9PSB1bmRlZmluZWQgPyBtLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG0udHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldENGRlN0cmluZyhzdHJpbmdzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdEaWN0W20ubmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdEaWN0O1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIGhlYWRlci5cbmZ1bmN0aW9uIHBhcnNlQ0ZGSGVhZGVyKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIGhlYWRlciA9IHt9O1xuICAgIGhlYWRlci5mb3JtYXRNYWpvciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0KTtcbiAgICBoZWFkZXIuZm9ybWF0TWlub3IgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDEpO1xuICAgIGhlYWRlci5zaXplID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICBoZWFkZXIub2Zmc2V0U2l6ZSA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMyk7XG4gICAgaGVhZGVyLnN0YXJ0T2Zmc2V0ID0gc3RhcnQ7XG4gICAgaGVhZGVyLmVuZE9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICByZXR1cm4gaGVhZGVyO1xufVxuXG52YXIgVE9QX0RJQ1RfTUVUQSA9IFtcbiAgICB7IG5hbWU6ICd2ZXJzaW9uJywgb3A6IDAsIHR5cGU6ICdTSUQnIH0sXG4gICAgeyBuYW1lOiAnbm90aWNlJywgb3A6IDEsIHR5cGU6ICdTSUQnIH0sXG4gICAgeyBuYW1lOiAnY29weXJpZ2h0Jywgb3A6IDEyMDAsIHR5cGU6ICdTSUQnIH0sXG4gICAgeyBuYW1lOiAnZnVsbE5hbWUnLCBvcDogMiwgdHlwZTogJ1NJRCcgfSxcbiAgICB7IG5hbWU6ICdmYW1pbHlOYW1lJywgb3A6IDMsIHR5cGU6ICdTSUQnIH0sXG4gICAgeyBuYW1lOiAnd2VpZ2h0Jywgb3A6IDQsIHR5cGU6ICdTSUQnIH0sXG4gICAgeyBuYW1lOiAnaXNGaXhlZFBpdGNoJywgb3A6IDEyMDEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ2l0YWxpY0FuZ2xlJywgb3A6IDEyMDIsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgb3A6IDEyMDMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogLTEwMCB9LFxuICAgIHsgbmFtZTogJ3VuZGVybGluZVRoaWNrbmVzcycsIG9wOiAxMjA0LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDUwIH0sXG4gICAgeyBuYW1lOiAncGFpbnRUeXBlJywgb3A6IDEyMDUsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ2NoYXJzdHJpbmdUeXBlJywgb3A6IDEyMDYsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMiB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2ZvbnRNYXRyaXgnLFxuICAgICAgICBvcDogMTIwNyxcbiAgICAgICAgdHlwZTogWydyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCddLFxuICAgICAgICB2YWx1ZTogWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF0sXG4gICAgfSxcbiAgICB7IG5hbWU6ICd1bmlxdWVJZCcsIG9wOiAxMywgdHlwZTogJ251bWJlcicgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdmb250QkJveCcsXG4gICAgICAgIG9wOiA1LFxuICAgICAgICB0eXBlOiBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddLFxuICAgICAgICB2YWx1ZTogWzAsIDAsIDAsIDBdLFxuICAgIH0sXG4gICAgeyBuYW1lOiAnc3Ryb2tlV2lkdGgnLCBvcDogMTIwOCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAneHVpZCcsIG9wOiAxNCwgdHlwZTogW10sIHZhbHVlOiBudWxsIH0sXG4gICAgeyBuYW1lOiAnY2hhcnNldCcsIG9wOiAxNSwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAnZW5jb2RpbmcnLCBvcDogMTYsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMCB9LFxuICAgIHsgbmFtZTogJ2NoYXJTdHJpbmdzJywgb3A6IDE3LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICdwcml2YXRlJywgb3A6IDE4LCB0eXBlOiBbJ251bWJlcicsICdvZmZzZXQnXSwgdmFsdWU6IFswLCAwXSB9LFxuICAgIHsgbmFtZTogJ3JvcycsIG9wOiAxMjMwLCB0eXBlOiBbJ1NJRCcsICdTSUQnLCAnbnVtYmVyJ10gfSxcbiAgICB7IG5hbWU6ICdjaWRGb250VmVyc2lvbicsIG9wOiAxMjMxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICdjaWRGb250UmV2aXNpb24nLCBvcDogMTIzMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAnY2lkRm9udFR5cGUnLCBvcDogMTIzMywgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH0sXG4gICAgeyBuYW1lOiAnY2lkQ291bnQnLCBvcDogMTIzNCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiA4NzIwIH0sXG4gICAgeyBuYW1lOiAndWlkQmFzZScsIG9wOiAxMjM1LCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIHsgbmFtZTogJ2ZkQXJyYXknLCBvcDogMTIzNiwgdHlwZTogJ29mZnNldCcgfSxcbiAgICB7IG5hbWU6ICdmZFNlbGVjdCcsIG9wOiAxMjM3LCB0eXBlOiAnb2Zmc2V0JyB9LFxuICAgIHsgbmFtZTogJ2ZvbnROYW1lJywgb3A6IDEyMzgsIHR5cGU6ICdTSUQnIH0gXTtcblxudmFyIFBSSVZBVEVfRElDVF9NRVRBID0gW1xuICAgIHsgbmFtZTogJ3N1YnJzJywgb3A6IDE5LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICdkZWZhdWx0V2lkdGhYJywgb3A6IDIwLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSxcbiAgICB7IG5hbWU6ICdub21pbmFsV2lkdGhYJywgb3A6IDIxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDAgfSBdO1xuXG4vLyBQYXJzZSB0aGUgQ0ZGIHRvcCBkaWN0aW9uYXJ5LiBBIENGRiB0YWJsZSBjYW4gY29udGFpbiBtdWx0aXBsZSBmb250cywgZWFjaCB3aXRoIHRoZWlyIG93biB0b3AgZGljdGlvbmFyeS5cbi8vIFRoZSB0b3AgZGljdGlvbmFyeSBjb250YWlucyB0aGUgZXNzZW50aWFsIG1ldGFkYXRhIGZvciB0aGUgZm9udCwgdG9nZXRoZXIgd2l0aCB0aGUgcHJpdmF0ZSBkaWN0aW9uYXJ5LlxuZnVuY3Rpb24gcGFyc2VDRkZUb3BEaWN0KGRhdGEsIHN0cmluZ3MpIHtcbiAgICB2YXIgZGljdCA9IHBhcnNlQ0ZGRGljdChkYXRhLCAwLCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFRPUF9ESUNUX01FVEEsIHN0cmluZ3MpO1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIHByaXZhdGUgZGljdGlvbmFyeS4gV2UgZG9uJ3QgZnVsbHkgcGFyc2Ugb3V0IGFsbCB0aGUgdmFsdWVzLCBvbmx5IHRoZSBvbmVzIHdlIG5lZWQuXG5mdW5jdGlvbiBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHN0YXJ0LCBzaXplLCBzdHJpbmdzKSB7XG4gICAgdmFyIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpO1xuICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFBSSVZBVEVfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUmV0dXJucyBhIGxpc3Qgb2YgXCJUb3AgRElDVFwicyBmb3VuZCB1c2luZyBhbiBJTkRFWCBsaXN0LlxuLy8gVXNlZCB0byByZWFkIGJvdGggdGhlIHVzdWFsIGhpZ2gtbGV2ZWwgVG9wIERJQ1RzIGFuZCBhbHNvIHRoZSBGREFycmF5XG4vLyBkaXNjb3ZlcmVkIGluc2lkZSBDSUQta2V5ZWQgZm9udHMuICBXaGVuIGEgVG9wIERJQ1QgaGFzIGEgcmVmZXJlbmNlIHRvXG4vLyBhIFByaXZhdGUgRElDVCB0aGF0IGlzIHJlYWQgYW5kIHNhdmVkIGludG8gdGhlIFRvcCBESUNULlxuLy9cbi8vIEluIGFkZGl0aW9uIHRvIHRoZSBleHBlY3RlZC9vcHRpb25hbCB2YWx1ZXMgYXMgb3V0bGluZWQgaW4gVE9QX0RJQ1RfTUVUQVxuLy8gdGhlIGZvbGxvd2luZyB2YWx1ZXMgbWlnaHQgYmUgc2F2ZWQgaW50byB0aGUgVG9wIERJQ1QuXG4vL1xuLy8gICAgX3N1YnJzIFtdICAgICAgICBhcnJheSBvZiBsb2NhbCBDRkYgc3Vicm91dGluZXMgZnJvbSBQcml2YXRlIERJQ1Rcbi8vICAgIF9zdWJyc0JpYXMgICAgICAgYmlhcyB2YWx1ZSBjb21wdXRlZCBmcm9tIG51bWJlciBvZiBzdWJyb3V0aW5lc1xuLy8gICAgICAgICAgICAgICAgICAgICAgKHNlZSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoKSBhbmQgcGFyc2VDRkZDaGFyc3RyaW5nKCkpXG4vLyAgICBfZGVmYXVsdFdpZHRoWCAgIGRlZmF1bHQgd2lkdGhzIGZvciBDRkYgY2hhcmFjdGVyc1xuLy8gICAgX25vbWluYWxXaWR0aFggICBiaWFzIGFkZGVkIHRvIHdpZHRoIGVtYmVkZGVkIHdpdGhpbiBnbHlwaCBkZXNjcmlwdGlvblxuLy9cbi8vICAgIF9wcml2YXRlRGljdCAgICAgc2F2ZWQgY29weSBvZiBwYXJzZWQgUHJpdmF0ZSBESUNUIGZyb20gVG9wIERJQ1RcbmZ1bmN0aW9uIGdhdGhlckNGRlRvcERpY3RzKGRhdGEsIHN0YXJ0LCBjZmZJbmRleCwgc3RyaW5ncykge1xuICAgIHZhciB0b3BEaWN0QXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpVG9wRGljdCA9IDA7IGlUb3BEaWN0IDwgY2ZmSW5kZXgubGVuZ3RoOyBpVG9wRGljdCArPSAxKSB7XG4gICAgICAgIHZhciB0b3BEaWN0RGF0YSA9IG5ldyBEYXRhVmlldyhcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGNmZkluZGV4W2lUb3BEaWN0XSkuYnVmZmVyXG4gICAgICAgICk7XG4gICAgICAgIHZhciB0b3BEaWN0ID0gcGFyc2VDRkZUb3BEaWN0KHRvcERpY3REYXRhLCBzdHJpbmdzKTtcbiAgICAgICAgdG9wRGljdC5fc3VicnMgPSBbXTtcbiAgICAgICAgdG9wRGljdC5fc3VicnNCaWFzID0gMDtcbiAgICAgICAgdG9wRGljdC5fZGVmYXVsdFdpZHRoWCA9IDA7XG4gICAgICAgIHRvcERpY3QuX25vbWluYWxXaWR0aFggPSAwO1xuICAgICAgICB2YXIgcHJpdmF0ZVNpemUgPSB0b3BEaWN0LnByaXZhdGVbMF07XG4gICAgICAgIHZhciBwcml2YXRlT2Zmc2V0ID0gdG9wRGljdC5wcml2YXRlWzFdO1xuICAgICAgICBpZiAocHJpdmF0ZVNpemUgIT09IDAgJiYgcHJpdmF0ZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIHByaXZhdGVEaWN0ID0gcGFyc2VDRkZQcml2YXRlRGljdChcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIHByaXZhdGVPZmZzZXQgKyBzdGFydCxcbiAgICAgICAgICAgICAgICBwcml2YXRlU2l6ZSxcbiAgICAgICAgICAgICAgICBzdHJpbmdzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdG9wRGljdC5fZGVmYXVsdFdpZHRoWCA9IHByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgICAgICAgICB0b3BEaWN0Ll9ub21pbmFsV2lkdGhYID0gcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJyT2Zmc2V0ID0gcHJpdmF0ZU9mZnNldCArIHByaXZhdGVEaWN0LnN1YnJzO1xuICAgICAgICAgICAgICAgIHZhciBzdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN1YnJPZmZzZXQgKyBzdGFydCk7XG4gICAgICAgICAgICAgICAgdG9wRGljdC5fc3VicnMgPSBzdWJySW5kZXgub2JqZWN0cztcbiAgICAgICAgICAgICAgICB0b3BEaWN0Ll9zdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXModG9wRGljdC5fc3VicnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wRGljdC5fcHJpdmF0ZURpY3QgPSBwcml2YXRlRGljdDtcbiAgICAgICAgfVxuICAgICAgICB0b3BEaWN0QXJyYXkucHVzaCh0b3BEaWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcERpY3RBcnJheTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBjaGFyc2V0IHRhYmxlLCB3aGljaCBjb250YWlucyBpbnRlcm5hbCBuYW1lcyBmb3IgYWxsIHRoZSBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBnbHlwaCBuYW1lcy5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEzLCBcIkNoYXJzZXRzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIHN0cmluZ3MpIHtcbiAgICB2YXIgc2lkO1xuICAgIHZhciBjb3VudDtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cbiAgICAvLyBUaGUgLm5vdGRlZiBnbHlwaCBpcyBub3QgaW5jbHVkZWQsIHNvIHN1YnRyYWN0IDEuXG4gICAgbkdseXBocyAtPSAxO1xuICAgIHZhciBjaGFyc2V0ID0gWycubm90ZGVmJ107XG5cbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkdseXBoczsgaSArPSAxKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICB3aGlsZSAoY2hhcnNldC5sZW5ndGggPD0gbkdseXBocykge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjb3VudCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPD0gY291bnQ7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPD0gY291bnQ7IGkkMiArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjaGFyc2V0IGZvcm1hdCAnICsgZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnNldDtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBlbmNvZGluZyBkYXRhLiBPbmx5IG9uZSBlbmNvZGluZyBjYW4gYmUgc3BlY2lmaWVkIHBlciBmb250LlxuLy8gU2VlIEFkb2JlIFROICM1MTc2IGNoYXB0ZXIgMTIsIFwiRW5jb2RpbmdzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkVuY29kaW5nKGRhdGEsIHN0YXJ0LCBjaGFyc2V0KSB7XG4gICAgdmFyIGNvZGU7XG4gICAgdmFyIGVuYyA9IHt9O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIHZhciBuQ29kZXMgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Db2RlczsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb2RlID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGVuY1tjb2RlXSA9IGk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICB2YXIgblJhbmdlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGNvZGUgPSAxO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBuUmFuZ2VzOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIHZhciBuTGVmdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gZmlyc3Q7IGogPD0gZmlyc3QgKyBuTGVmdDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgZW5jW2pdID0gY29kZTtcbiAgICAgICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ2ZmRW5jb2RpbmcoZW5jLCBjaGFyc2V0KTtcbn1cblxuLy8gVGFrZSBpbiBjaGFyc3RyaW5nIGNvZGUgYW5kIHJldHVybiBhIEdseXBoIG9iamVjdC5cbi8vIFRoZSBlbmNvZGluZyBpcyBkZXNjcmliZWQgaW4gdGhlIFR5cGUgMiBDaGFyc3RyaW5nIEZvcm1hdFxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFyc3RyMi5odG1cbmZ1bmN0aW9uIHBhcnNlQ0ZGQ2hhcnN0cmluZyhmb250LCBnbHlwaCwgY29kZSkge1xuICAgIHZhciBjMXg7XG4gICAgdmFyIGMxeTtcbiAgICB2YXIgYzJ4O1xuICAgIHZhciBjMnk7XG4gICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBuU3RlbXMgPSAwO1xuICAgIHZhciBoYXZlV2lkdGggPSBmYWxzZTtcbiAgICB2YXIgb3BlbiA9IGZhbHNlO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIHN1YnJzO1xuICAgIHZhciBzdWJyc0JpYXM7XG4gICAgdmFyIGRlZmF1bHRXaWR0aFg7XG4gICAgdmFyIG5vbWluYWxXaWR0aFg7XG4gICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG4gICAgICAgIHZhciBmZEluZGV4ID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2ZkU2VsZWN0W2dseXBoLmluZGV4XTtcbiAgICAgICAgdmFyIGZkRGljdCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9mZEFycmF5W2ZkSW5kZXhdO1xuICAgICAgICBzdWJycyA9IGZkRGljdC5fc3VicnM7XG4gICAgICAgIHN1YnJzQmlhcyA9IGZkRGljdC5fc3VicnNCaWFzO1xuICAgICAgICBkZWZhdWx0V2lkdGhYID0gZmREaWN0Ll9kZWZhdWx0V2lkdGhYO1xuICAgICAgICBub21pbmFsV2lkdGhYID0gZmREaWN0Ll9ub21pbmFsV2lkdGhYO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YnJzID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX3N1YnJzO1xuICAgICAgICBzdWJyc0JpYXMgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fc3VicnNCaWFzO1xuICAgICAgICBkZWZhdWx0V2lkdGhYID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2RlZmF1bHRXaWR0aFg7XG4gICAgICAgIG5vbWluYWxXaWR0aFggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fbm9taW5hbFdpZHRoWDtcbiAgICB9XG4gICAgdmFyIHdpZHRoID0gZGVmYXVsdFdpZHRoWDtcblxuICAgIGZ1bmN0aW9uIG5ld0NvbnRvdXIoeCwgeSkge1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHAubW92ZVRvKHgsIHkpO1xuICAgICAgICBvcGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0ZW1zKCkge1xuICAgICAgICB2YXIgaGFzV2lkdGhBcmc7XG5cbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBzdGVtIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgaXMgYWx3YXlzIGV2ZW4uXG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB1bmV2ZW4sIHRoYXQgbWVhbnMgYSB3aWR0aCBpcyBzcGVjaWZpZWQuXG4gICAgICAgIGhhc1dpZHRoQXJnID0gc3RhY2subGVuZ3RoICUgMiAhPT0gMDtcbiAgICAgICAgaWYgKGhhc1dpZHRoQXJnICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgIH1cblxuICAgICAgICBuU3RlbXMgKz0gc3RhY2subGVuZ3RoID4+IDE7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoY29kZSkge1xuICAgICAgICB2YXIgYjE7XG4gICAgICAgIHZhciBiMjtcbiAgICAgICAgdmFyIGIzO1xuICAgICAgICB2YXIgYjQ7XG4gICAgICAgIHZhciBjb2RlSW5kZXg7XG4gICAgICAgIHZhciBzdWJyQ29kZTtcbiAgICAgICAgdmFyIGpweDtcbiAgICAgICAgdmFyIGpweTtcbiAgICAgICAgdmFyIGMzeDtcbiAgICAgICAgdmFyIGMzeTtcbiAgICAgICAgdmFyIGM0eDtcbiAgICAgICAgdmFyIGM0eTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgY29kZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2ID0gY29kZVtpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gaHN0ZW1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIHZzdGVtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiAvLyB2bW92ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiAvLyBybGluZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogLy8gaGxpbmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiAvLyB2bGluZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6IC8vIHJyY3VydmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogLy8gY2FsbHN1YnJcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gc3RhY2sucG9wKCkgKyBzdWJyc0JpYXM7XG4gICAgICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gc3VicnNbY29kZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZShzdWJyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDExOiAvLyByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IC8vIGZsZXggb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIHYgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNTogLy8gZmxleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHkzIGR4NCBkeTQgZHg1IGR5NSBkeDYgZHk2IGZkIGZsZXggKDEyIDM1KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0ganB5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjNHkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5zaGlmdCgpOyAvLyBmbGV4IGRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNDogLy8gaGZsZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHgyIGR5MiBkeDMgZHg0IGR4NSBkeDYgaGZsZXggKDEyIDM0KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5OyAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnk7IC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGMyeTsgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0geTsgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzY6IC8vIGhmbGV4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHg0IGR4NSBkeTUgZHg2IGhmbGV4MSAoMTIgMzYpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnk7IC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGMyeTsgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6IC8vIGZsZXgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeTMgZHg0IGR5NCBkeDUgZHk1IGQ2IGZsZXgxICgxMiAzNykgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTsgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGpweSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7IC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7IC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjNHggLSB4KSA+IE1hdGguYWJzKGM0eSAtIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjNHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdHbHlwaCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdseXBoLmluZGV4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6IHVua25vd24gb3BlcmF0b3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMjAwICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDogLy8gZW5kY2hhclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxODogLy8gaHN0ZW1obVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTk6IC8vIGhpbnRtYXNrXG4gICAgICAgICAgICAgICAgY2FzZSAyMDogLy8gY250cm1hc2tcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IChuU3RlbXMgKyA3KSA+PiAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIxOiAvLyBybW92ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAyICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMjogLy8gaG1vdmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM6IC8vIHZzdGVtaG1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0OiAvLyByY3VydmVsaW5lXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjU6IC8vIHJsaW5lY3VydmVcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI2OiAvLyB2dmN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gaGhjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjg6IC8vIHNob3J0aW50XG4gICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgoKGIxIDw8IDI0KSB8IChiMiA8PCAxNikpID4+IDE2KTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI5OiAvLyBjYWxsZ3N1YnJcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gc3RhY2sucG9wKCkgKyBmb250LmdzdWJyc0JpYXM7XG4gICAgICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5nc3VicnNbY29kZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZShzdWJyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMwOiAvLyB2aGN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzE6IC8vIGh2Y3VydmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0dseXBoICcgKyBnbHlwaC5pbmRleCArICc6IHVua25vd24gb3BlcmF0b3IgJyArIHZcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI0Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh2IC0gMTM5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjUxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCh2IC0gMjQ3KSAqIDI1NiArIGIxICsgMTA4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKC0odiAtIDI1MSkgKiAyNTYgLSBiMSAtIDEwOCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGNvZGVbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYjMgPSBjb2RlW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGI0ID0gY29kZVtpICsgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSB8IChiMyA8PCA4KSB8IGI0KSAvIDY1NTM2XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZShjb2RlKTtcblxuICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNGRkZEU2VsZWN0KGRhdGEsIHN0YXJ0LCBuR2x5cGhzLCBmZEFycmF5Q291bnQpIHtcbiAgICB2YXIgZmRTZWxlY3QgPSBbXTtcbiAgICB2YXIgZmRJbmRleDtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGZvcm1hdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMCkge1xuICAgICAgICAvLyBTaW1wbGUgbGlzdCBvZiBuR2x5cGhzIGVsZW1lbnRzXG4gICAgICAgIGZvciAodmFyIGlHaWQgPSAwOyBpR2lkIDwgbkdseXBoczsgaUdpZCsrKSB7XG4gICAgICAgICAgICBmZEluZGV4ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGlmIChmZEluZGV4ID49IGZkQXJyYXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ0NGRiB0YWJsZSBDSUQgRm9udCBGRFNlbGVjdCBoYXMgYmFkIEZEIGluZGV4IHZhbHVlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZmRJbmRleCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIChGRCBjb3VudCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZkQXJyYXlDb3VudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmRTZWxlY3QucHVzaChmZEluZGV4KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzKSB7XG4gICAgICAgIC8vIFJhbmdlc1xuICAgICAgICB2YXIgblJhbmdlcyA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICB2YXIgZmlyc3QgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgaWYgKGZpcnN0ICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIGluaXRpYWwgR0lEICcgK1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgZm9yICh2YXIgaVJhbmdlID0gMDsgaVJhbmdlIDwgblJhbmdlczsgaVJhbmdlKyspIHtcbiAgICAgICAgICAgIGZkSW5kZXggPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgbmV4dCA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICAgICAgaWYgKGZkSW5kZXggPj0gZmRBcnJheUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnQ0ZGIHRhYmxlIENJRCBGb250IEZEU2VsZWN0IGhhcyBiYWQgRkQgaW5kZXggdmFsdWUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBmZEluZGV4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKEZEIGNvdW50ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZmRBcnJheUNvdW50ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA+IG5HbHlwaHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgZm9ybWF0IDMgcmFuZ2UgaGFzIGJhZCBHSUQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyBmaXJzdCA8IG5leHQ7IGZpcnN0KyspIHtcbiAgICAgICAgICAgICAgICBmZFNlbGVjdC5wdXNoKGZkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3QgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0ICE9PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIGZpbmFsIEdJRCAnICtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgdGFibGUgaGFzIHVuc3VwcG9ydGVkIGZvcm1hdCAnICsgZm9ybWF0XG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBmZFNlbGVjdDtcbn1cblxuLy8gUGFyc2UgdGhlIGBDRkZgIHRhYmxlLCB3aGljaCBjb250YWlucyB0aGUgZ2x5cGggb3V0bGluZXMgaW4gUG9zdFNjcmlwdCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRlRhYmxlKGRhdGEsIHN0YXJ0LCBmb250LCBvcHQpIHtcbiAgICBmb250LnRhYmxlcy5jZmYgPSB7fTtcbiAgICB2YXIgaGVhZGVyID0gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBuYW1lSW5kZXggPSBwYXJzZUNGRkluZGV4KFxuICAgICAgICBkYXRhLFxuICAgICAgICBoZWFkZXIuZW5kT2Zmc2V0LFxuICAgICAgICBwYXJzZS5ieXRlc1RvU3RyaW5nXG4gICAgKTtcbiAgICB2YXIgdG9wRGljdEluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBuYW1lSW5kZXguZW5kT2Zmc2V0KTtcbiAgICB2YXIgc3RyaW5nSW5kZXggPSBwYXJzZUNGRkluZGV4KFxuICAgICAgICBkYXRhLFxuICAgICAgICB0b3BEaWN0SW5kZXguZW5kT2Zmc2V0LFxuICAgICAgICBwYXJzZS5ieXRlc1RvU3RyaW5nXG4gICAgKTtcbiAgICB2YXIgZ2xvYmFsU3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdHJpbmdJbmRleC5lbmRPZmZzZXQpO1xuICAgIGZvbnQuZ3N1YnJzID0gZ2xvYmFsU3VickluZGV4Lm9iamVjdHM7XG4gICAgZm9udC5nc3VicnNCaWFzID0gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKGZvbnQuZ3N1YnJzKTtcblxuICAgIHZhciB0b3BEaWN0QXJyYXkgPSBnYXRoZXJDRkZUb3BEaWN0cyhcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHRvcERpY3RJbmRleC5vYmplY3RzLFxuICAgICAgICBzdHJpbmdJbmRleC5vYmplY3RzXG4gICAgKTtcbiAgICBpZiAodG9wRGljdEFycmF5Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNGRiB0YWJsZSBoYXMgdG9vIG1hbnkgZm9udHMgaW4gJ0ZvbnRTZXQnIC0gY291bnQgb2YgZm9udHMgTmFtZUluZGV4Lmxlbmd0aCA9IFwiICtcbiAgICAgICAgICAgICAgICB0b3BEaWN0QXJyYXkubGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHRvcERpY3QgPSB0b3BEaWN0QXJyYXlbMF07XG4gICAgZm9udC50YWJsZXMuY2ZmLnRvcERpY3QgPSB0b3BEaWN0O1xuXG4gICAgaWYgKHRvcERpY3QuX3ByaXZhdGVEaWN0KSB7XG4gICAgICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHRvcERpY3QuX3ByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgICAgIGZvbnQubm9taW5hbFdpZHRoWCA9IHRvcERpY3QuX3ByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFg7XG4gICAgfVxuXG4gICAgaWYgKHRvcERpY3Qucm9zWzBdICE9PSB1bmRlZmluZWQgJiYgdG9wRGljdC5yb3NbMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb250LmlzQ0lERm9udCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG4gICAgICAgIHZhciBmZEFycmF5T2Zmc2V0ID0gdG9wRGljdC5mZEFycmF5O1xuICAgICAgICB2YXIgZmRTZWxlY3RPZmZzZXQgPSB0b3BEaWN0LmZkU2VsZWN0O1xuICAgICAgICBpZiAoZmRBcnJheU9mZnNldCA9PT0gMCB8fCBmZFNlbGVjdE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdGb250IGlzIG1hcmtlZCBhcyBhIENJRCBmb250LCBidXQgRkRBcnJheSBhbmQvb3IgRkRTZWxlY3QgaW5mb3JtYXRpb24gaXMgbWlzc2luZydcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZmRBcnJheU9mZnNldCArPSBzdGFydDtcbiAgICAgICAgdmFyIGZkQXJyYXlJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgZmRBcnJheU9mZnNldCk7XG4gICAgICAgIHZhciBmZEFycmF5ID0gZ2F0aGVyQ0ZGVG9wRGljdHMoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBmZEFycmF5SW5kZXgub2JqZWN0cyxcbiAgICAgICAgICAgIHN0cmluZ0luZGV4Lm9iamVjdHNcbiAgICAgICAgKTtcbiAgICAgICAgdG9wRGljdC5fZmRBcnJheSA9IGZkQXJyYXk7XG4gICAgICAgIGZkU2VsZWN0T2Zmc2V0ICs9IHN0YXJ0O1xuICAgICAgICB0b3BEaWN0Ll9mZFNlbGVjdCA9IHBhcnNlQ0ZGRkRTZWxlY3QoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgZmRTZWxlY3RPZmZzZXQsXG4gICAgICAgICAgICBmb250Lm51bUdseXBocyxcbiAgICAgICAgICAgIGZkQXJyYXkubGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHByaXZhdGVEaWN0T2Zmc2V0ID0gc3RhcnQgKyB0b3BEaWN0LnByaXZhdGVbMV07XG4gICAgdmFyIHByaXZhdGVEaWN0ID0gcGFyc2VDRkZQcml2YXRlRGljdChcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcHJpdmF0ZURpY3RPZmZzZXQsXG4gICAgICAgIHRvcERpY3QucHJpdmF0ZVswXSxcbiAgICAgICAgc3RyaW5nSW5kZXgub2JqZWN0c1xuICAgICk7XG4gICAgZm9udC5kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICBmb250Lm5vbWluYWxXaWR0aFggPSBwcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuXG4gICAgaWYgKHByaXZhdGVEaWN0LnN1YnJzICE9PSAwKSB7XG4gICAgICAgIHZhciBzdWJyT2Zmc2V0ID0gcHJpdmF0ZURpY3RPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcbiAgICAgICAgdmFyIHN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3Vick9mZnNldCk7XG4gICAgICAgIGZvbnQuc3VicnMgPSBzdWJySW5kZXgub2JqZWN0cztcbiAgICAgICAgZm9udC5zdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5zdWJycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5zdWJycyA9IFtdO1xuICAgICAgICBmb250LnN1YnJzQmlhcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gT2Zmc2V0cyBpbiB0aGUgdG9wIGRpY3QgYXJlIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIENGRiBkYXRhLCBzbyBhZGQgdGhlIENGRiBzdGFydCBvZmZzZXQuXG4gICAgdmFyIGNoYXJTdHJpbmdzSW5kZXg7XG4gICAgaWYgKG9wdC5sb3dNZW1vcnkpIHtcbiAgICAgICAgY2hhclN0cmluZ3NJbmRleCA9IHBhcnNlQ0ZGSW5kZXhMb3dNZW1vcnkoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc3RhcnQgKyB0b3BEaWN0LmNoYXJTdHJpbmdzXG4gICAgICAgICk7XG4gICAgICAgIGZvbnQubkdseXBocyA9IGNoYXJTdHJpbmdzSW5kZXgub2Zmc2V0cy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hhclN0cmluZ3NJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RhcnQgKyB0b3BEaWN0LmNoYXJTdHJpbmdzKTtcbiAgICAgICAgZm9udC5uR2x5cGhzID0gY2hhclN0cmluZ3NJbmRleC5vYmplY3RzLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgY2hhcnNldCA9IHBhcnNlQ0ZGQ2hhcnNldChcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc3RhcnQgKyB0b3BEaWN0LmNoYXJzZXQsXG4gICAgICAgIGZvbnQubkdseXBocyxcbiAgICAgICAgc3RyaW5nSW5kZXgub2JqZWN0c1xuICAgICk7XG4gICAgaWYgKHRvcERpY3QuZW5jb2RpbmcgPT09IDApIHtcbiAgICAgICAgLy8gU3RhbmRhcmQgZW5jb2RpbmdcbiAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IG5ldyBDZmZFbmNvZGluZyhjZmZTdGFuZGFyZEVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9IGVsc2UgaWYgKHRvcERpY3QuZW5jb2RpbmcgPT09IDEpIHtcbiAgICAgICAgLy8gRXhwZXJ0IGVuY29kaW5nXG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBuZXcgQ2ZmRW5jb2RpbmcoY2ZmRXhwZXJ0RW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBwYXJzZUNGRkVuY29kaW5nKFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0ICsgdG9wRGljdC5lbmNvZGluZyxcbiAgICAgICAgICAgIGNoYXJzZXRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBQcmVmZXIgdGhlIENNQVAgZW5jb2RpbmcgdG8gdGhlIENGRiBlbmNvZGluZy5cbiAgICBmb250LmVuY29kaW5nID0gZm9udC5lbmNvZGluZyB8fCBmb250LmNmZkVuY29kaW5nO1xuXG4gICAgZm9udC5nbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG4gICAgaWYgKG9wdC5sb3dNZW1vcnkpIHtcbiAgICAgICAgZm9udC5fcHVzaCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgY2hhclN0cmluZyA9IGdldENmZkluZGV4T2JqZWN0KFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgY2hhclN0cmluZ3NJbmRleC5vZmZzZXRzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgc3RhcnQgKyB0b3BEaWN0LmNoYXJTdHJpbmdzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm9udC5nbHlwaHMucHVzaChcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGdseXBoc2V0LmNmZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlQ0ZGQ2hhcnN0cmluZywgY2hhclN0cmluZylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250Lm5HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNoYXJTdHJpbmcgPSBjaGFyU3RyaW5nc0luZGV4Lm9iamVjdHNbaV07XG4gICAgICAgICAgICBmb250LmdseXBocy5wdXNoKFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgZ2x5cGhzZXQuY2ZmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VDRkZDaGFyc3RyaW5nLCBjaGFyU3RyaW5nKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGNmZiA9IHsgcGFyc2U6IHBhcnNlQ0ZGVGFibGUgfTtcblxuLy8gVGhlIGBmdmFyYCB0YWJsZSBzdG9yZXMgZm9udCB2YXJpYXRpb24gYXhlcyBhbmQgaW5zdGFuY2VzLlxuXG5mdW5jdGlvbiBwYXJzZUZ2YXJBeGlzKGRhdGEsIHN0YXJ0LCBuYW1lcykge1xuICAgIHZhciBheGlzID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBheGlzLnRhZyA9IHAucGFyc2VUYWcoKTtcbiAgICBheGlzLm1pblZhbHVlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgYXhpcy5kZWZhdWx0VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBheGlzLm1heFZhbHVlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgcC5za2lwKCd1U2hvcnQnLCAxKTsgLy8gcmVzZXJ2ZWQgZm9yIGZsYWdzOyBubyB2YWx1ZXMgZGVmaW5lZFxuICAgIGF4aXMubmFtZSA9IG5hbWVzW3AucGFyc2VVU2hvcnQoKV0gfHwge307XG4gICAgcmV0dXJuIGF4aXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnZhckluc3RhbmNlKGRhdGEsIHN0YXJ0LCBheGVzLCBuYW1lcykge1xuICAgIHZhciBpbnN0ID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBpbnN0Lm5hbWUgPSBuYW1lc1twLnBhcnNlVVNob3J0KCldIHx8IHt9O1xuICAgIHAuc2tpcCgndVNob3J0JywgMSk7IC8vIHJlc2VydmVkIGZvciBmbGFnczsgbm8gdmFsdWVzIGRlZmluZWRcblxuICAgIGluc3QuY29vcmRpbmF0ZXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW5zdC5jb29yZGluYXRlc1theGVzW2ldLnRhZ10gPSBwLnBhcnNlRml4ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VGdmFyVGFibGUoZGF0YSwgc3RhcnQsIG5hbWVzKSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgIHRhYmxlVmVyc2lvbiA9PT0gMHgwMDAxMDAwMCxcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIGZ2YXIgdGFibGUgdmVyc2lvbi4nXG4gICAgKTtcbiAgICB2YXIgb2Zmc2V0VG9EYXRhID0gcC5wYXJzZU9mZnNldDE2KCk7XG4gICAgLy8gU2tpcCBjb3VudFNpemVQYWlycy5cbiAgICBwLnNraXAoJ3VTaG9ydCcsIDEpO1xuICAgIHZhciBheGlzQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGF4aXNTaXplID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBpbnN0YW5jZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBpbnN0YW5jZVNpemUgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICB2YXIgYXhlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpc0NvdW50OyBpKyspIHtcbiAgICAgICAgYXhlcy5wdXNoKFxuICAgICAgICAgICAgcGFyc2VGdmFyQXhpcyhkYXRhLCBzdGFydCArIG9mZnNldFRvRGF0YSArIGkgKiBheGlzU2l6ZSwgbmFtZXMpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuICAgIHZhciBpbnN0YW5jZVN0YXJ0ID0gc3RhcnQgKyBvZmZzZXRUb0RhdGEgKyBheGlzQ291bnQgKiBheGlzU2l6ZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluc3RhbmNlQ291bnQ7IGorKykge1xuICAgICAgICBpbnN0YW5jZXMucHVzaChcbiAgICAgICAgICAgIHBhcnNlRnZhckluc3RhbmNlKFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCArIGogKiBpbnN0YW5jZVNpemUsXG4gICAgICAgICAgICAgICAgYXhlcyxcbiAgICAgICAgICAgICAgICBuYW1lc1xuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7IGF4ZXM6IGF4ZXMsIGluc3RhbmNlczogaW5zdGFuY2VzIH07XG59XG5cbnZhciBmdmFyID0geyBwYXJzZTogcGFyc2VGdmFyVGFibGUgfTtcblxuLy8gVGhlIGBHREVGYCB0YWJsZSBjb250YWlucyB2YXJpb3VzIGdseXBoIHByb3BlcnRpZXNcblxudmFyIGF0dGFjaExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgYXR0YWNoUG9pbnRzOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIudVNob3J0TGlzdCkpXG4gICAgfTtcbn07XG5cbnZhciBjYXJldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChmb3JtYXQgPT09IDEgfHwgZm9ybWF0ID09PSAyIHx8IGZvcm1hdCA9PT0gMyxcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIENhcmV0VmFsdWUgdGFibGUgdmVyc2lvbi4nKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7IGNvb3JkaW5hdGU6IHRoaXMucGFyc2VTaG9ydCgpIH07XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgcG9pbnRpbmRleDogdGhpcy5wYXJzZVNob3J0KCkgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMykge1xuICAgICAgICAvLyBEZXZpY2UgLyBWYXJpYXRpb24gSW5kZXggdGFibGVzIHVuc3VwcG9ydGVkXG4gICAgICAgIHJldHVybiB7IGNvb3JkaW5hdGU6IHRoaXMucGFyc2VTaG9ydCgpIH07XG4gICAgfVxufTtcblxudmFyIGxpZ0dseXBoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKGNhcmV0VmFsdWUpKTtcbn07XG5cbnZhciBsaWdDYXJldExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgbGlnR2x5cGhzOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihsaWdHbHlwaCkpXG4gICAgfTtcbn07XG5cbnZhciBtYXJrR2x5cGhTZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wYXJzZVVTaG9ydCgpOyAvLyBWZXJzaW9uXG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpO1xufTtcblxuZnVuY3Rpb24gcGFyc2VHREVGVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIHAgPSBuZXcgUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oMSk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4yIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4zLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgR0RFRiB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIHZhciBnZGVmID0ge1xuICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgIGNsYXNzRGVmOiBwLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICBhdHRhY2hMaXN0OiBwLnBhcnNlUG9pbnRlcihhdHRhY2hMaXN0KSxcbiAgICAgICAgbGlnQ2FyZXRMaXN0OiBwLnBhcnNlUG9pbnRlcihsaWdDYXJldExpc3QpLFxuICAgICAgICBtYXJrQXR0YWNoQ2xhc3NEZWY6IHAucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZilcbiAgICB9O1xuICAgIGlmICh0YWJsZVZlcnNpb24gPj0gMS4yKSB7XG4gICAgICAgIGdkZWYubWFya0dseXBoU2V0cyA9IHAucGFyc2VQb2ludGVyKG1hcmtHbHlwaFNldHMpO1xuICAgIH1cbiAgICByZXR1cm4gZ2RlZjtcbn1cbnZhciBnZGVmID0geyBwYXJzZTogcGFyc2VHREVGVGFibGUgfTtcblxuLy8gVGhlIGBHUE9TYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG5cbnZhciBzdWJ0YWJsZVBhcnNlcnMgPSBuZXcgQXJyYXkoMTApOyAvLyBzdWJ0YWJsZVBhcnNlcnNbMF0gaXMgdW51c2VkXG5cbi8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI2xvb2t1cC10eXBlLTEtc2luZ2xlLWFkanVzdG1lbnQtcG9zaXRpb25pbmctc3VidGFibGVcbi8vIHRoaXMgPSBQYXJzZXIgaW5zdGFuY2VcbnN1YnRhYmxlUGFyc2Vyc1sxXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMSgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHBvc2Zvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAocG9zZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQoKSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHBvc2Zvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zRm9ybWF0OiAyLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICB2YWx1ZXM6IHRoaXMucGFyc2VWYWx1ZVJlY29yZExpc3QoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJzB4JyArXG4gICAgICAgICAgICBzdGFydC50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgJzogR1BPUyBsb29rdXAgdHlwZSAxIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nXG4gICAgKTtcbn07XG5cbi8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI2xvb2t1cC10eXBlLTItcGFpci1hZGp1c3RtZW50LXBvc2l0aW9uaW5nLXN1YnRhYmxlXG5zdWJ0YWJsZVBhcnNlcnNbMl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDIoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBwb3NGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICBwb3NGb3JtYXQgPT09IDEgfHwgcG9zRm9ybWF0ID09PSAyLFxuICAgICAgICAnMHgnICtcbiAgICAgICAgICAgIHN0YXJ0LnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAnOiBHUE9TIGxvb2t1cCB0eXBlIDIgZm9ybWF0IG11c3QgYmUgMSBvciAyLidcbiAgICApO1xuICAgIHZhciBjb3ZlcmFnZSA9IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSk7XG4gICAgdmFyIHZhbHVlRm9ybWF0MSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgdmFsdWVGb3JtYXQyID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChwb3NGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgLy8gQWRqdXN0bWVudHMgZm9yIEdseXBoIFBhaXJzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NGb3JtYXQ6IHBvc0Zvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlOiBjb3ZlcmFnZSxcbiAgICAgICAgICAgIHZhbHVlRm9ybWF0MTogdmFsdWVGb3JtYXQxLFxuICAgICAgICAgICAgdmFsdWVGb3JtYXQyOiB2YWx1ZUZvcm1hdDIsXG4gICAgICAgICAgICBwYWlyU2V0czogdGhpcy5wYXJzZUxpc3QoXG4gICAgICAgICAgICAgICAgUGFyc2VyLnBvaW50ZXIoXG4gICAgICAgICAgICAgICAgICAgIFBhcnNlci5saXN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFpclZhbHVlUmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kR2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTE6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMjogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwb3NGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgdmFyIGNsYXNzRGVmMSA9IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZik7XG4gICAgICAgIHZhciBjbGFzc0RlZjIgPSB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpO1xuICAgICAgICB2YXIgY2xhc3MxQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBjbGFzczJDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIENsYXNzIFBhaXIgQWRqdXN0bWVudFxuICAgICAgICAgICAgcG9zRm9ybWF0OiBwb3NGb3JtYXQsXG4gICAgICAgICAgICBjb3ZlcmFnZTogY292ZXJhZ2UsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdDE6IHZhbHVlRm9ybWF0MSxcbiAgICAgICAgICAgIHZhbHVlRm9ybWF0MjogdmFsdWVGb3JtYXQyLFxuICAgICAgICAgICAgY2xhc3NEZWYxOiBjbGFzc0RlZjEsXG4gICAgICAgICAgICBjbGFzc0RlZjI6IGNsYXNzRGVmMixcbiAgICAgICAgICAgIGNsYXNzMUNvdW50OiBjbGFzczFDb3VudCxcbiAgICAgICAgICAgIGNsYXNzMkNvdW50OiBjbGFzczJDb3VudCxcbiAgICAgICAgICAgIGNsYXNzUmVjb3JkczogdGhpcy5wYXJzZUxpc3QoXG4gICAgICAgICAgICAgICAgY2xhc3MxQ291bnQsXG4gICAgICAgICAgICAgICAgUGFyc2VyLmxpc3QoY2xhc3MyQ291bnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMTogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTI6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdDIpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbnN1YnRhYmxlUGFyc2Vyc1szXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMygpIHtcbiAgICByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDMgbm90IHN1cHBvcnRlZCcgfTtcbn07XG5zdWJ0YWJsZVBhcnNlcnNbNF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDQoKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA0IG5vdCBzdXBwb3J0ZWQnIH07XG59O1xuc3VidGFibGVQYXJzZXJzWzVdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA1KCkge1xuICAgIHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNSBub3Qgc3VwcG9ydGVkJyB9O1xufTtcbnN1YnRhYmxlUGFyc2Vyc1s2XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNigpIHtcbiAgICByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDYgbm90IHN1cHBvcnRlZCcgfTtcbn07XG5zdWJ0YWJsZVBhcnNlcnNbN10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDcoKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA3IG5vdCBzdXBwb3J0ZWQnIH07XG59O1xuc3VidGFibGVQYXJzZXJzWzhdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA4KCkge1xuICAgIHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgOCBub3Qgc3VwcG9ydGVkJyB9O1xufTtcbnN1YnRhYmxlUGFyc2Vyc1s5XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwOSgpIHtcbiAgICByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDkgbm90IHN1cHBvcnRlZCcgfTtcbn07XG5cbi8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zXG5mdW5jdGlvbiBwYXJzZUdwb3NUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICB2YXIgcCA9IG5ldyBQYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigxKTtcbiAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgdGFibGVWZXJzaW9uID09PSAxIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4xLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgR1BPUyB0YWJsZSB2ZXJzaW9uICcgKyB0YWJsZVZlcnNpb25cbiAgICApO1xuXG4gICAgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcbiAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyksXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMpLFxuICAgICAgICAgICAgdmFyaWF0aW9uczogcC5wYXJzZUZlYXR1cmVWYXJpYXRpb25zTGlzdCgpLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxudmFyIGdwb3MgPSB7IHBhcnNlOiBwYXJzZUdwb3NUYWJsZSB9O1xuXG4vLyBUaGUgYEdTVUJgIHRhYmxlIGNvbnRhaW5zIGxpZ2F0dXJlcywgYW1vbmcgb3RoZXIgdGhpbmdzLlxuXG52YXIgc3VidGFibGVQYXJzZXJzJDEgPSBuZXcgQXJyYXkoOSk7IC8vIHN1YnRhYmxlUGFyc2Vyc1swXSBpcyB1bnVzZWRcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNTU1xuc3VidGFibGVQYXJzZXJzJDFbMV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDEoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBkZWx0YUdseXBoSWQ6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMixcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgc3Vic3RpdHV0ZTogdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgMSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJ1xuICAgICk7XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI01TXG5zdWJ0YWJsZVBhcnNlcnMkMVsyXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMigpIHtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgIHN1YnN0Rm9ybWF0ID09PSAxLFxuICAgICAgICAnR1NVQiBNdWx0aXBsZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJ1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgc2VxdWVuY2VzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoKSxcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNBU1xuc3VidGFibGVQYXJzZXJzJDFbM10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDMoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICBzdWJzdEZvcm1hdCA9PT0gMSxcbiAgICAgICAgJ0dTVUIgQWx0ZXJuYXRlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBhbHRlcm5hdGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoKSxcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNMU1xuc3VidGFibGVQYXJzZXJzJDFbNF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDQoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICBzdWJzdEZvcm1hdCA9PT0gMSxcbiAgICAgICAgJ0dTVUIgbGlnYXR1cmUgdGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJ1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgbGlnYXR1cmVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsaWdHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VVU2hvcnQoKSAtIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgfTtcbn07XG5cbnZhciBsb29rdXBSZWNvcmREZXNjID0ge1xuICAgIHNlcXVlbmNlSW5kZXg6IFBhcnNlci51U2hvcnQsXG4gICAgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0LFxufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNDU0ZcbnN1YnRhYmxlUGFyc2VycyQxWzVdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA1KCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cbiAgICBpZiAoc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgcnVsZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0Q291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGdseXBoQ291bnQgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkRGVzY1xuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGNsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgY2xhc3NTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGdseXBoQ291bnQgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkRGVzY1xuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAzKSB7XG4gICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlczogdGhpcy5wYXJzZUxpc3QoXG4gICAgICAgICAgICAgICAgZ2x5cGhDb3VudCxcbiAgICAgICAgICAgICAgICBQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3Qoc3Vic3RDb3VudCwgbG9va3VwUmVjb3JkRGVzYyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSA1IGZvcm1hdCBtdXN0IGJlIDEsIDIgb3IgMy4nXG4gICAgKTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQ0NcbnN1YnRhYmxlUGFyc2VycyQxWzZdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA2KCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgY2hhaW5SdWxlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYWNrdHJhY2s6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlU2hvcnQoKSAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBsb29rYWhlYWQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMixcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgYmFja3RyYWNrQ2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgICAgICBpbnB1dENsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgbG9va2FoZWFkQ2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgICAgICBjaGFpbkNsYXNzU2V0OiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2t0cmFjazogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VTaG9ydCgpIC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZDogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYyksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAzLFxuICAgICAgICAgICAgYmFja3RyYWNrQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgaW5wdXRDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgICAgICBsb29rYWhlYWRDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChsb29rdXBSZWNvcmREZXNjKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDYgZm9ybWF0IG11c3QgYmUgMSwgMiBvciAzLidcbiAgICApO1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNFU1xuc3VidGFibGVQYXJzZXJzJDFbN10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDcoKSB7XG4gICAgLy8gRXh0ZW5zaW9uIFN1YnN0aXR1dGlvbiBzdWJ0YWJsZVxuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgc3Vic3RGb3JtYXQgPT09IDEsXG4gICAgICAgICdHU1VCIEV4dGVuc2lvbiBTdWJzdGl0dXRpb24gc3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJ1xuICAgICk7XG4gICAgdmFyIGV4dGVuc2lvbkxvb2t1cFR5cGUgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGV4dGVuc2lvblBhcnNlciA9IG5ldyBQYXJzZXIoXG4gICAgICAgIHRoaXMuZGF0YSxcbiAgICAgICAgdGhpcy5vZmZzZXQgKyB0aGlzLnBhcnNlVUxvbmcoKVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgIGxvb2t1cFR5cGU6IGV4dGVuc2lvbkxvb2t1cFR5cGUsXG4gICAgICAgIGV4dGVuc2lvbjogc3VidGFibGVQYXJzZXJzJDFbZXh0ZW5zaW9uTG9va3VwVHlwZV0uY2FsbChleHRlbnNpb25QYXJzZXIpLFxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI1JDQ1NcbnN1YnRhYmxlUGFyc2VycyQxWzhdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA4KCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChcbiAgICAgICAgc3Vic3RGb3JtYXQgPT09IDEsXG4gICAgICAgICdHU1VCIFJldmVyc2UgQ2hhaW5pbmcgQ29udGV4dHVhbCBTaW5nbGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMSdcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIGJhY2t0cmFja0NvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgbG9va2FoZWFkQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICBzdWJzdGl0dXRlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9nc3ViLmh0bVxuZnVuY3Rpb24gcGFyc2VHc3ViVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIHAgPSBuZXcgUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oMSk7XG4gICAgY2hlY2suYXJndW1lbnQoXG4gICAgICAgIHRhYmxlVmVyc2lvbiA9PT0gMSB8fCB0YWJsZVZlcnNpb24gPT09IDEuMSxcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIEdTVUIgdGFibGUgdmVyc2lvbi4nXG4gICAgKTtcbiAgICBpZiAodGFibGVWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzJDEpLFxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzJDEpLFxuICAgICAgICAgICAgdmFyaWF0aW9uczogcC5wYXJzZUZlYXR1cmVWYXJpYXRpb25zTGlzdCgpLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxudmFyIGdzdWIgPSB7IHBhcnNlOiBwYXJzZUdzdWJUYWJsZSB9O1xuXG4vLyBUaGUgYGhlYWRgIHRhYmxlIGNvbnRhaW5zIGdsb2JhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZm9udC5cblxuLy8gUGFyc2UgdGhlIGhlYWRlciBgaGVhZGAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlSGVhZFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIGhlYWQgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGhlYWQudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgaGVhZC5mb250UmV2aXNpb24gPSBNYXRoLnJvdW5kKHAucGFyc2VGaXhlZCgpICogMTAwMCkgLyAxMDAwO1xuICAgIGhlYWQuY2hlY2tTdW1BZGp1c3RtZW50ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgaGVhZC5tYWdpY051bWJlciA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KFxuICAgICAgICBoZWFkLm1hZ2ljTnVtYmVyID09PSAweDVmMGYzY2Y1LFxuICAgICAgICAnRm9udCBoZWFkZXIgaGFzIHdyb25nIG1hZ2ljIG51bWJlci4nXG4gICAgKTtcbiAgICBoZWFkLmZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQudW5pdHNQZXJFbSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmNyZWF0ZWQgPSBwLnBhcnNlTG9uZ0RhdGVUaW1lKCk7XG4gICAgaGVhZC5tb2RpZmllZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICBoZWFkLnhNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLm1hY1N0eWxlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQubG93ZXN0UmVjUFBFTSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmZvbnREaXJlY3Rpb25IaW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5pbmRleFRvTG9jRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5nbHlwaERhdGFGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICByZXR1cm4gaGVhZDtcbn1cblxudmFyIGhlYWQgPSB7IHBhcnNlOiBwYXJzZUhlYWRUYWJsZSB9O1xuXG4vLyBUaGUgYGhoZWFgIHRhYmxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGZvciBob3Jpem9udGFsIGxheW91dC5cblxuLy8gUGFyc2UgdGhlIGhvcml6b250YWwgaGVhZGVyIGBoaGVhYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VIaGVhVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGhlYSA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgaGhlYS52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBoaGVhLmFzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5kZXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmxpbmVHYXAgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmFkdmFuY2VXaWR0aE1heCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoaGVhLm1pbkxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubWluUmlnaHRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEueE1heEV4dGVudCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRTbG9wZVJpc2UgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmNhcmV0U2xvcGVSdW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmNhcmV0T2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcC5yZWxhdGl2ZU9mZnNldCArPSA4O1xuICAgIGhoZWEubWV0cmljRGF0YUZvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubnVtYmVyT2ZITWV0cmljcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICByZXR1cm4gaGhlYTtcbn1cblxudmFyIGhoZWEgPSB7IHBhcnNlOiBwYXJzZUhoZWFUYWJsZSB9O1xuXG4vLyBUaGUgYGhtdHhgIHRhYmxlIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG5cbmZ1bmN0aW9uIHBhcnNlSG10eFRhYmxlQWxsKGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMsIGdseXBocykge1xuICAgIHZhciBhZHZhbmNlV2lkdGg7XG4gICAgdmFyIGxlZnRTaWRlQmVhcmluZztcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZvbnQgaXMgbW9ub3NwYWNlZCwgb25seSBvbmUgZW50cnkgaXMgbmVlZGVkLiBUaGlzIGxhc3QgZW50cnkgYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBnbHlwaHMuXG4gICAgICAgIGlmIChpIDwgbnVtTWV0cmljcykge1xuICAgICAgICAgICAgYWR2YW5jZVdpZHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgbGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICBnbHlwaC5hZHZhbmNlV2lkdGggPSBhZHZhbmNlV2lkdGg7XG4gICAgICAgIGdseXBoLmxlZnRTaWRlQmVhcmluZyA9IGxlZnRTaWRlQmVhcmluZztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlSG10eFRhYmxlT25Mb3dNZW1vcnkoZm9udCwgZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocykge1xuICAgIGZvbnQuX2htdHhUYWJsZURhdGEgPSB7fTtcblxuICAgIHZhciBhZHZhbmNlV2lkdGg7XG4gICAgdmFyIGxlZnRTaWRlQmVhcmluZztcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZvbnQgaXMgbW9ub3NwYWNlZCwgb25seSBvbmUgZW50cnkgaXMgbmVlZGVkLiBUaGlzIGxhc3QgZW50cnkgYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBnbHlwaHMuXG4gICAgICAgIGlmIChpIDwgbnVtTWV0cmljcykge1xuICAgICAgICAgICAgYWR2YW5jZVdpZHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgbGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb250Ll9obXR4VGFibGVEYXRhW2ldID0ge1xuICAgICAgICAgICAgYWR2YW5jZVdpZHRoOiBhZHZhbmNlV2lkdGgsXG4gICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmc6IGxlZnRTaWRlQmVhcmluZyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIHRoZSBgaG10eGAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIGF1Z21lbnRzIHRoZSBnbHlwaCBhcnJheSwgYWRkaW5nIHRoZSBhZHZhbmNlV2lkdGggYW5kIGxlZnRTaWRlQmVhcmluZyB0byBlYWNoIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VIbXR4VGFibGUoZm9udCwgZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocywgZ2x5cGhzLCBvcHQpIHtcbiAgICBpZiAob3B0Lmxvd01lbW9yeSlcbiAgICAgICAgeyBwYXJzZUhtdHhUYWJsZU9uTG93TWVtb3J5KGZvbnQsIGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMpOyB9XG4gICAgZWxzZSB7IHBhcnNlSG10eFRhYmxlQWxsKGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMsIGdseXBocyk7IH1cbn1cblxudmFyIGhtdHggPSB7IHBhcnNlOiBwYXJzZUhtdHhUYWJsZSB9O1xuXG4vLyBUaGUgYGtlcm5gIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMuXG5cbmZ1bmN0aW9uIHBhcnNlV2luZG93c0tlcm5UYWJsZShwKSB7XG4gICAgdmFyIHBhaXJzID0ge307XG4gICAgLy8gU2tpcCBuVGFibGVzLlxuICAgIHAuc2tpcCgndVNob3J0Jyk7XG4gICAgdmFyIHN1YnRhYmxlVmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJ0YWJsZVZlcnNpb24gPT09IDAsICdVbnN1cHBvcnRlZCBrZXJuIHN1Yi10YWJsZSB2ZXJzaW9uLicpO1xuICAgIC8vIFNraXAgc3VidGFibGVMZW5ndGgsIHN1YnRhYmxlQ292ZXJhZ2VcbiAgICBwLnNraXAoJ3VTaG9ydCcsIDIpO1xuICAgIHZhciBuUGFpcnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgLy8gU2tpcCBzZWFyY2hSYW5nZSwgZW50cnlTZWxlY3RvciwgcmFuZ2VTaGlmdC5cbiAgICBwLnNraXAoJ3VTaG9ydCcsIDMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhaXJzOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGxlZnRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBwYWlyc1tsZWZ0SW5kZXggKyAnLCcgKyByaWdodEluZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWFjS2VyblRhYmxlKHApIHtcbiAgICB2YXIgcGFpcnMgPSB7fTtcbiAgICAvLyBUaGUgTWFjIGtlcm4gdGFibGUgc3RvcmVzIHRoZSB2ZXJzaW9uIGFzIGEgZml4ZWQgKDMyIGJpdHMpIGJ1dCB3ZSBvbmx5IGxvYWRlZCB0aGUgZmlyc3QgMTYgYml0cy5cbiAgICAvLyBTa2lwIHRoZSByZXN0LlxuICAgIHAuc2tpcCgndVNob3J0Jyk7XG4gICAgdmFyIG5UYWJsZXMgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAvL2NoZWNrLmFyZ3VtZW50KG5UYWJsZXMgPT09IDEsICdPbmx5IDEgc3VidGFibGUgaXMgc3VwcG9ydGVkIChnb3QgJyArIG5UYWJsZXMgKyAnKS4nKTtcbiAgICBpZiAoblRhYmxlcyA+IDEpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdPbmx5IHRoZSBmaXJzdCBrZXJuIHN1YnRhYmxlIGlzIHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgcC5za2lwKCd1TG9uZycpO1xuICAgIHZhciBjb3ZlcmFnZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgc3VidGFibGVWZXJzaW9uID0gY292ZXJhZ2UgJiAweEZGO1xuICAgIHAuc2tpcCgndVNob3J0Jyk7XG4gICAgaWYgKHN1YnRhYmxlVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICB2YXIgblBhaXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgICAgICBwLnNraXAoJ3VTaG9ydCcsIDMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWlyczsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbGVmdEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgIHBhaXJzW2xlZnRJbmRleCArICcsJyArIHJpZ2h0SW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xufVxuXG4vLyBQYXJzZSB0aGUgYGtlcm5gIHRhYmxlIHdoaWNoIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMuXG5mdW5jdGlvbiBwYXJzZUtlcm5UYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAodGFibGVWZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVdpbmRvd3NLZXJuVGFibGUocCk7XG4gICAgfSBlbHNlIGlmICh0YWJsZVZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTWFjS2VyblRhYmxlKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2VybiB0YWJsZSB2ZXJzaW9uICgnICsgdGFibGVWZXJzaW9uICsgJykuJyk7XG4gICAgfVxufVxuXG52YXIga2VybiA9IHsgcGFyc2U6IHBhcnNlS2VyblRhYmxlIH07XG5cbi8vIFRoZSBgbHRhZ2AgdGFibGUgc3RvcmVzIElFVEYgQkNQLTQ3IGxhbmd1YWdlIHRhZ3MuIEl0IGFsbG93cyBzdXBwb3J0aW5nXG5cbmZ1bmN0aW9uIHBhcnNlTHRhZ1RhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxLCAnVW5zdXBwb3J0ZWQgbHRhZyB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIC8vIFRoZSAnbHRhZycgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBkZWZpbmUgYW55IGZsYWdzOyBza2lwIHRoZSBmaWVsZC5cbiAgICBwLnNraXAoJ3VMb25nJywgMSk7XG4gICAgdmFyIG51bVRhZ3MgPSBwLnBhcnNlVUxvbmcoKTtcblxuICAgIHZhciB0YWdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWdzOyBpKyspIHtcbiAgICAgICAgdmFyIHRhZyA9ICcnO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQgKyBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGZvciAodmFyIGogPSBvZmZzZXQ7IGogPCBvZmZzZXQgKyBsZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdGFnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YS5nZXRJbnQ4KGopKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhZ3MucHVzaCh0YWcpO1xuICAgIH1cblxuICAgIHJldHVybiB0YWdzO1xufVxuXG52YXIgbHRhZyA9IHsgcGFyc2U6IHBhcnNlTHRhZ1RhYmxlIH07XG5cbi8vIFRoZSBgbG9jYWAgdGFibGUgc3RvcmVzIHRoZSBvZmZzZXRzIHRvIHRoZSBsb2NhdGlvbnMgb2YgdGhlIGdseXBocyBpbiB0aGUgZm9udC5cblxuLy8gUGFyc2UgdGhlIGBsb2NhYCB0YWJsZS4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIG9mZnNldHMgdG8gdGhlIGxvY2F0aW9ucyBvZiB0aGUgZ2x5cGhzIGluIHRoZSBmb250LFxuLy8gcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2x5cGhEYXRhIHRhYmxlLlxuLy8gVGhlIG51bWJlciBvZiBnbHlwaHMgc3RvcmVkIGluIHRoZSBgbG9jYWAgdGFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBgbWF4cGAgdGFibGUgKHVuZGVyIG51bUdseXBocylcbi8vIFRoZSBsb2NhIHRhYmxlIGhhcyB0d28gdmVyc2lvbnM6IGEgc2hvcnQgdmVyc2lvbiB3aGVyZSBvZmZzZXRzIGFyZSBzdG9yZWQgYXMgdVNob3J0cywgYW5kIGEgbG9uZ1xuLy8gdmVyc2lvbiB3aGVyZSBvZmZzZXRzIGFyZSBzdG9yZWQgYXMgdUxvbmdzLiBUaGUgYGhlYWRgIHRhYmxlIHNwZWNpZmllcyB3aGljaCB2ZXJzaW9uIHRvIHVzZVxuLy8gKHVuZGVyIGluZGV4VG9Mb2NGb3JtYXQpLlxuZnVuY3Rpb24gcGFyc2VMb2NhVGFibGUoZGF0YSwgc3RhcnQsIG51bUdseXBocywgc2hvcnRWZXJzaW9uKSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgcGFyc2VGbiA9IHNob3J0VmVyc2lvbiA/IHAucGFyc2VVU2hvcnQgOiBwLnBhcnNlVUxvbmc7XG4gICAgLy8gVGhlcmUgaXMgYW4gZXh0cmEgZW50cnkgYWZ0ZXIgdGhlIGxhc3QgaW5kZXggZWxlbWVudCB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIGxhc3QgZ2x5cGguXG4gICAgLy8gVGhhdCdzIHdoeSB3ZSB1c2UgbnVtR2x5cGhzICsgMS5cbiAgICB2YXIgZ2x5cGhPZmZzZXRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHMgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoT2Zmc2V0ID0gcGFyc2VGbi5jYWxsKHApO1xuICAgICAgICBpZiAoc2hvcnRWZXJzaW9uKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2hvcnQgdGFibGUgdmVyc2lvbiBzdG9yZXMgdGhlIGFjdHVhbCBvZmZzZXQgZGl2aWRlZCBieSAyLlxuICAgICAgICAgICAgZ2x5cGhPZmZzZXQgKj0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoT2Zmc2V0cy5wdXNoKGdseXBoT2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhPZmZzZXRzO1xufVxuXG52YXIgbG9jYSA9IHsgcGFyc2U6IHBhcnNlTG9jYVRhYmxlIH07XG5cbi8vIFRoZSBgbWF4cGAgdGFibGUgZXN0YWJsaXNoZXMgdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgZm9yIHRoZSBmb250LlxuXG4vLyBQYXJzZSB0aGUgbWF4aW11bSBwcm9maWxlIGBtYXhwYCB0YWJsZS5cbmZ1bmN0aW9uIHBhcnNlTWF4cFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIG1heHAgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIG1heHAudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgbWF4cC5udW1HbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKG1heHAudmVyc2lvbiA9PT0gMS4wKSB7XG4gICAgICAgIG1heHAubWF4UG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbnRvdXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvc2l0ZVBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhab25lcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhUd2lsaWdodFBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTdG9yYWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heEZ1bmN0aW9uRGVmcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhJbnN0cnVjdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U3RhY2tFbGVtZW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTaXplT2ZJbnN0cnVjdGlvbnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9uZW50RWxlbWVudHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9uZW50RGVwdGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heHA7XG59XG5cbnZhciBtYXhwID0geyBwYXJzZTogcGFyc2VNYXhwVGFibGUgfTtcblxuLy8gVGhlIGBPUy8yYCB0YWJsZSBjb250YWlucyBtZXRyaWNzIHJlcXVpcmVkIGluIE9wZW5UeXBlIGZvbnRzLlxuXG4vLyBQYXJzZSB0aGUgT1MvMiBhbmQgV2luZG93cyBtZXRyaWNzIGBPUy8yYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VPUzJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBvczIgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIG9zMi52ZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi54QXZnQ2hhcldpZHRoID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnVzV2VpZ2h0Q2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzV2lkdGhDbGFzcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIuZnNUeXBlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0U2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0UG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc0ZhbWlseUNsYXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnBhbm9zZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBvczIucGFub3NlW2ldID0gcC5wYXJzZUJ5dGUoKTtcbiAgICB9XG5cbiAgICBvczIudWxVbmljb2RlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMiA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTMgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2U0ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLmFjaFZlbmRJRCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHAucGFyc2VCeXRlKCksXG4gICAgICAgIHAucGFyc2VCeXRlKCksXG4gICAgICAgIHAucGFyc2VCeXRlKCksXG4gICAgICAgIHAucGFyc2VCeXRlKClcbiAgICApO1xuICAgIG9zMi5mc1NlbGVjdGlvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNGaXJzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNMYXN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0FzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvRGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvTGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dpbkFzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNXaW5EZXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChvczIudmVyc2lvbiA+PSAxKSB7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgfVxuXG4gICAgaWYgKG9zMi52ZXJzaW9uID49IDIpIHtcbiAgICAgICAgb3MyLnN4SGVpZ2h0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIG9zMi5zQ2FwSGVpZ2h0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIG9zMi51c0RlZmF1bHRDaGFyID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvczIudXNCcmVha0NoYXIgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG9zMi51c01heENvbnRlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9zMjtcbn1cblxudmFyIG9zMiA9IHsgcGFyc2U6IHBhcnNlT1MyVGFibGUgfTtcblxuLy8gVGhlIGBwb3N0YCB0YWJsZSBzdG9yZXMgYWRkaXRpb25hbCBQb3N0U2NyaXB0IGluZm9ybWF0aW9uLCBzdWNoIGFzIGdseXBoIG5hbWVzLlxuXG4vLyBQYXJzZSB0aGUgUG9zdFNjcmlwdCBgcG9zdGAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlUG9zdFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHBvc3QgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHBvc3QudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgcG9zdC5pdGFsaWNBbmdsZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIHBvc3QudW5kZXJsaW5lUG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwb3N0LnVuZGVybGluZVRoaWNrbmVzcyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHBvc3QuaXNGaXhlZFBpdGNoID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5taW5NZW1UeXBlNDIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1heE1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWluTWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1heE1lbVR5cGUxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5uYW1lcyA9IFtdO1xuICAgIHN3aXRjaCAocG9zdC52ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcG9zdC5nbHlwaE5hbWVJbmRleCA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9zdC5nbHlwaE5hbWVJbmRleFtpXSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIuNTpcbiAgICAgICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBwb3N0Lm9mZnNldCA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgcG9zdC5vZmZzZXRbaSQxXSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHBvc3Q7XG59XG5cbnZhciBwb3N0ID0geyBwYXJzZTogcGFyc2VQb3N0VGFibGUgfTtcblxuLy8gRGF0YSB0eXBlcyB1c2VkIGluIHRoZSBPcGVuVHlwZSBmb250IGZpbGUuXG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuZGVjb2RlXG4gKiBAY2xhc3NcbiAqL1xudmFyIGRlY29kZSA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1CeXRlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZGVjb2RlLlVURjggPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG51bUJ5dGVzKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcbiAgICB2YXIgbnVtQ2hhcnMgPSBudW1CeXRlcztcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUNoYXJzOyBqKyssIG9mZnNldCArPSAxKSB7XG4gICAgICAgIGNvZGVQb2ludHNbal0gPSBkYXRhLmdldFVpbnQ4KG9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVBvaW50cyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1CeXRlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZGVjb2RlLlVURjE2ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBudW1CeXRlcykge1xuICAgIHZhciBjb2RlUG9pbnRzID0gW107XG4gICAgdmFyIG51bUNoYXJzID0gbnVtQnl0ZXMgLyAyO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQ2hhcnM7IGorKywgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgY29kZVBvaW50c1tqXSA9IGRhdGEuZ2V0VWludDE2KG9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVBvaW50cyk7XG59O1xuXG4vLyBEYXRhIGZvciBjb252ZXJ0aW5nIG9sZCBlaWdodC1iaXQgTWFjaW50b3NoIGVuY29kaW5ncyB0byBVbmljb2RlLlxuLy8gVGhpcyByZXByZXNlbnRhdGlvbiBpcyBvcHRpbWl6ZWQgZm9yIGRlY29kaW5nOyBlbmNvZGluZyBpcyBzbG93ZXJcbi8vIGFuZCBuZWVkcyBtb3JlIG1lbW9yeS4gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCBhbGwgb3BlbnR5cGUuanMgdXNlcnNcbi8vIHdhbnQgdG8gb3BlbiBmb250cywgYnV0IHNhdmluZyBhIGZvbnQgd2lsbCBiZSBjb21wYXJhdGl2ZWx5IHJhcmVcbi8vIHNvIGl0IGNhbiBiZSBtb3JlIGV4cGVuc2l2ZS4gS2V5ZWQgYnkgSUFOQSBjaGFyYWN0ZXIgc2V0IG5hbWUuXG4vL1xuLy8gUHl0aG9uIHNjcmlwdCBmb3IgZ2VuZXJhdGluZyB0aGVzZSBzdHJpbmdzOlxuLy9cbi8vICAgICBzID0gdScnLmpvaW4oW2NocihjKS5kZWNvZGUoJ21hY19ncmVlaycpIGZvciBjIGluIHJhbmdlKDEyOCwgMjU2KV0pXG4vLyAgICAgcHJpbnQocy5lbmNvZGUoJ3V0Zi04JykpXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlaWdodEJpdE1hY0VuY29kaW5ncyA9IHtcbiAgICAneC1tYWMtY3JvYXRpYW4nOiAgLy8gUHl0aG9uOiAnbWFjX2Nyb2F0aWFuJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7FoOKEosK0wqjiiaDFvcOY4oiewrHiiaTiiaXiiIbCteKIguKIkeKIj8Wh4oirwqrCus6pxb7DuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiMSGwqvEjOKApsKgw4DDg8OVxZLFk8SQ4oCU4oCc4oCd4oCY4oCZw7fil4rvo7/CqeKBhOKCrOKAueKAusOGwrvigJPCt+KAmuKAnuKAsMOCxIfDgcSNw4jDjcOOw4/DjMOTw5TEkcOSw5rDm8OZxLHLhsucwq/PgMOLy5rCuMOKw6bLhycsXG4gICAgJ3gtbWFjLWN5cmlsbGljJzogIC8vIFB5dGhvbjogJ21hY19jeXJpbGxpYydcbiAgICAn0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr+KAoMKw0pDCo8Kn4oCiwrbQhsKuwqnihKLQgtGS4omg0IPRk+KInsKx4omk4oml0ZbCtdKR0IjQhNGU0IfRl9CJ0ZnQitGaJyArXG4gICAgJ9GY0IXCrOKImsaS4omI4oiGwqvCu+KApsKg0IvRm9CM0ZzRleKAk+KAlOKAnOKAneKAmOKAmcO34oCe0I7RntCP0Z/ihJbQgdGR0Y/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv9GA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjicsXG4gICAgJ3gtbWFjLWdhZWxpYyc6IC8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9HQUVMSUMuVFhUXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jhuILCseKJpOKJpeG4g8SKxIvhuIrhuIvhuJ7huJ/EoMSh4bmAw6bDuCcgK1xuICAgICfhuYHhuZbhuZfJvMaSxb/huaDCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZ4bmh4bqbw7/FuOG5quKCrOKAueKAusW2xbfhuavCt+G7suG7s+KBisOCw4rDgcOLw4jDjcOOw4/DjMOTw5TimaPDksOaw5vDmcSxw53DvcW0xbXhuoThuoXhuoDhuoHhuoLhuoMnLFxuICAgICd4LW1hYy1ncmVlayc6ICAvLyBQeXRob246ICdtYWNfZ3JlZWsnXG4gICAgJ8OEwrnCssOJwrPDlsOczoXDoMOiw6TOhMKow6fDqcOow6rDq8Kj4oSiw67Dr+KAosK94oCww7TDtsKm4oKsw7nDu8O84oCgzpPOlM6YzpvOns6gw5/CrsKpzqPOqsKn4omgwrDCt86RwrHiiaTiiaXCpc6SzpXOls6XzpnOms6czqbOq86ozqknICtcbiAgICAnzqzOncKszp/OoeKJiM6kwqvCu+KApsKgzqXOp86GzojFk+KAk+KAleKAnOKAneKAmOKAmcO3zonOis6Mzo7Orc6uzq/PjM6Pz43Osc6yz4jOtM61z4bOs863zrnOvs66zrvOvM69zr/PgM+Oz4HPg8+EzrjPic+Cz4fPhc62z4rPi86QzrBcXHUwMEFEJyxcbiAgICAneC1tYWMtaWNlbGFuZGljJzogIC8vIFB5dGhvbjogJ21hY19pY2VsYW5kJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O8w53CsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcOmw7gnICtcbiAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKsw5DDsMOew77DvcK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG4gICAgJ3gtbWFjLWludWl0JzogLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL0lOVUlULlRYVFxuICAgICfhkIPhkIThkIXhkIbhkIrhkIvhkLHhkLLhkLPhkLThkLjhkLnhkYnhkY7hkY/hkZDhkZHhkZXhkZbhkabhka3hka7hka/hkbDhkbLhkbPhkoPhkovhkozhko3hko7hkpDhkpHCsOGSoeGSpeGSpuKAosK24ZKnwq7CqeKEouGSqOGSquGSq+GSu+GTguGTg+GThOGTheGTh+GTiOGTkOGTr+GTsOGTseGTsuGTtOGTteGUheGTleGTluGTlycgK1xuICAgICfhk5jhk5rhk5vhk6rhlKjhlKnhlKrhlKvhlK3igKbCoOGUruGUvuGVleGVluGVl+KAk+KAlOKAnOKAneKAmOKAmeGVmOGVmeGVmuGVneGVhuGVh+GViOGVieGVi+GVjOGVkOGVv+GWgOGWgeGWguGWg+GWhOGWheGWj+GWkOGWkeGWkuGWk+GWlOGWleGZseGZsuGZs+GZtOGZteGZtuGWluGWoOGWoeGWouGWo+GWpOGWpeGWpuGVvMWBxYInLFxuICAgICd4LW1hYy1jZSc6ICAvLyBQeXRob246ICdtYWNfbGF0aW4yJ1xuICAgICfDhMSAxIHDicSEw5bDnMOhxIXEjMOkxI3EhsSHw6nFucW6xI7DrcSPxJLEk8SWw7PEl8O0w7bDtcO6xJrEm8O84oCgwrDEmMKjwqfigKLCtsOfwq7CqeKEosSZwqjiiaDEo8SuxK/EquKJpOKJpcSrxLbiiILiiJHFgsS7xLzEvcS+xLnEusWFJyArXG4gICAgJ8WGxYPCrOKImsWExYfiiIbCq8K74oCmwqDFiMWQw5XFkcWM4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rFjcWUxZXFmOKAueKAusWZxZbFl8Wg4oCa4oCexaHFmsWbw4HFpMWlw43FvcW+xarDk8OUxavFrsOaxa/FsMWxxbLFs8Odw73Et8W7xYHFvMSiy4cnLFxuICAgIG1hY2ludG9zaDogIC8vIFB5dGhvbjogJ21hY19yb21hbidcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzigLnigLrvrIHvrILigKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4cnLFxuICAgICd4LW1hYy1yb21hbmlhbic6ICAvLyBQeXRob246ICdtYWNfcm9tYW5pYW4nXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMSCyJjiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcSDyJknICtcbiAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKs4oC54oC6yJrIm+KAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG4gICAgJ3gtbWFjLXR1cmtpc2gnOiAgLy8gUHl0aG9uOiAnbWFjX3R1cmtpc2gnXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcOmw7gnICtcbiAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W4xJ7En8SwxLHFnsWf4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nvoqDLhsucwq/LmMuZy5rCuMudy5vLhydcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhbiBvbGQtc3R5bGUgTWFjaW50b3NoIHN0cmluZy4gUmV0dXJucyBlaXRoZXIgYSBVbmljb2RlIEphdmFTY3JpcHRcbiAqIHN0cmluZywgb3IgJ3VuZGVmaW5lZCcgaWYgdGhlIGVuY29kaW5nIGlzIHVuc3VwcG9ydGVkLiBGb3IgZXhhbXBsZSwgd2UgZG9cbiAqIG5vdCBzdXBwb3J0IENoaW5lc2UsIEphcGFuZXNlIG9yIEtvcmVhbiBiZWNhdXNlIHRoZXNlIHdvdWxkIG5lZWQgbGFyZ2VcbiAqIG1hcHBpbmcgdGFibGVzLlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXdcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhTGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmRlY29kZS5NQUNTVFJJTkcgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0LCBkYXRhTGVuZ3RoLCBlbmNvZGluZykge1xuICAgIHZhciB0YWJsZSA9IGVpZ2h0Qml0TWFjRW5jb2RpbmdzW2VuY29kaW5nXTtcbiAgICBpZiAodGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpO1xuICAgICAgICAvLyBJbiBhbGwgZWlnaHQtYml0IE1hYyBlbmNvZGluZ3MsIHRoZSBjaGFyYWN0ZXJzIDB4MDAuLjB4N0YgYXJlXG4gICAgICAgIC8vIG1hcHBlZCB0byBVKzAwMDAuLlUrMDA3Rjsgd2Ugb25seSBuZWVkIHRvIGxvb2sgdXAgdGhlIG90aGVycy5cbiAgICAgICAgaWYgKGMgPD0gMHg3Rikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGFibGVbYyAmIDB4N0ZdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIFRoZSBgR1BPU2AgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycywgYW1vbmcgb3RoZXIgdGhpbmdzLlxuXG4vLyBQYXJzZSB0aGUgbWV0YWRhdGEgYG1ldGFgIHRhYmxlLlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvbnRzL1RydWVUeXBlLVJlZmVyZW5jZS1NYW51YWwvUk0wNi9DaGFwNm1ldGEuaHRtbFxuZnVuY3Rpb24gcGFyc2VNZXRhVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBNRVRBIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgcC5wYXJzZVVMb25nKCk7IC8vIGZsYWdzIC0gY3VycmVudGx5IHVudXNlZCBhbmQgc2V0IHRvIDBcbiAgICBwLnBhcnNlVUxvbmcoKTsgLy8gdGFibGVPZmZzZXRcbiAgICB2YXIgbnVtRGF0YU1hcHMgPSBwLnBhcnNlVUxvbmcoKTtcblxuICAgIHZhciB0YWdzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXRhTWFwczsgaSsrKSB7XG4gICAgICAgIHZhciB0YWcgPSBwLnBhcnNlVGFnKCk7XG4gICAgICAgIHZhciBkYXRhT2Zmc2V0ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIHZhciBkYXRhTGVuZ3RoID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIHZhciB0ZXh0ID0gZGVjb2RlLlVURjgoZGF0YSwgc3RhcnQgKyBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcblxuICAgICAgICB0YWdzW3RhZ10gPSB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGFncztcbn1cblxudmFyIG1ldGEgPSB7IHBhcnNlOiBwYXJzZU1ldGFUYWJsZSB9O1xuXG4vLyBvcGVudHlwZS5qc1xuXG4vKipcbiAqIFRoZSBvcGVudHlwZSBsaWJyYXJ5LlxuICogQG5hbWVzcGFjZSBvcGVudHlwZVxuICovXG5cbi8vIFRhYmxlIERpcmVjdG9yeSBFbnRyaWVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogUGFyc2VzIE9wZW5UeXBlIHRhYmxlIGVudHJpZXMuXG4gKiBAcGFyYW0gIHtEYXRhVmlld31cbiAqIEBwYXJhbSAge051bWJlcn1cbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICovXG5mdW5jdGlvbiBwYXJzZU9wZW5UeXBlVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcykge1xuICAgIHZhciB0YWJsZUVudHJpZXMgPSBbXTtcbiAgICB2YXIgcCA9IDEyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFibGVzOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHRhZyA9IHBhcnNlLmdldFRhZyhkYXRhLCBwKTtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDQpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDEyKTtcbiAgICAgICAgdGFibGVFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICBjaGVja3N1bTogY2hlY2tzdW0sXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgY29tcHJlc3Npb246IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgcCArPSAxNjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGVFbnRyaWVzO1xufVxuXG4vKipcbiAqIFBhcnNlcyBXT0ZGIHRhYmxlIGVudHJpZXMuXG4gKiBAcGFyYW0gIHtEYXRhVmlld31cbiAqIEBwYXJhbSAge051bWJlcn1cbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICovXG5mdW5jdGlvbiBwYXJzZVdPRkZUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKSB7XG4gICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuICAgIHZhciBwID0gNDQ7IC8vIG9mZnNldCB0byB0aGUgZmlyc3QgdGFibGUgZGlyZWN0b3J5IGVudHJ5LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFibGVzOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHRhZyA9IHBhcnNlLmdldFRhZyhkYXRhLCBwKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA0KTtcbiAgICAgICAgdmFyIGNvbXBMZW5ndGggPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgOCk7XG4gICAgICAgIHZhciBvcmlnTGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDEyKTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChjb21wTGVuZ3RoIDwgb3JpZ0xlbmd0aCkge1xuICAgICAgICAgICAgY29tcHJlc3Npb24gPSAnV09GRic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wcmVzc2lvbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFibGVFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvbixcbiAgICAgICAgICAgIGNvbXByZXNzZWRMZW5ndGg6IGNvbXBMZW5ndGgsXG4gICAgICAgICAgICBsZW5ndGg6IG9yaWdMZW5ndGgsXG4gICAgICAgIH0pO1xuICAgICAgICBwICs9IDIwO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZUVudHJpZXM7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgVGFibGVEYXRhXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RGF0YVZpZXd9IGRhdGEgLSBUaGUgRGF0YVZpZXdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgZGF0YSBvZmZzZXQuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gIHtEYXRhVmlld31cbiAqIEBwYXJhbSAge09iamVjdH1cbiAqIEByZXR1cm4ge1RhYmxlRGF0YX1cbiAqL1xuZnVuY3Rpb24gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpIHtcbiAgICBpZiAodGFibGVFbnRyeS5jb21wcmVzc2lvbiA9PT0gJ1dPRkYnKSB7XG4gICAgICAgIHZhciBpbkJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgZGF0YS5idWZmZXIsXG4gICAgICAgICAgICB0YWJsZUVudHJ5Lm9mZnNldCArIDIsXG4gICAgICAgICAgICB0YWJsZUVudHJ5LmNvbXByZXNzZWRMZW5ndGggLSAyXG4gICAgICAgICk7XG4gICAgICAgIHZhciBvdXRCdWZmZXIgPSBuZXcgVWludDhBcnJheSh0YWJsZUVudHJ5Lmxlbmd0aCk7XG4gICAgICAgIGluZmxhdGVTeW5jKGluQnVmZmVyLCBvdXRCdWZmZXIpO1xuICAgICAgICBpZiAob3V0QnVmZmVyLmJ5dGVMZW5ndGggIT09IHRhYmxlRW50cnkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ0RlY29tcHJlc3Npb24gZXJyb3I6ICcgK1xuICAgICAgICAgICAgICAgICAgICB0YWJsZUVudHJ5LnRhZyArXG4gICAgICAgICAgICAgICAgICAgIFwiIGRlY29tcHJlc3NlZCBsZW5ndGggZG9lc24ndCBtYXRjaCByZWNvcmRlZCBsZW5ndGhcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG91dEJ1ZmZlci5idWZmZXIsIDApO1xuICAgICAgICByZXR1cm4geyBkYXRhOiB2aWV3LCBvZmZzZXQ6IDAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBkYXRhOiBkYXRhLCBvZmZzZXQ6IHRhYmxlRW50cnkub2Zmc2V0IH07XG4gICAgfVxufVxuXG4vLyBQdWJsaWMgQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUGFyc2UgdGhlIE9wZW5UeXBlIGZpbGUgZGF0YSAoYXMgYW4gQXJyYXlCdWZmZXIpIGFuZCByZXR1cm4gYSBGb250IG9iamVjdC5cbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgZm9udCBjb3VsZCBub3QgYmUgcGFyc2VkLlxuICogQHBhcmFtICB7QXJyYXlCdWZmZXJ9XG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdCAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAqIEByZXR1cm4ge29wZW50eXBlLkZvbnR9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQnVmZmVyKGJ1ZmZlciwgb3B0KSB7XG4gICAgb3B0ID0gb3B0ID09PSB1bmRlZmluZWQgfHwgb3B0ID09PSBudWxsID8ge30gOiBvcHQ7XG5cbiAgICB2YXIgaW5kZXhUb0xvY0Zvcm1hdDtcblxuICAgIC8vIFNpbmNlIHRoZSBjb25zdHJ1Y3RvciBjYW4gYWxzbyBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBmb250cyBmcm9tIHNjcmF0Y2gsIHdlIGluZGljYXRlIHRoaXNcbiAgICAvLyBzaG91bGQgYmUgYW4gZW1wdHkgZm9udCB0aGF0IHdlJ2xsIGZpbGwgd2l0aCBvdXIgb3duIGRhdGEuXG4gICAgdmFyIGZvbnQgPSBuZXcgRm9udCh7IGVtcHR5OiB0cnVlIH0pO1xuXG4gICAgLy8gT3BlblR5cGUgZm9udHMgdXNlIGJpZyBlbmRpYW4gYnl0ZSBvcmRlcmluZy5cbiAgICAvLyBXZSBjYW4ndCByZWx5IG9uIHR5cGVkIGFycmF5IHZpZXcgdHlwZXMsIGJlY2F1c2UgdGhleSBvcGVyYXRlIHdpdGggdGhlIGVuZGlhbm5lc3Mgb2YgdGhlIGhvc3QgY29tcHV0ZXIuXG4gICAgLy8gSW5zdGVhZCB3ZSB1c2UgRGF0YVZpZXdzIHdoZXJlIHdlIGNhbiBzcGVjaWZ5IGVuZGlhbm5lc3MuXG4gICAgdmFyIGRhdGEgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLCAwKTtcbiAgICB2YXIgbnVtVGFibGVzO1xuICAgIHZhciB0YWJsZUVudHJpZXMgPSBbXTtcbiAgICB2YXIgc2lnbmF0dXJlID0gcGFyc2UuZ2V0VGFnKGRhdGEsIDApO1xuICAgIGlmIChcbiAgICAgICAgc2lnbmF0dXJlID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDAsIDEsIDAsIDApIHx8XG4gICAgICAgIHNpZ25hdHVyZSA9PT0gJ3RydWUnIHx8XG4gICAgICAgIHNpZ25hdHVyZSA9PT0gJ3R5cDEnXG4gICAgKSB7XG4gICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAndHJ1ZXR5cGUnO1xuICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG4gICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKTtcbiAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gJ09UVE8nKSB7XG4gICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcbiAgICAgICAgbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIDQpO1xuICAgICAgICB0YWJsZUVudHJpZXMgPSBwYXJzZU9wZW5UeXBlVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcyk7XG4gICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09ICd3T0ZGJykge1xuICAgICAgICB2YXIgZmxhdm9yID0gcGFyc2UuZ2V0VGFnKGRhdGEsIDQpO1xuICAgICAgICBpZiAoZmxhdm9yID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDAsIDEsIDAsIDApKSB7XG4gICAgICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ3RydWV0eXBlJztcbiAgICAgICAgfSBlbHNlIGlmIChmbGF2b3IgPT09ICdPVFRPJykge1xuICAgICAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICdjZmYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBPcGVuVHlwZSBmbGF2b3IgJyArIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgMTIpO1xuICAgICAgICB0YWJsZUVudHJpZXMgPSBwYXJzZVdPRkZUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIHNpZ25hdHVyZSAnICsgc2lnbmF0dXJlKTtcbiAgICB9XG5cbiAgICB2YXIgY2ZmVGFibGVFbnRyeTtcbiAgICB2YXIgZnZhclRhYmxlRW50cnk7XG4gICAgdmFyIGdseWZUYWJsZUVudHJ5O1xuICAgIHZhciBnZGVmVGFibGVFbnRyeTtcbiAgICB2YXIgZ3Bvc1RhYmxlRW50cnk7XG4gICAgdmFyIGdzdWJUYWJsZUVudHJ5O1xuICAgIHZhciBobXR4VGFibGVFbnRyeTtcbiAgICB2YXIga2VyblRhYmxlRW50cnk7XG4gICAgdmFyIGxvY2FUYWJsZUVudHJ5O1xuICAgIHZhciBtZXRhVGFibGVFbnRyeTtcbiAgICB2YXIgcDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFibGVzOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHRhYmxlRW50cnkgPSB0YWJsZUVudHJpZXNbaV07XG4gICAgICAgIHZhciB0YWJsZSA9ICh2b2lkIDApO1xuICAgICAgICBzd2l0Y2ggKHRhYmxlRW50cnkudGFnKSB7XG4gICAgICAgICAgICBjYXNlICdjbWFwJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5jbWFwID0gY21hcC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQuZW5jb2RpbmcgPSBuZXcgQ21hcEVuY29kaW5nKGZvbnQudGFibGVzLmNtYXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY3Z0ICc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5jdnQgPSBwLnBhcnNlU2hvcnRMaXN0KHRhYmxlRW50cnkubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmdmFyJzpcbiAgICAgICAgICAgICAgICBmdmFyVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmcGdtJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcih0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmZwZ20gPSBwLnBhcnNlQnl0ZUxpc3QodGFibGVFbnRyeS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuaGVhZCA9IGhlYWQucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnVuaXRzUGVyRW0gPSBmb250LnRhYmxlcy5oZWFkLnVuaXRzUGVyRW07XG4gICAgICAgICAgICAgICAgaW5kZXhUb0xvY0Zvcm1hdCA9IGZvbnQudGFibGVzLmhlYWQuaW5kZXhUb0xvY0Zvcm1hdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hoZWEnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmhoZWEgPSBoaGVhLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5hc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuYXNjZW5kZXI7XG4gICAgICAgICAgICAgICAgZm9udC5kZXNjZW5kZXIgPSBmb250LnRhYmxlcy5oaGVhLmRlc2NlbmRlcjtcbiAgICAgICAgICAgICAgICBmb250Lm51bWJlck9mSE1ldHJpY3MgPSBmb250LnRhYmxlcy5oaGVhLm51bWJlck9mSE1ldHJpY3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdobXR4JzpcbiAgICAgICAgICAgICAgICBobXR4VGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsdGFnJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBsdGFnVGFibGUgPSBsdGFnLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtYXhwJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5tYXhwID0gbWF4cC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQubnVtR2x5cGhzID0gZm9udC50YWJsZXMubWF4cC5udW1HbHlwaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdPUy8yJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5vczIgPSBvczIucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Bvc3QnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLnBvc3QgPSBwb3N0LnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwcmVwJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcih0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLnByZXAgPSBwLnBhcnNlQnl0ZUxpc3QodGFibGVFbnRyeS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZ2x5Zic6XG4gICAgICAgICAgICAgICAgZ2x5ZlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbG9jYSc6XG4gICAgICAgICAgICAgICAgbG9jYVRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQ0ZGICc6XG4gICAgICAgICAgICAgICAgY2ZmVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdrZXJuJzpcbiAgICAgICAgICAgICAgICBrZXJuVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdHREVGJzpcbiAgICAgICAgICAgICAgICBnZGVmVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdHUE9TJzpcbiAgICAgICAgICAgICAgICBncG9zVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdHU1VCJzpcbiAgICAgICAgICAgICAgICBnc3ViVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZXRhJzpcbiAgICAgICAgICAgICAgICBtZXRhVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2x5ZlRhYmxlRW50cnkgJiYgbG9jYVRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIHNob3J0VmVyc2lvbiA9IGluZGV4VG9Mb2NGb3JtYXQgPT09IDA7XG4gICAgICAgIHZhciBsb2NhVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbG9jYVRhYmxlRW50cnkpO1xuICAgICAgICB2YXIgbG9jYU9mZnNldHMgPSBsb2NhLnBhcnNlKFxuICAgICAgICAgICAgbG9jYVRhYmxlLmRhdGEsXG4gICAgICAgICAgICBsb2NhVGFibGUub2Zmc2V0LFxuICAgICAgICAgICAgZm9udC5udW1HbHlwaHMsXG4gICAgICAgICAgICBzaG9ydFZlcnNpb25cbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGdseWZUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBnbHlmVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQuZ2x5cGhzID0gZ2x5Zi5wYXJzZShcbiAgICAgICAgICAgIGdseWZUYWJsZS5kYXRhLFxuICAgICAgICAgICAgZ2x5ZlRhYmxlLm9mZnNldCxcbiAgICAgICAgICAgIGxvY2FPZmZzZXRzLFxuICAgICAgICAgICAgZm9udCxcbiAgICAgICAgICAgIG9wdFxuICAgICAgICApO1xuICAgIH0gZWxzZSBpZiAoY2ZmVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgY2ZmVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgY2ZmVGFibGVFbnRyeSk7XG4gICAgICAgIGNmZi5wYXJzZShjZmZUYWJsZS5kYXRhLCBjZmZUYWJsZS5vZmZzZXQsIGZvbnQsIG9wdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9udCBkb2Vzbid0IGNvbnRhaW4gVHJ1ZVR5cGUgb3IgQ0ZGIG91dGxpbmVzLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgaG10eFRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGhtdHhUYWJsZUVudHJ5KTtcbiAgICBobXR4LnBhcnNlKFxuICAgICAgICBmb250LFxuICAgICAgICBobXR4VGFibGUuZGF0YSxcbiAgICAgICAgaG10eFRhYmxlLm9mZnNldCxcbiAgICAgICAgZm9udC5udW1iZXJPZkhNZXRyaWNzLFxuICAgICAgICBmb250Lm51bUdseXBocyxcbiAgICAgICAgZm9udC5nbHlwaHMsXG4gICAgICAgIG9wdFxuICAgICk7XG4gICAgYWRkR2x5cGhOYW1lcyhmb250LCBvcHQpO1xuXG4gICAgaWYgKGtlcm5UYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBrZXJuVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwga2VyblRhYmxlRW50cnkpO1xuICAgICAgICBmb250Lmtlcm5pbmdQYWlycyA9IGtlcm4ucGFyc2Uoa2VyblRhYmxlLmRhdGEsIGtlcm5UYWJsZS5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ge307XG4gICAgfVxuXG4gICAgaWYgKGdkZWZUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBnZGVmVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ2RlZlRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5nZGVmID0gZ2RlZi5wYXJzZShnZGVmVGFibGUuZGF0YSwgZ2RlZlRhYmxlLm9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKGdwb3NUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBncG9zVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ3Bvc1RhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5ncG9zID0gZ3Bvcy5wYXJzZShncG9zVGFibGUuZGF0YSwgZ3Bvc1RhYmxlLm9mZnNldCk7XG4gICAgICAgIGZvbnQucG9zaXRpb24uaW5pdCgpO1xuICAgIH1cblxuICAgIGlmIChnc3ViVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgZ3N1YlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdzdWJUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMuZ3N1YiA9IGdzdWIucGFyc2UoZ3N1YlRhYmxlLmRhdGEsIGdzdWJUYWJsZS5vZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChmdmFyVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgZnZhclRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGZ2YXJUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMuZnZhciA9IGZ2YXIucGFyc2UoXG4gICAgICAgICAgICBmdmFyVGFibGUuZGF0YSxcbiAgICAgICAgICAgIGZ2YXJUYWJsZS5vZmZzZXQsXG4gICAgICAgICAgICBmb250Lm5hbWVzXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG1ldGFUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBtZXRhVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbWV0YVRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5tZXRhID0gbWV0YS5wYXJzZShtZXRhVGFibGUuZGF0YSwgbWV0YVRhYmxlLm9mZnNldCk7XG4gICAgICAgIGZvbnQubWV0YXMgPSBmb250LnRhYmxlcy5tZXRhO1xuICAgIH1cblxuICAgIHJldHVybiBmb250O1xufVxuXG5mdW5jdGlvbiBsb2FkKCkge31cbmZ1bmN0aW9uIGxvYWRTeW5jKCkge31cblxudmFyIG9wZW50eXBlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgX19wcm90b19fOiBudWxsLFxuICAgRm9udDogRm9udCxcbiAgIEdseXBoOiBHbHlwaCxcbiAgIFBhdGg6IFBhdGgsXG4gICBfcGFyc2U6IHBhcnNlLFxuICAgcGFyc2U6IHBhcnNlQnVmZmVyLFxuICAgbG9hZDogbG9hZCxcbiAgIGxvYWRTeW5jOiBsb2FkU3luY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG9wZW50eXBlO1xuZXhwb3J0IHsgRm9udCwgR2x5cGgsIFBhdGgsIHBhcnNlIGFzIF9wYXJzZSwgbG9hZCwgbG9hZFN5bmMsIHBhcnNlQnVmZmVyIGFzIHBhcnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGVudHlwZS5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@shuding/opentype.js/dist/opentype.module.js\n");

/***/ })

};
;